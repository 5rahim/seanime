package onlinestream_providers

var AnimepahePayload = "/// <reference path=\"./onlinestream-provider.d.ts\" />\n/// <reference path=\"../goja_bindings/doc.d.ts\" />\n/// <reference path=\"../goja_bindings/crypto.d.ts\" />\n\nclass Provider {\n\n    api = \"https://animepahe.ru\"\n    headers = { Referer: \"https://kwik.si\" }\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"gogocdn\", \"vidstreaming\", \"streamsb\"],\n            supportsDub: false,\n        }\n    }\n\n    async search(opts: SearchOptions): Promise<SearchResult[]> {\n        const request = await fetch(`${this.api}/api?m=search&q=${encodeURIComponent(opts.query)}`, {\n            headers: {\n                Cookie: \"__ddg1_=;__ddg2_=;\",\n            },\n        })\n\n        if (!request.ok) {\n            return []\n        }\n        const data = (await request.json()) as { data: { id: number; title: string; year: number; poster: string; type: string; session: string }[] }\n        const results: SearchResult[] = []\n\n        if (!data?.data) {\n            return []\n        }\n\n        data.data.map((item: { id: number; title: string; year: number; poster: string; type: string; session: string }) => {\n            const formatString: string = item.type.toUpperCase()\n\n            results.push({\n                subOrDub: \"sub\",\n                id: String(item.id) ?? item.session,\n                title: item.title,\n                url: \"\",\n            })\n        })\n\n        return results\n    }\n\n    async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n        const episodes: EpisodeDetails[] = []\n\n        const req = await (\n            await fetch(\n                `${this.api}${id.includes(\"-\") ? `/anime/${id}` : `/a/${id}`}`,\n                {\n                    headers: {\n                        Cookie: \"__ddg1_=;__ddg2_=;\",\n                    },\n                },\n            )\n        ).text()\n\n        const $ = LoadDoc(req)\n\n        const tempId = $(\"head > meta[property='og:url']\").attr(\"content\")!.split(\"/\").pop()!\n\n        const { last_page, data } = (await (\n            await fetch(`${this.api}/api?m=release&id=${tempId}&sort=episode_asc&page=1`, {\n                headers: {\n                    Cookie: \"__ddg1_=;__ddg2_=;\",\n                },\n            })\n        ).json()) as {\n            last_page: number;\n            data: { id: number; episode: number; title: string; snapshot: string; filler: number; created_at?: string }[]\n        }\n\n        data.map((item: { id: number; episode: number; title: string; snapshot: string; filler: number; created_at?: string }) => {\n            episodes.push({\n                id: item.id + \"$\" + id,\n                number: item.episode,\n                title: item.title && item.title.length > 0 ? item.title : \"Episode \" + item.episode,\n                url: \"\",\n            })\n        })\n\n        const pageNumbers = Array.from({ length: last_page - 1 }, (_, i) => i + 2)\n\n        const promises = pageNumbers.map((pageNumber) =>\n            fetch(`${this.api}/api?m=release&id=${tempId}&sort=episode_asc&page=${pageNumber}`, {\n                headers: {\n                    Cookie: \"__ddg1_=;__ddg2_=;\",\n                },\n            }).then((res) => res.json()),\n        )\n        const results = (await Promise.all(promises)) as {\n            data: { id: number; episode: number; title: string; snapshot: string; filler: number; created_at?: string }[];\n        }[]\n\n        results.forEach((showData) => {\n            for (const data of showData.data) {\n                if (data) {\n\n                    episodes.push({\n                        id: data.id + \"$\" + id,\n                        number: data.episode,\n                        title: data.title && data.title.length > 0 ? data.title : \"Episode \" + data.episode,\n                        url: \"\",\n                    })\n                }\n            }\n        });\n        (data as any[]).sort((a, b) => a.number - b.number)\n        return episodes\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n        const animeId = episode.id.split(\"$\").pop()!\n        const episodeId = episode.id.split(\"$\")[0]\n\n        const req = await fetch(\n            `${this.api}${animeId.includes(\"-\") ? `/anime/${animeId}` : `/a/${animeId}`}`,\n            {\n                headers: {\n                    Cookie: \"__ddg1_=;__ddg2_=;\",\n                },\n            },\n        )\n\n        try {\n            const url = req.url\n            // Need session id to fetch the watch page\n            const sessionId = url.split(\"/anime/\").pop()?.split(\"?\")[0] ?? \"\"\n\n            const $ = LoadDoc(await req.text())\n            const tempId = $(\"head > meta[property='og:url']\").attr(\"content\")!.split(\"/\").pop()!\n            const { last_page, data } = (await (\n                await fetch(\n                    `${this.api}/api?m=release&id=${tempId}&sort=episode_asc&page=1`,\n                    {\n                        headers: {\n                            Cookie: \"__ddg1_=;__ddg2_=;\",\n                        },\n                    },\n                )\n            ).json()) as { last_page: number; data: { id: number; session: string }[] }\n\n\n            let episodeSession = \"\"\n\n            for (let i = 0; i < data.length; i++) {\n                if (String(data[i].id) === episodeId) {\n                    episodeSession = data[i].session\n                    break\n                }\n            }\n\n            if (episodeSession === \"\") {\n                for (let i = 1; i < last_page; i++) {\n                    const data = (await (\n                        await fetch(`${this.api}/api?m=release&id=${tempId}&sort=episode_asc&page=${i + 1}`, {\n                            headers: {\n                                Cookie: \"__ddg1_=;__ddg2_=;\",\n                            },\n                        })\n                    ).json()) as { last_page: number; data: { id: number; session: string }[] }[\"data\"]\n\n                    for (let j = 0; j < data.length; j++) {\n                        if (String(data[j].id) === episodeId) {\n                            episodeSession = data[j].session\n                            break\n                        }\n                    }\n\n                    if (episodeSession !== \"\") break\n                }\n            }\n\n            if (episodeSession === \"\") {\n                throw new Error(\"Episode not found.\")\n            }\n\n            const watchReq = await (\n                await fetch(\n                    `${this.api}/play/${sessionId}/${episodeSession}`,\n                    {\n                        headers: {\n                            Cookie: \"__ddg1_=;__ddg2_=;\",\n                        },\n                    },\n                )\n            ).text()\n\n            const regex = /https:\\/\\/kwik\\.si\\/e\\/\\w+/g\n            const matches = watchReq.match(regex)\n\n            if (matches === null) {\n                throw new Error(\"Failed to fetch episode server.\")\n            }\n\n            const result: EpisodeServer = {\n                videoSources: [],\n                headers: this.headers ?? {},\n                server: \"kwik\",\n            }\n\n            return this.extractKwik(matches[0], result)\n        }\n        catch (e) {\n            console.error(e)\n            throw new Error(\"Failed to fetch episode server.\")\n        }\n    }\n\n    async extractKwik(url: string, result: EpisodeServer): Promise<EpisodeServer> {\n        const host = \"https://animepahe.ru\"\n        const req = await fetch(url, {\n            headers: {\n                Referer: host,\n            },\n        })\n        const $ = LoadDoc(await req.text())\n        // console.log($(\"html\").html())\n        const match = $(\"html\").html()?.match(/p\\}.*kwik.*/g)\n        if (!match) {\n            throw new Error(\"Video not found.\")\n        }\n        let arr: string[] = match[0].split(\"return p}(\")[1].split(\",\")\n\n        const l = arr.slice(0, arr.length - 5).join(\"\")\n        arr = arr.slice(arr.length - 5, -1)\n        arr.unshift(l)\n\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const [p, a, c, k, e, d] = arr.map((x) => x.split(\".sp\")[0])\n\n        console.log(p, a, c, k, e, d)\n\n        const formatted = format(p, a, c, k, e, {})\n\n        console.log(formatted)\n\n        const source = formatted\n            .match(/source=\\\\(.*?)\\\\'/g)[0]\n            .replace(/\\'/g, \"\")\n            .replace(/source=/g, \"\")\n            .replace(/\\\\/g, \"\")\n\n        result.videoSources.push({\n            type: \"m3u8\",\n            url: source,\n            quality: \"auto\",\n            subtitles: [],\n        })\n\n        return result\n\n        function format(p: any, a: any, c: any, k: any, e: any, d: any) {\n            k = k.split(\"|\")\n            e = (c: any) => {\n                return (c < a ? \"\" : e(parseInt((c / a).toString()))) + ((c = c % a) > 35 ? String.fromCharCode(c + 29) : c.toString(36))\n            }\n            if (!\"\".replace(/^/, String)) {\n                while (c--) {\n                    d[e(c)] = k[c] || e(c)\n                }\n                k = [\n                    (e: any) => {\n                        return d[e]\n                    },\n                ]\n                e = () => {\n                    return \"\\\\w+\"\n                }\n                c = 1\n            }\n            while (c--) {\n                if (k[c]) {\n                    p = p.replace(new RegExp(\"\\\\b\" + e(c) + \"\\\\b\", \"g\"), k[c])\n                }\n            }\n            return p\n        }\n    }\n\n\n}\n\n"
