// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package anilist

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

// Activity union type
type ActivityUnion interface {
	IsActivityUnion()
}

// Likeable union type
type LikeableUnion interface {
	IsLikeableUnion()
}

// Notification union type
type NotificationUnion interface {
	IsNotificationUnion()
}

// Notification for when a activity is liked
type ActivityLikeNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The id of the user who liked to the activity
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the activity which was liked
	ActivityID int `json:"activityId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The liked activity
	Activity ActivityUnion `json:"activity,omitempty"`
	// The user who liked the activity
	User *User `json:"user,omitempty"`
}

func (ActivityLikeNotification) IsNotificationUnion() {}

// Notification for when authenticated user is @ mentioned in activity or reply
type ActivityMentionNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The id of the user who mentioned the authenticated user
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the activity where mentioned
	ActivityID int `json:"activityId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The liked activity
	Activity ActivityUnion `json:"activity,omitempty"`
	// The user who mentioned the authenticated user
	User *User `json:"user,omitempty"`
}

func (ActivityMentionNotification) IsNotificationUnion() {}

// Notification for when a user is send an activity message
type ActivityMessageNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The if of the user who send the message
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the activity message
	ActivityID int `json:"activityId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The message activity
	Message *MessageActivity `json:"message,omitempty"`
	// The user who sent the message
	User *User `json:"user,omitempty"`
}

func (ActivityMessageNotification) IsNotificationUnion() {}

// Replay to an activity item
type ActivityReply struct {
	// The id of the reply
	ID int `json:"id"`
	// The id of the replies creator
	UserID *int `json:"userId,omitempty"`
	// The id of the parent activity
	ActivityID *int `json:"activityId,omitempty"`
	// The reply text
	Text *string `json:"text,omitempty"`
	// The amount of likes the reply has
	LikeCount int `json:"likeCount"`
	// If the currently authenticated user liked the reply
	IsLiked *bool `json:"isLiked,omitempty"`
	// The time the reply was created at
	CreatedAt int `json:"createdAt"`
	// The user who created reply
	User *User `json:"user,omitempty"`
	// The users who liked the reply
	Likes []*User `json:"likes,omitempty"`
}

func (ActivityReply) IsLikeableUnion() {}

// Notification for when a activity reply is liked
type ActivityReplyLikeNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The id of the user who liked to the activity reply
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the activity where the reply which was liked
	ActivityID int `json:"activityId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The liked activity
	Activity ActivityUnion `json:"activity,omitempty"`
	// The user who liked the activity reply
	User *User `json:"user,omitempty"`
}

func (ActivityReplyLikeNotification) IsNotificationUnion() {}

// Notification for when a user replies to the authenticated users activity
type ActivityReplyNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The id of the user who replied to the activity
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the activity which was replied too
	ActivityID int `json:"activityId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The liked activity
	Activity ActivityUnion `json:"activity,omitempty"`
	// The user who replied to the activity
	User *User `json:"user,omitempty"`
}

func (ActivityReplyNotification) IsNotificationUnion() {}

// Notification for when a user replies to activity the authenticated user has replied to
type ActivityReplySubscribedNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The id of the user who replied to the activity
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the activity which was replied too
	ActivityID int `json:"activityId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The liked activity
	Activity ActivityUnion `json:"activity,omitempty"`
	// The user who replied to the activity
	User *User `json:"user,omitempty"`
}

func (ActivityReplySubscribedNotification) IsNotificationUnion() {}

// Notification for when an episode of anime airs
type AiringNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the aired anime
	AnimeID int `json:"animeId"`
	// The episode number that just aired
	Episode int `json:"episode"`
	// The notification context text
	Contexts []*string `json:"contexts,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The associated media of the airing schedule
	Media *Media `json:"media,omitempty"`
}

func (AiringNotification) IsNotificationUnion() {}

// Score & Watcher stats for airing anime by episode and mid-week
type AiringProgression struct {
	// The episode the stats were recorded at. .5 is the mid point between 2 episodes airing dates.
	Episode *float64 `json:"episode,omitempty"`
	// The average score for the media
	Score *float64 `json:"score,omitempty"`
	// The amount of users watching the anime
	Watching *int `json:"watching,omitempty"`
}

// Media Airing Schedule. NOTE: We only aim to guarantee that FUTURE airing data is present and accurate.
type AiringSchedule struct {
	// The id of the airing schedule item
	ID int `json:"id"`
	// The time the episode airs at
	AiringAt int `json:"airingAt"`
	// Seconds until episode starts airing
	TimeUntilAiring int `json:"timeUntilAiring"`
	// The airing episode number
	Episode int `json:"episode"`
	// The associate media id of the airing episode
	MediaID int `json:"mediaId"`
	// The associate media of the airing episode
	Media *Media `json:"media,omitempty"`
}

type AiringScheduleConnection struct {
	Edges []*AiringScheduleEdge `json:"edges,omitempty"`
	Nodes []*AiringSchedule     `json:"nodes,omitempty"`
	// The pagination information
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

// AiringSchedule connection edge
type AiringScheduleEdge struct {
	Node *AiringSchedule `json:"node,omitempty"`
	// The id of the connection
	ID *int `json:"id,omitempty"`
}

type AiringScheduleInput struct {
	AiringAt        *int `json:"airingAt,omitempty"`
	Episode         *int `json:"episode,omitempty"`
	TimeUntilAiring *int `json:"timeUntilAiring,omitempty"`
}

type AniChartHighlightInput struct {
	MediaID   *int    `json:"mediaId,omitempty"`
	Highlight *string `json:"highlight,omitempty"`
}

type AniChartUser struct {
	User       *User   `json:"user,omitempty"`
	Settings   *string `json:"settings,omitempty"`
	Highlights *string `json:"highlights,omitempty"`
}

// A character that features in an anime or manga
type Character struct {
	// The id of the character
	ID int `json:"id"`
	// The names of the character
	Name *CharacterName `json:"name,omitempty"`
	// Character images
	Image *CharacterImage `json:"image,omitempty"`
	// A general description of the character
	Description *string `json:"description,omitempty"`
	// The character's gender. Usually Male, Female, or Non-binary but can be any string.
	Gender *string `json:"gender,omitempty"`
	// The character's birth date
	DateOfBirth *FuzzyDate `json:"dateOfBirth,omitempty"`
	// The character's age. Note this is a string, not an int, it may contain further text and additional ages.
	Age *string `json:"age,omitempty"`
	// The characters blood type
	BloodType *string `json:"bloodType,omitempty"`
	// If the character is marked as favourite by the currently authenticated user
	IsFavourite bool `json:"isFavourite"`
	// If the character is blocked from being added to favourites
	IsFavouriteBlocked bool `json:"isFavouriteBlocked"`
	// The url for the character page on the AniList website
	SiteURL *string `json:"siteUrl,omitempty"`
	// Media that includes the character
	Media     *MediaConnection `json:"media,omitempty"`
	UpdatedAt *int             `json:"updatedAt,omitempty"`
	// The amount of user's who have favourited the character
	Favourites *int `json:"favourites,omitempty"`
	// Notes for site moderators
	ModNotes *string `json:"modNotes,omitempty"`
}

type CharacterConnection struct {
	Edges []*CharacterEdge `json:"edges,omitempty"`
	Nodes []*Character     `json:"nodes,omitempty"`
	// The pagination information
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

// Character connection edge
type CharacterEdge struct {
	Node *Character `json:"node,omitempty"`
	// The id of the connection
	ID *int `json:"id,omitempty"`
	// The characters role in the media
	Role *CharacterRole `json:"role,omitempty"`
	// Media specific character name
	Name *string `json:"name,omitempty"`
	// The voice actors of the character
	VoiceActors []*Staff `json:"voiceActors,omitempty"`
	// The voice actors of the character with role date
	VoiceActorRoles []*StaffRoleType `json:"voiceActorRoles,omitempty"`
	// The media the character is in
	Media []*Media `json:"media,omitempty"`
	// The order the character should be displayed from the users favourites
	FavouriteOrder *int `json:"favouriteOrder,omitempty"`
}

type CharacterImage struct {
	// The character's image of media at its largest size
	Large *string `json:"large,omitempty"`
	// The character's image of media at medium size
	Medium *string `json:"medium,omitempty"`
}

// The names of the character
type CharacterName struct {
	// The character's given name
	First *string `json:"first,omitempty"`
	// The character's middle name
	Middle *string `json:"middle,omitempty"`
	// The character's surname
	Last *string `json:"last,omitempty"`
	// The character's first and last name
	Full *string `json:"full,omitempty"`
	// The character's full name in their native language
	Native *string `json:"native,omitempty"`
	// Other names the character might be referred to as
	Alternative []*string `json:"alternative,omitempty"`
	// Other names the character might be referred to as but are spoilers
	AlternativeSpoiler []*string `json:"alternativeSpoiler,omitempty"`
	// The currently authenticated users preferred name language. Default romaji for non-authenticated
	UserPreferred *string `json:"userPreferred,omitempty"`
}

// The names of the character
type CharacterNameInput struct {
	// The character's given name
	First *string `json:"first,omitempty"`
	// The character's middle name
	Middle *string `json:"middle,omitempty"`
	// The character's surname
	Last *string `json:"last,omitempty"`
	// The character's full name in their native language
	Native *string `json:"native,omitempty"`
	// Other names the character might be referred by
	Alternative []*string `json:"alternative,omitempty"`
	// Other names the character might be referred to as but are spoilers
	AlternativeSpoiler []*string `json:"alternativeSpoiler,omitempty"`
}

// A submission for a character that features in an anime or manga
type CharacterSubmission struct {
	// The id of the submission
	ID int `json:"id"`
	// Character that the submission is referencing
	Character *Character `json:"character,omitempty"`
	// The character submission changes
	Submission *Character `json:"submission,omitempty"`
	// Submitter for the submission
	Submitter *User `json:"submitter,omitempty"`
	// Data Mod assigned to handle the submission
	Assignee *User `json:"assignee,omitempty"`
	// Status of the submission
	Status *SubmissionStatus `json:"status,omitempty"`
	// Inner details of submission status
	Notes  *string `json:"notes,omitempty"`
	Source *string `json:"source,omitempty"`
	// Whether the submission is locked
	Locked    *bool `json:"locked,omitempty"`
	CreatedAt *int  `json:"createdAt,omitempty"`
}

type CharacterSubmissionConnection struct {
	Edges []*CharacterSubmissionEdge `json:"edges,omitempty"`
	Nodes []*CharacterSubmission     `json:"nodes,omitempty"`
	// The pagination information
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

// CharacterSubmission connection edge
type CharacterSubmissionEdge struct {
	Node *CharacterSubmission `json:"node,omitempty"`
	// The characters role in the media
	Role *CharacterRole `json:"role,omitempty"`
	// The voice actors of the character
	VoiceActors []*Staff `json:"voiceActors,omitempty"`
	// The submitted voice actors of the character
	SubmittedVoiceActors []*StaffSubmission `json:"submittedVoiceActors,omitempty"`
}

// Deleted data type
type Deleted struct {
	// If an item has been successfully deleted
	Deleted *bool `json:"deleted,omitempty"`
}

// User's favourite anime, manga, characters, staff & studios
type Favourites struct {
	// Favourite anime
	Anime *MediaConnection `json:"anime,omitempty"`
	// Favourite manga
	Manga *MediaConnection `json:"manga,omitempty"`
	// Favourite characters
	Characters *CharacterConnection `json:"characters,omitempty"`
	// Favourite staff
	Staff *StaffConnection `json:"staff,omitempty"`
	// Favourite studios
	Studios *StudioConnection `json:"studios,omitempty"`
}

// Notification for when the authenticated user is followed by another user
type FollowingNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The id of the user who followed the authenticated user
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The liked activity
	User *User `json:"user,omitempty"`
}

func (FollowingNotification) IsNotificationUnion() {}

// User's format statistics
type FormatStats struct {
	Format *MediaFormat `json:"format,omitempty"`
	Amount *int         `json:"amount,omitempty"`
}

// Date object that allows for incomplete date values (fuzzy)
type FuzzyDate struct {
	// Numeric Year (2017)
	Year *int `json:"year,omitempty"`
	// Numeric Month (3)
	Month *int `json:"month,omitempty"`
	// Numeric Day (24)
	Day *int `json:"day,omitempty"`
}

// Date object that allows for incomplete date values (fuzzy)
type FuzzyDateInput struct {
	// Numeric Year (2017)
	Year *int `json:"year,omitempty"`
	// Numeric Month (3)
	Month *int `json:"month,omitempty"`
	// Numeric Day (24)
	Day *int `json:"day,omitempty"`
}

// User's genre statistics
type GenreStats struct {
	Genre     *string `json:"genre,omitempty"`
	Amount    *int    `json:"amount,omitempty"`
	MeanScore *int    `json:"meanScore,omitempty"`
	// The amount of time in minutes the genre has been watched by the user
	TimeWatched *int `json:"timeWatched,omitempty"`
}

// Page of data (Used for internal use only)
type InternalPage struct {
	MediaSubmissions     []*MediaSubmission     `json:"mediaSubmissions,omitempty"`
	CharacterSubmissions []*CharacterSubmission `json:"characterSubmissions,omitempty"`
	StaffSubmissions     []*StaffSubmission     `json:"staffSubmissions,omitempty"`
	RevisionHistory      []*RevisionHistory     `json:"revisionHistory,omitempty"`
	Reports              []*Report              `json:"reports,omitempty"`
	ModActions           []*ModAction           `json:"modActions,omitempty"`
	UserBlockSearch      []*User                `json:"userBlockSearch,omitempty"`
	// The pagination information
	PageInfo        *PageInfo           `json:"pageInfo,omitempty"`
	Users           []*User             `json:"users,omitempty"`
	Media           []*Media            `json:"media,omitempty"`
	Characters      []*Character        `json:"characters,omitempty"`
	Staff           []*Staff            `json:"staff,omitempty"`
	Studios         []*Studio           `json:"studios,omitempty"`
	MediaList       []*MediaList        `json:"mediaList,omitempty"`
	AiringSchedules []*AiringSchedule   `json:"airingSchedules,omitempty"`
	MediaTrends     []*MediaTrend       `json:"mediaTrends,omitempty"`
	Notifications   []NotificationUnion `json:"notifications,omitempty"`
	Followers       []*User             `json:"followers,omitempty"`
	Following       []*User             `json:"following,omitempty"`
	Activities      []ActivityUnion     `json:"activities,omitempty"`
	ActivityReplies []*ActivityReply    `json:"activityReplies,omitempty"`
	Threads         []*Thread           `json:"threads,omitempty"`
	ThreadComments  []*ThreadComment    `json:"threadComments,omitempty"`
	Reviews         []*Review           `json:"reviews,omitempty"`
	Recommendations []*Recommendation   `json:"recommendations,omitempty"`
	Likes           []*User             `json:"likes,omitempty"`
}

// User list activity (anime & manga updates)
type ListActivity struct {
	// The id of the activity
	ID int `json:"id"`
	// The user id of the activity's creator
	UserID *int `json:"userId,omitempty"`
	// The type of activity
	Type *ActivityType `json:"type,omitempty"`
	// The number of activity replies
	ReplyCount int `json:"replyCount"`
	// The list item's textual status
	Status *string `json:"status,omitempty"`
	// The list progress made
	Progress *string `json:"progress,omitempty"`
	// If the activity is locked and can receive replies
	IsLocked *bool `json:"isLocked,omitempty"`
	// If the currently authenticated user is subscribed to the activity
	IsSubscribed *bool `json:"isSubscribed,omitempty"`
	// The amount of likes the activity has
	LikeCount int `json:"likeCount"`
	// If the currently authenticated user liked the activity
	IsLiked *bool `json:"isLiked,omitempty"`
	// If the activity is pinned to the top of the users activity feed
	IsPinned *bool `json:"isPinned,omitempty"`
	// The url for the activity page on the AniList website
	SiteURL *string `json:"siteUrl,omitempty"`
	// The time the activity was created at
	CreatedAt int `json:"createdAt"`
	// The owner of the activity
	User *User `json:"user,omitempty"`
	// The associated media to the activity update
	Media *Media `json:"media,omitempty"`
	// The written replies to the activity
	Replies []*ActivityReply `json:"replies,omitempty"`
	// The users who liked the activity
	Likes []*User `json:"likes,omitempty"`
}

func (ListActivity) IsActivityUnion() {}

func (ListActivity) IsLikeableUnion() {}

type ListActivityOption struct {
	Disabled *bool            `json:"disabled,omitempty"`
	Type     *MediaListStatus `json:"type,omitempty"`
}

type ListActivityOptionInput struct {
	Disabled *bool            `json:"disabled,omitempty"`
	Type     *MediaListStatus `json:"type,omitempty"`
}

// User's list score statistics
type ListScoreStats struct {
	MeanScore         *int `json:"meanScore,omitempty"`
	StandardDeviation *int `json:"standardDeviation,omitempty"`
}

// Anime or Manga
type Media struct {
	// The id of the media
	ID int `json:"id"`
	// The mal id of the media
	IDMal *int `json:"idMal,omitempty"`
	// The official titles of the media in various languages
	Title *MediaTitle `json:"title,omitempty"`
	// The type of the media; anime or manga
	Type *MediaType `json:"type,omitempty"`
	// The format the media was released in
	Format *MediaFormat `json:"format,omitempty"`
	// The current releasing status of the media
	Status *MediaStatus `json:"status,omitempty"`
	// Short description of the media's story and characters
	Description *string `json:"description,omitempty"`
	// The first official release date of the media
	StartDate *FuzzyDate `json:"startDate,omitempty"`
	// The last official release date of the media
	EndDate *FuzzyDate `json:"endDate,omitempty"`
	// The season the media was initially released in
	Season *MediaSeason `json:"season,omitempty"`
	// The season year the media was initially released in
	SeasonYear *int `json:"seasonYear,omitempty"`
	// The year & season the media was initially released in
	SeasonInt *int `json:"seasonInt,omitempty"`
	// The amount of episodes the anime has when complete
	Episodes *int `json:"episodes,omitempty"`
	// The general length of each anime episode in minutes
	Duration *int `json:"duration,omitempty"`
	// The amount of chapters the manga has when complete
	Chapters *int `json:"chapters,omitempty"`
	// The amount of volumes the manga has when complete
	Volumes *int `json:"volumes,omitempty"`
	// Where the media was created. (ISO 3166-1 alpha-2)
	CountryOfOrigin *string `json:"countryOfOrigin,omitempty"`
	// If the media is officially licensed or a self-published doujin release
	IsLicensed *bool `json:"isLicensed,omitempty"`
	// Source type the media was adapted from.
	Source *MediaSource `json:"source,omitempty"`
	// Official Twitter hashtags for the media
	Hashtag *string `json:"hashtag,omitempty"`
	// Media trailer or advertisement
	Trailer *MediaTrailer `json:"trailer,omitempty"`
	// When the media's data was last updated
	UpdatedAt *int `json:"updatedAt,omitempty"`
	// The cover images of the media
	CoverImage *MediaCoverImage `json:"coverImage,omitempty"`
	// The banner image of the media
	BannerImage *string `json:"bannerImage,omitempty"`
	// The genres of the media
	Genres []*string `json:"genres,omitempty"`
	// Alternative titles of the media
	Synonyms []*string `json:"synonyms,omitempty"`
	// A weighted average score of all the user's scores of the media
	AverageScore *int `json:"averageScore,omitempty"`
	// Mean score of all the user's scores of the media
	MeanScore *int `json:"meanScore,omitempty"`
	// The number of users with the media on their list
	Popularity *int `json:"popularity,omitempty"`
	// Locked media may not be added to lists our favorited. This may be due to the entry pending for deletion or other reasons.
	IsLocked *bool `json:"isLocked,omitempty"`
	// The amount of related activity in the past hour
	Trending *int `json:"trending,omitempty"`
	// The amount of user's who have favourited the media
	Favourites *int `json:"favourites,omitempty"`
	// List of tags that describes elements and themes of the media
	Tags []*MediaTag `json:"tags,omitempty"`
	// Other media in the same or connecting franchise
	Relations *MediaConnection `json:"relations,omitempty"`
	// The characters in the media
	Characters *CharacterConnection `json:"characters,omitempty"`
	// The staff who produced the media
	Staff *StaffConnection `json:"staff,omitempty"`
	// The companies who produced the media
	Studios *StudioConnection `json:"studios,omitempty"`
	// If the media is marked as favourite by the current authenticated user
	IsFavourite bool `json:"isFavourite"`
	// If the media is blocked from being added to favourites
	IsFavouriteBlocked bool `json:"isFavouriteBlocked"`
	// If the media is intended only for 18+ adult audiences
	IsAdult *bool `json:"isAdult,omitempty"`
	// The media's next episode airing schedule
	NextAiringEpisode *AiringSchedule `json:"nextAiringEpisode,omitempty"`
	// The media's entire airing schedule
	AiringSchedule *AiringScheduleConnection `json:"airingSchedule,omitempty"`
	// The media's daily trend stats
	Trends *MediaTrendConnection `json:"trends,omitempty"`
	// External links to another site related to the media
	ExternalLinks []*MediaExternalLink `json:"externalLinks,omitempty"`
	// Data and links to legal streaming episodes on external sites
	StreamingEpisodes []*MediaStreamingEpisode `json:"streamingEpisodes,omitempty"`
	// The ranking of the media in a particular time span and format compared to other media
	Rankings []*MediaRank `json:"rankings,omitempty"`
	// The authenticated user's media list entry for the media
	MediaListEntry *MediaList `json:"mediaListEntry,omitempty"`
	// User reviews of the media
	Reviews *ReviewConnection `json:"reviews,omitempty"`
	// User recommendations for similar media
	Recommendations *RecommendationConnection `json:"recommendations,omitempty"`
	Stats           *MediaStats               `json:"stats,omitempty"`
	// The url for the media page on the AniList website
	SiteURL *string `json:"siteUrl,omitempty"`
	// If the media should have forum thread automatically created for it on airing episode release
	AutoCreateForumThread *bool `json:"autoCreateForumThread,omitempty"`
	// If the media is blocked from being recommended to/from
	IsRecommendationBlocked *bool `json:"isRecommendationBlocked,omitempty"`
	// If the media is blocked from being reviewed
	IsReviewBlocked *bool `json:"isReviewBlocked,omitempty"`
	// Notes for site moderators
	ModNotes *string `json:"modNotes,omitempty"`
}

// Internal - Media characters separated
type MediaCharacter struct {
	// The id of the connection
	ID *int `json:"id,omitempty"`
	// The characters role in the media
	Role      *CharacterRole `json:"role,omitempty"`
	RoleNotes *string        `json:"roleNotes,omitempty"`
	DubGroup  *string        `json:"dubGroup,omitempty"`
	// Media specific character name
	CharacterName *string `json:"characterName,omitempty"`
	// The characters in the media voiced by the parent actor
	Character *Character `json:"character,omitempty"`
	// The voice actor of the character
	VoiceActor *Staff `json:"voiceActor,omitempty"`
}

type MediaConnection struct {
	Edges []*MediaEdge `json:"edges,omitempty"`
	Nodes []*Media     `json:"nodes,omitempty"`
	// The pagination information
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

type MediaCoverImage struct {
	// The cover image url of the media at its largest size. If this size isn't available, large will be provided instead.
	ExtraLarge *string `json:"extraLarge,omitempty"`
	// The cover image url of the media at a large size
	Large *string `json:"large,omitempty"`
	// The cover image url of the media at medium size
	Medium *string `json:"medium,omitempty"`
	// Average #hex color of cover image
	Color *string `json:"color,omitempty"`
}

// Notification for when a media entry's data was changed in a significant way impacting users' list tracking
type MediaDataChangeNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the media that received data changes
	MediaID int `json:"mediaId"`
	// The reason for the media data change
	Context *string `json:"context,omitempty"`
	// The reason for the media data change
	Reason *string `json:"reason,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The media that received data changes
	Media *Media `json:"media,omitempty"`
}

func (MediaDataChangeNotification) IsNotificationUnion() {}

// Notification for when a media tracked in a user's list is deleted from the site
type MediaDeletionNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The title of the deleted media
	DeletedMediaTitle *string `json:"deletedMediaTitle,omitempty"`
	// The reason for the media deletion
	Context *string `json:"context,omitempty"`
	// The reason for the media deletion
	Reason *string `json:"reason,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
}

func (MediaDeletionNotification) IsNotificationUnion() {}

// Media connection edge
type MediaEdge struct {
	Node *Media `json:"node,omitempty"`
	// The id of the connection
	ID *int `json:"id,omitempty"`
	// The type of relation to the parent model
	RelationType *MediaRelation `json:"relationType,omitempty"`
	// If the studio is the main animation studio of the media (For Studio->MediaConnection field only)
	IsMainStudio bool `json:"isMainStudio"`
	// The characters in the media voiced by the parent actor
	Characters []*Character `json:"characters,omitempty"`
	// The characters role in the media
	CharacterRole *CharacterRole `json:"characterRole,omitempty"`
	// Media specific character name
	CharacterName *string `json:"characterName,omitempty"`
	// Notes regarding the VA's role for the character
	RoleNotes *string `json:"roleNotes,omitempty"`
	// Used for grouping roles where multiple dubs exist for the same language. Either dubbing company name or language variant.
	DubGroup *string `json:"dubGroup,omitempty"`
	// The role of the staff member in the production of the media
	StaffRole *string `json:"staffRole,omitempty"`
	// The voice actors of the character
	VoiceActors []*Staff `json:"voiceActors,omitempty"`
	// The voice actors of the character with role date
	VoiceActorRoles []*StaffRoleType `json:"voiceActorRoles,omitempty"`
	// The order the media should be displayed from the users favourites
	FavouriteOrder *int `json:"favouriteOrder,omitempty"`
}

// An external link to another site related to the media or staff member
type MediaExternalLink struct {
	// The id of the external link
	ID int `json:"id"`
	// The url of the external link or base url of link source
	URL *string `json:"url,omitempty"`
	// The links website site name
	Site string `json:"site"`
	// The links website site id
	SiteID *int              `json:"siteId,omitempty"`
	Type   *ExternalLinkType `json:"type,omitempty"`
	// Language the site content is in. See Staff language field for values.
	Language *string `json:"language,omitempty"`
	Color    *string `json:"color,omitempty"`
	// The icon image url of the site. Not available for all links. Transparent PNG 64x64
	Icon       *string `json:"icon,omitempty"`
	Notes      *string `json:"notes,omitempty"`
	IsDisabled *bool   `json:"isDisabled,omitempty"`
}

// An external link to another site related to the media
type MediaExternalLinkInput struct {
	// The id of the external link
	ID int `json:"id"`
	// The url of the external link
	URL string `json:"url"`
	// The site location of the external link
	Site string `json:"site"`
}

// List of anime or manga
type MediaList struct {
	// The id of the list entry
	ID int `json:"id"`
	// The id of the user owner of the list entry
	UserID int `json:"userId"`
	// The id of the media
	MediaID int `json:"mediaId"`
	// The watching/reading status
	Status *MediaListStatus `json:"status,omitempty"`
	// The score of the entry
	Score *float64 `json:"score,omitempty"`
	// The amount of episodes/chapters consumed by the user
	Progress *int `json:"progress,omitempty"`
	// The amount of volumes read by the user
	ProgressVolumes *int `json:"progressVolumes,omitempty"`
	// The amount of times the user has rewatched/read the media
	Repeat *int `json:"repeat,omitempty"`
	// Priority of planning
	Priority *int `json:"priority,omitempty"`
	// If the entry should only be visible to authenticated user
	Private *bool `json:"private,omitempty"`
	// Text notes
	Notes *string `json:"notes,omitempty"`
	// If the entry shown be hidden from non-custom lists
	HiddenFromStatusLists *bool `json:"hiddenFromStatusLists,omitempty"`
	// Map of booleans for which custom lists the entry are in
	CustomLists *string `json:"customLists,omitempty"`
	// Map of advanced scores with name keys
	AdvancedScores *string `json:"advancedScores,omitempty"`
	// When the entry was started by the user
	StartedAt *FuzzyDate `json:"startedAt,omitempty"`
	// When the entry was completed by the user
	CompletedAt *FuzzyDate `json:"completedAt,omitempty"`
	// When the entry data was last updated
	UpdatedAt *int `json:"updatedAt,omitempty"`
	// When the entry data was created
	CreatedAt *int   `json:"createdAt,omitempty"`
	Media     *Media `json:"media,omitempty"`
	User      *User  `json:"user,omitempty"`
}

// List of anime or manga
type MediaListCollection struct {
	// Grouped media list entries
	Lists []*MediaListGroup `json:"lists,omitempty"`
	// The owner of the list
	User *User `json:"user,omitempty"`
	// If there is another chunk
	HasNextChunk *bool `json:"hasNextChunk,omitempty"`
	// A map of media list entry arrays grouped by status
	StatusLists [][]*MediaList `json:"statusLists,omitempty"`
	// A map of media list entry arrays grouped by custom lists
	CustomLists [][]*MediaList `json:"customLists,omitempty"`
}

// List group of anime or manga entries
type MediaListGroup struct {
	// Media list entries
	Entries              []*MediaList     `json:"entries,omitempty"`
	Name                 *string          `json:"name,omitempty"`
	IsCustomList         *bool            `json:"isCustomList,omitempty"`
	IsSplitCompletedList *bool            `json:"isSplitCompletedList,omitempty"`
	Status               *MediaListStatus `json:"status,omitempty"`
}

// A user's list options
type MediaListOptions struct {
	// The score format the user is using for media lists
	ScoreFormat *ScoreFormat `json:"scoreFormat,omitempty"`
	// The default order list rows should be displayed in
	RowOrder       *string `json:"rowOrder,omitempty"`
	UseLegacyLists *bool   `json:"useLegacyLists,omitempty"`
	// The user's anime list options
	AnimeList *MediaListTypeOptions `json:"animeList,omitempty"`
	// The user's manga list options
	MangaList *MediaListTypeOptions `json:"mangaList,omitempty"`
	// The list theme options for both lists
	SharedTheme *string `json:"sharedTheme,omitempty"`
	// If the shared theme should be used instead of the individual list themes
	SharedThemeEnabled *bool `json:"sharedThemeEnabled,omitempty"`
}

// A user's list options for anime or manga lists
type MediaListOptionsInput struct {
	// The order each list should be displayed in
	SectionOrder []*string `json:"sectionOrder,omitempty"`
	// If the completed sections of the list should be separated by format
	SplitCompletedSectionByFormat *bool `json:"splitCompletedSectionByFormat,omitempty"`
	// The names of the user's custom lists
	CustomLists []*string `json:"customLists,omitempty"`
	// The names of the user's advanced scoring sections
	AdvancedScoring []*string `json:"advancedScoring,omitempty"`
	// If advanced scoring is enabled
	AdvancedScoringEnabled *bool `json:"advancedScoringEnabled,omitempty"`
	// list theme
	Theme *string `json:"theme,omitempty"`
}

// A user's list options for anime or manga lists
type MediaListTypeOptions struct {
	// The order each list should be displayed in
	SectionOrder []*string `json:"sectionOrder,omitempty"`
	// If the completed sections of the list should be separated by format
	SplitCompletedSectionByFormat *bool `json:"splitCompletedSectionByFormat,omitempty"`
	// The list theme options
	Theme *string `json:"theme,omitempty"`
	// The names of the user's custom lists
	CustomLists []*string `json:"customLists,omitempty"`
	// The names of the user's advanced scoring sections
	AdvancedScoring []*string `json:"advancedScoring,omitempty"`
	// If advanced scoring is enabled
	AdvancedScoringEnabled *bool `json:"advancedScoringEnabled,omitempty"`
}

// Notification for when a media entry is merged into another for a user who had it on their list
type MediaMergeNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the media that was merged into
	MediaID int `json:"mediaId"`
	// The title of the deleted media
	DeletedMediaTitles []*string `json:"deletedMediaTitles,omitempty"`
	// The reason for the media data change
	Context *string `json:"context,omitempty"`
	// The reason for the media merge
	Reason *string `json:"reason,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The media that was merged into
	Media *Media `json:"media,omitempty"`
}

func (MediaMergeNotification) IsNotificationUnion() {}

// The ranking of a media in a particular time span and format compared to other media
type MediaRank struct {
	// The id of the rank
	ID int `json:"id"`
	// The numerical rank of the media
	Rank int `json:"rank"`
	// The type of ranking
	Type MediaRankType `json:"type"`
	// The format the media is ranked within
	Format MediaFormat `json:"format"`
	// The year the media is ranked within
	Year *int `json:"year,omitempty"`
	// The season the media is ranked within
	Season *MediaSeason `json:"season,omitempty"`
	// If the ranking is based on all time instead of a season/year
	AllTime *bool `json:"allTime,omitempty"`
	// String that gives context to the ranking type and time span
	Context string `json:"context"`
}

// A media's statistics
type MediaStats struct {
	ScoreDistribution  []*ScoreDistribution  `json:"scoreDistribution,omitempty"`
	StatusDistribution []*StatusDistribution `json:"statusDistribution,omitempty"`
	AiringProgression  []*AiringProgression  `json:"airingProgression,omitempty"`
}

// Data and links to legal streaming episodes on external sites
type MediaStreamingEpisode struct {
	// Title of the episode
	Title *string `json:"title,omitempty"`
	// Url of episode image thumbnail
	Thumbnail *string `json:"thumbnail,omitempty"`
	// The url of the episode
	URL *string `json:"url,omitempty"`
	// The site location of the streaming episodes
	Site *string `json:"site,omitempty"`
}

// Media submission
type MediaSubmission struct {
	// The id of the submission
	ID int `json:"id"`
	// User submitter of the submission
	Submitter *User `json:"submitter,omitempty"`
	// Data Mod assigned to handle the submission
	Assignee *User `json:"assignee,omitempty"`
	// Status of the submission
	Status         *SubmissionStatus `json:"status,omitempty"`
	SubmitterStats *string           `json:"submitterStats,omitempty"`
	Notes          *string           `json:"notes,omitempty"`
	Source         *string           `json:"source,omitempty"`
	Changes        []*string         `json:"changes,omitempty"`
	// Whether the submission is locked
	Locked        *bool                        `json:"locked,omitempty"`
	Media         *Media                       `json:"media,omitempty"`
	Submission    *Media                       `json:"submission,omitempty"`
	Characters    []*MediaSubmissionComparison `json:"characters,omitempty"`
	Staff         []*MediaSubmissionComparison `json:"staff,omitempty"`
	Studios       []*MediaSubmissionComparison `json:"studios,omitempty"`
	Relations     []*MediaEdge                 `json:"relations,omitempty"`
	ExternalLinks []*MediaSubmissionComparison `json:"externalLinks,omitempty"`
	CreatedAt     *int                         `json:"createdAt,omitempty"`
}

// Media submission with comparison to current data
type MediaSubmissionComparison struct {
	Submission   *MediaSubmissionEdge `json:"submission,omitempty"`
	Character    *MediaCharacter      `json:"character,omitempty"`
	Staff        *StaffEdge           `json:"staff,omitempty"`
	Studio       *StudioEdge          `json:"studio,omitempty"`
	ExternalLink *MediaExternalLink   `json:"externalLink,omitempty"`
}

type MediaSubmissionEdge struct {
	// The id of the direct submission
	ID                   *int               `json:"id,omitempty"`
	CharacterRole        *CharacterRole     `json:"characterRole,omitempty"`
	StaffRole            *string            `json:"staffRole,omitempty"`
	RoleNotes            *string            `json:"roleNotes,omitempty"`
	DubGroup             *string            `json:"dubGroup,omitempty"`
	CharacterName        *string            `json:"characterName,omitempty"`
	IsMain               *bool              `json:"isMain,omitempty"`
	Character            *Character         `json:"character,omitempty"`
	CharacterSubmission  *Character         `json:"characterSubmission,omitempty"`
	VoiceActor           *Staff             `json:"voiceActor,omitempty"`
	VoiceActorSubmission *Staff             `json:"voiceActorSubmission,omitempty"`
	Staff                *Staff             `json:"staff,omitempty"`
	StaffSubmission      *Staff             `json:"staffSubmission,omitempty"`
	Studio               *Studio            `json:"studio,omitempty"`
	ExternalLink         *MediaExternalLink `json:"externalLink,omitempty"`
	Media                *Media             `json:"media,omitempty"`
}

// A tag that describes a theme or element of the media
type MediaTag struct {
	// The id of the tag
	ID int `json:"id"`
	// The name of the tag
	Name string `json:"name"`
	// A general description of the tag
	Description *string `json:"description,omitempty"`
	// The categories of tags this tag belongs to
	Category *string `json:"category,omitempty"`
	// The relevance ranking of the tag out of the 100 for this media
	Rank *int `json:"rank,omitempty"`
	// If the tag could be a spoiler for any media
	IsGeneralSpoiler *bool `json:"isGeneralSpoiler,omitempty"`
	// If the tag is a spoiler for this media
	IsMediaSpoiler *bool `json:"isMediaSpoiler,omitempty"`
	// If the tag is only for adult 18+ media
	IsAdult *bool `json:"isAdult,omitempty"`
	// The user who submitted the tag
	UserID *int `json:"userId,omitempty"`
}

// The official titles of the media in various languages
type MediaTitle struct {
	// The romanization of the native language title
	Romaji *string `json:"romaji,omitempty"`
	// The official english title
	English *string `json:"english,omitempty"`
	// Official title in it's native language
	Native *string `json:"native,omitempty"`
	// The currently authenticated users preferred title language. Default romaji for non-authenticated
	UserPreferred *string `json:"userPreferred,omitempty"`
}

// The official titles of the media in various languages
type MediaTitleInput struct {
	// The romanization of the native language title
	Romaji *string `json:"romaji,omitempty"`
	// The official english title
	English *string `json:"english,omitempty"`
	// Official title in it's native language
	Native *string `json:"native,omitempty"`
}

// Media trailer or advertisement
type MediaTrailer struct {
	// The trailer video id
	ID *string `json:"id,omitempty"`
	// The site the video is hosted by (Currently either youtube or dailymotion)
	Site *string `json:"site,omitempty"`
	// The url for the thumbnail image of the video
	Thumbnail *string `json:"thumbnail,omitempty"`
}

// Daily media statistics
type MediaTrend struct {
	// The id of the tag
	MediaID int `json:"mediaId"`
	// The day the data was recorded (timestamp)
	Date int `json:"date"`
	// The amount of media activity on the day
	Trending int `json:"trending"`
	// A weighted average score of all the user's scores of the media
	AverageScore *int `json:"averageScore,omitempty"`
	// The number of users with the media on their list
	Popularity *int `json:"popularity,omitempty"`
	// The number of users with watching/reading the media
	InProgress *int `json:"inProgress,omitempty"`
	// If the media was being released at this time
	Releasing bool `json:"releasing"`
	// The episode number of the anime released on this day
	Episode *int `json:"episode,omitempty"`
	// The related media
	Media *Media `json:"media,omitempty"`
}

type MediaTrendConnection struct {
	Edges []*MediaTrendEdge `json:"edges,omitempty"`
	Nodes []*MediaTrend     `json:"nodes,omitempty"`
	// The pagination information
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

// Media trend connection edge
type MediaTrendEdge struct {
	Node *MediaTrend `json:"node,omitempty"`
}

// User message activity
type MessageActivity struct {
	// The id of the activity
	ID int `json:"id"`
	// The user id of the activity's recipient
	RecipientID *int `json:"recipientId,omitempty"`
	// The user id of the activity's sender
	MessengerID *int `json:"messengerId,omitempty"`
	// The type of the activity
	Type *ActivityType `json:"type,omitempty"`
	// The number of activity replies
	ReplyCount int `json:"replyCount"`
	// The message text (Markdown)
	Message *string `json:"message,omitempty"`
	// If the activity is locked and can receive replies
	IsLocked *bool `json:"isLocked,omitempty"`
	// If the currently authenticated user is subscribed to the activity
	IsSubscribed *bool `json:"isSubscribed,omitempty"`
	// The amount of likes the activity has
	LikeCount int `json:"likeCount"`
	// If the currently authenticated user liked the activity
	IsLiked *bool `json:"isLiked,omitempty"`
	// If the message is private and only viewable to the sender and recipients
	IsPrivate *bool `json:"isPrivate,omitempty"`
	// The url for the activity page on the AniList website
	SiteURL *string `json:"siteUrl,omitempty"`
	// The time the activity was created at
	CreatedAt int `json:"createdAt"`
	// The user who the activity message was sent to
	Recipient *User `json:"recipient,omitempty"`
	// The user who sent the activity message
	Messenger *User `json:"messenger,omitempty"`
	// The written replies to the activity
	Replies []*ActivityReply `json:"replies,omitempty"`
	// The users who liked the activity
	Likes []*User `json:"likes,omitempty"`
}

func (MessageActivity) IsActivityUnion() {}

func (MessageActivity) IsLikeableUnion() {}

type ModAction struct {
	// The id of the action
	ID         int            `json:"id"`
	User       *User          `json:"user,omitempty"`
	Mod        *User          `json:"mod,omitempty"`
	Type       *ModActionType `json:"type,omitempty"`
	ObjectID   *int           `json:"objectId,omitempty"`
	ObjectType *string        `json:"objectType,omitempty"`
	Data       *string        `json:"data,omitempty"`
	CreatedAt  int            `json:"createdAt"`
}

type Mutation struct {
}

// Notification option
type NotificationOption struct {
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// Whether this type of notification is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

// Notification option input
type NotificationOptionInput struct {
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// Whether this type of notification is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

// Page of data
type Page struct {
	// The pagination information
	PageInfo        *PageInfo           `json:"pageInfo,omitempty"`
	Users           []*User             `json:"users,omitempty"`
	Media           []*Media            `json:"media,omitempty"`
	Characters      []*Character        `json:"characters,omitempty"`
	Staff           []*Staff            `json:"staff,omitempty"`
	Studios         []*Studio           `json:"studios,omitempty"`
	MediaList       []*MediaList        `json:"mediaList,omitempty"`
	AiringSchedules []*AiringSchedule   `json:"airingSchedules,omitempty"`
	MediaTrends     []*MediaTrend       `json:"mediaTrends,omitempty"`
	Notifications   []NotificationUnion `json:"notifications,omitempty"`
	Followers       []*User             `json:"followers,omitempty"`
	Following       []*User             `json:"following,omitempty"`
	Activities      []ActivityUnion     `json:"activities,omitempty"`
	ActivityReplies []*ActivityReply    `json:"activityReplies,omitempty"`
	Threads         []*Thread           `json:"threads,omitempty"`
	ThreadComments  []*ThreadComment    `json:"threadComments,omitempty"`
	Reviews         []*Review           `json:"reviews,omitempty"`
	Recommendations []*Recommendation   `json:"recommendations,omitempty"`
	Likes           []*User             `json:"likes,omitempty"`
}

type PageInfo struct {
	// The total number of items. Note: This value is not guaranteed to be accurate, do not rely on this for logic
	Total *int `json:"total,omitempty"`
	// The count on a page
	PerPage *int `json:"perPage,omitempty"`
	// The current page
	CurrentPage *int `json:"currentPage,omitempty"`
	// The last page
	LastPage *int `json:"lastPage,omitempty"`
	// If there is another page
	HasNextPage *bool `json:"hasNextPage,omitempty"`
}

// Provides the parsed markdown as html
type ParsedMarkdown struct {
	// The parsed markdown as html
	HTML *string `json:"html,omitempty"`
}

type Query struct {
}

// Media recommendation
type Recommendation struct {
	// The id of the recommendation
	ID int `json:"id"`
	// Users rating of the recommendation
	Rating *int `json:"rating,omitempty"`
	// The rating of the recommendation by currently authenticated user
	UserRating *RecommendationRating `json:"userRating,omitempty"`
	// The media the recommendation is from
	Media *Media `json:"media,omitempty"`
	// The recommended media
	MediaRecommendation *Media `json:"mediaRecommendation,omitempty"`
	// The user that first created the recommendation
	User *User `json:"user,omitempty"`
}

type RecommendationConnection struct {
	Edges []*RecommendationEdge `json:"edges,omitempty"`
	Nodes []*Recommendation     `json:"nodes,omitempty"`
	// The pagination information
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

// Recommendation connection edge
type RecommendationEdge struct {
	Node *Recommendation `json:"node,omitempty"`
}

// Notification for when new media is added to the site
type RelatedMediaAdditionNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the new media
	MediaID int `json:"mediaId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The associated media of the airing schedule
	Media *Media `json:"media,omitempty"`
}

func (RelatedMediaAdditionNotification) IsNotificationUnion() {}

type Report struct {
	ID       int     `json:"id"`
	Reporter *User   `json:"reporter,omitempty"`
	Reported *User   `json:"reported,omitempty"`
	Reason   *string `json:"reason,omitempty"`
	// When the entry data was created
	CreatedAt *int  `json:"createdAt,omitempty"`
	Cleared   *bool `json:"cleared,omitempty"`
}

// A Review that features in an anime or manga
type Review struct {
	// The id of the review
	ID int `json:"id"`
	// The id of the review's creator
	UserID int `json:"userId"`
	// The id of the review's media
	MediaID int `json:"mediaId"`
	// For which type of media the review is for
	MediaType *MediaType `json:"mediaType,omitempty"`
	// A short summary of the review
	Summary *string `json:"summary,omitempty"`
	// The main review body text
	Body *string `json:"body,omitempty"`
	// The total user rating of the review
	Rating *int `json:"rating,omitempty"`
	// The amount of user ratings of the review
	RatingAmount *int `json:"ratingAmount,omitempty"`
	// The rating of the review by currently authenticated user
	UserRating *ReviewRating `json:"userRating,omitempty"`
	// The review score of the media
	Score *int `json:"score,omitempty"`
	// If the review is not yet publicly published and is only viewable by creator
	Private *bool `json:"private,omitempty"`
	// The url for the review page on the AniList website
	SiteURL *string `json:"siteUrl,omitempty"`
	// The time of the thread creation
	CreatedAt int `json:"createdAt"`
	// The time of the thread last update
	UpdatedAt int `json:"updatedAt"`
	// The creator of the review
	User *User `json:"user,omitempty"`
	// The media the review is of
	Media *Media `json:"media,omitempty"`
}

type ReviewConnection struct {
	Edges []*ReviewEdge `json:"edges,omitempty"`
	Nodes []*Review     `json:"nodes,omitempty"`
	// The pagination information
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

// Review connection edge
type ReviewEdge struct {
	Node *Review `json:"node,omitempty"`
}

// Feed of mod edit activity
type RevisionHistory struct {
	// The id of the media
	ID int `json:"id"`
	// The action taken on the objects
	Action *RevisionHistoryAction `json:"action,omitempty"`
	// A JSON object of the fields that changed
	Changes *string `json:"changes,omitempty"`
	// The user who made the edit to the object
	User *User `json:"user,omitempty"`
	// The media the mod feed entry references
	Media *Media `json:"media,omitempty"`
	// The character the mod feed entry references
	Character *Character `json:"character,omitempty"`
	// The staff member the mod feed entry references
	Staff *Staff `json:"staff,omitempty"`
	// The studio the mod feed entry references
	Studio *Studio `json:"studio,omitempty"`
	// The external link source the mod feed entry references
	ExternalLink *MediaExternalLink `json:"externalLink,omitempty"`
	// When the mod feed entry was created
	CreatedAt *int `json:"createdAt,omitempty"`
}

// A user's list score distribution.
type ScoreDistribution struct {
	Score *int `json:"score,omitempty"`
	// The amount of list entries with this score
	Amount *int `json:"amount,omitempty"`
}

type SiteStatistics struct {
	Users      *SiteTrendConnection `json:"users,omitempty"`
	Anime      *SiteTrendConnection `json:"anime,omitempty"`
	Manga      *SiteTrendConnection `json:"manga,omitempty"`
	Characters *SiteTrendConnection `json:"characters,omitempty"`
	Staff      *SiteTrendConnection `json:"staff,omitempty"`
	Studios    *SiteTrendConnection `json:"studios,omitempty"`
	Reviews    *SiteTrendConnection `json:"reviews,omitempty"`
}

// Daily site statistics
type SiteTrend struct {
	// The day the data was recorded (timestamp)
	Date  int `json:"date"`
	Count int `json:"count"`
	// The change from yesterday
	Change int `json:"change"`
}

type SiteTrendConnection struct {
	Edges []*SiteTrendEdge `json:"edges,omitempty"`
	Nodes []*SiteTrend     `json:"nodes,omitempty"`
	// The pagination information
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

// Site trend connection edge
type SiteTrendEdge struct {
	Node *SiteTrend `json:"node,omitempty"`
}

// Voice actors or production staff
type Staff struct {
	// The id of the staff member
	ID int `json:"id"`
	// The names of the staff member
	Name *StaffName `json:"name,omitempty"`
	// The primary language the staff member dub's in
	Language *StaffLanguage `json:"language,omitempty"`
	// The primary language of the staff member. Current values: Japanese, English, Korean, Italian, Spanish, Portuguese, French, German, Hebrew, Hungarian, Chinese, Arabic, Filipino, Catalan, Finnish, Turkish, Dutch, Swedish, Thai, Tagalog, Malaysian, Indonesian, Vietnamese, Nepali, Hindi, Urdu
	LanguageV2 *string `json:"languageV2,omitempty"`
	// The staff images
	Image *StaffImage `json:"image,omitempty"`
	// A general description of the staff member
	Description *string `json:"description,omitempty"`
	// The person's primary occupations
	PrimaryOccupations []*string `json:"primaryOccupations,omitempty"`
	// The staff's gender. Usually Male, Female, or Non-binary but can be any string.
	Gender      *string    `json:"gender,omitempty"`
	DateOfBirth *FuzzyDate `json:"dateOfBirth,omitempty"`
	DateOfDeath *FuzzyDate `json:"dateOfDeath,omitempty"`
	// The person's age in years
	Age *int `json:"age,omitempty"`
	// [startYear, endYear] (If the 2nd value is not present staff is still active)
	YearsActive []*int `json:"yearsActive,omitempty"`
	// The persons birthplace or hometown
	HomeTown *string `json:"homeTown,omitempty"`
	// The persons blood type
	BloodType *string `json:"bloodType,omitempty"`
	// If the staff member is marked as favourite by the currently authenticated user
	IsFavourite bool `json:"isFavourite"`
	// If the staff member is blocked from being added to favourites
	IsFavouriteBlocked bool `json:"isFavouriteBlocked"`
	// The url for the staff page on the AniList website
	SiteURL *string `json:"siteUrl,omitempty"`
	// Media where the staff member has a production role
	StaffMedia *MediaConnection `json:"staffMedia,omitempty"`
	// Characters voiced by the actor
	Characters *CharacterConnection `json:"characters,omitempty"`
	// Media the actor voiced characters in. (Same data as characters with media as node instead of characters)
	CharacterMedia *MediaConnection `json:"characterMedia,omitempty"`
	UpdatedAt      *int             `json:"updatedAt,omitempty"`
	// Staff member that the submission is referencing
	Staff *Staff `json:"staff,omitempty"`
	// Submitter for the submission
	Submitter *User `json:"submitter,omitempty"`
	// Status of the submission
	SubmissionStatus *int `json:"submissionStatus,omitempty"`
	// Inner details of submission status
	SubmissionNotes *string `json:"submissionNotes,omitempty"`
	// The amount of user's who have favourited the staff member
	Favourites *int `json:"favourites,omitempty"`
	// Notes for site moderators
	ModNotes *string `json:"modNotes,omitempty"`
}

type StaffConnection struct {
	Edges []*StaffEdge `json:"edges,omitempty"`
	Nodes []*Staff     `json:"nodes,omitempty"`
	// The pagination information
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

// Staff connection edge
type StaffEdge struct {
	Node *Staff `json:"node,omitempty"`
	// The id of the connection
	ID *int `json:"id,omitempty"`
	// The role of the staff member in the production of the media
	Role *string `json:"role,omitempty"`
	// The order the staff should be displayed from the users favourites
	FavouriteOrder *int `json:"favouriteOrder,omitempty"`
}

type StaffImage struct {
	// The person's image of media at its largest size
	Large *string `json:"large,omitempty"`
	// The person's image of media at medium size
	Medium *string `json:"medium,omitempty"`
}

// The names of the staff member
type StaffName struct {
	// The person's given name
	First *string `json:"first,omitempty"`
	// The person's middle name
	Middle *string `json:"middle,omitempty"`
	// The person's surname
	Last *string `json:"last,omitempty"`
	// The person's first and last name
	Full *string `json:"full,omitempty"`
	// The person's full name in their native language
	Native *string `json:"native,omitempty"`
	// Other names the staff member might be referred to as (pen names)
	Alternative []*string `json:"alternative,omitempty"`
	// The currently authenticated users preferred name language. Default romaji for non-authenticated
	UserPreferred *string `json:"userPreferred,omitempty"`
}

// The names of the staff member
type StaffNameInput struct {
	// The person's given name
	First *string `json:"first,omitempty"`
	// The person's middle name
	Middle *string `json:"middle,omitempty"`
	// The person's surname
	Last *string `json:"last,omitempty"`
	// The person's full name in their native language
	Native *string `json:"native,omitempty"`
	// Other names the character might be referred by
	Alternative []*string `json:"alternative,omitempty"`
}

// Voice actor role for a character
type StaffRoleType struct {
	// The voice actors of the character
	VoiceActor *Staff `json:"voiceActor,omitempty"`
	// Notes regarding the VA's role for the character
	RoleNotes *string `json:"roleNotes,omitempty"`
	// Used for grouping roles where multiple dubs exist for the same language. Either dubbing company name or language variant.
	DubGroup *string `json:"dubGroup,omitempty"`
}

// User's staff statistics
type StaffStats struct {
	Staff     *Staff `json:"staff,omitempty"`
	Amount    *int   `json:"amount,omitempty"`
	MeanScore *int   `json:"meanScore,omitempty"`
	// The amount of time in minutes the staff member has been watched by the user
	TimeWatched *int `json:"timeWatched,omitempty"`
}

// A submission for a staff that features in an anime or manga
type StaffSubmission struct {
	// The id of the submission
	ID int `json:"id"`
	// Staff that the submission is referencing
	Staff *Staff `json:"staff,omitempty"`
	// The staff submission changes
	Submission *Staff `json:"submission,omitempty"`
	// Submitter for the submission
	Submitter *User `json:"submitter,omitempty"`
	// Data Mod assigned to handle the submission
	Assignee *User `json:"assignee,omitempty"`
	// Status of the submission
	Status *SubmissionStatus `json:"status,omitempty"`
	// Inner details of submission status
	Notes  *string `json:"notes,omitempty"`
	Source *string `json:"source,omitempty"`
	// Whether the submission is locked
	Locked    *bool `json:"locked,omitempty"`
	CreatedAt *int  `json:"createdAt,omitempty"`
}

// The distribution of the watching/reading status of media or a user's list
type StatusDistribution struct {
	// The day the activity took place (Unix timestamp)
	Status *MediaListStatus `json:"status,omitempty"`
	// The amount of entries with this status
	Amount *int `json:"amount,omitempty"`
}

// Animation or production company
type Studio struct {
	// The id of the studio
	ID int `json:"id"`
	// The name of the studio
	Name string `json:"name"`
	// If the studio is an animation studio or a different kind of company
	IsAnimationStudio bool `json:"isAnimationStudio"`
	// The media the studio has worked on
	Media *MediaConnection `json:"media,omitempty"`
	// The url for the studio page on the AniList website
	SiteURL *string `json:"siteUrl,omitempty"`
	// If the studio is marked as favourite by the currently authenticated user
	IsFavourite bool `json:"isFavourite"`
	// The amount of user's who have favourited the studio
	Favourites *int `json:"favourites,omitempty"`
}

type StudioConnection struct {
	Edges []*StudioEdge `json:"edges,omitempty"`
	Nodes []*Studio     `json:"nodes,omitempty"`
	// The pagination information
	PageInfo *PageInfo `json:"pageInfo,omitempty"`
}

// Studio connection edge
type StudioEdge struct {
	Node *Studio `json:"node,omitempty"`
	// The id of the connection
	ID *int `json:"id,omitempty"`
	// If the studio is the main animation studio of the anime
	IsMain bool `json:"isMain"`
	// The order the character should be displayed from the users favourites
	FavouriteOrder *int `json:"favouriteOrder,omitempty"`
}

// User's studio statistics
type StudioStats struct {
	Studio    *Studio `json:"studio,omitempty"`
	Amount    *int    `json:"amount,omitempty"`
	MeanScore *int    `json:"meanScore,omitempty"`
	// The amount of time in minutes the studio's works have been watched by the user
	TimeWatched *int `json:"timeWatched,omitempty"`
}

// User's tag statistics
type TagStats struct {
	Tag       *MediaTag `json:"tag,omitempty"`
	Amount    *int      `json:"amount,omitempty"`
	MeanScore *int      `json:"meanScore,omitempty"`
	// The amount of time in minutes the tag has been watched by the user
	TimeWatched *int `json:"timeWatched,omitempty"`
}

// User text activity
type TextActivity struct {
	// The id of the activity
	ID int `json:"id"`
	// The user id of the activity's creator
	UserID *int `json:"userId,omitempty"`
	// The type of activity
	Type *ActivityType `json:"type,omitempty"`
	// The number of activity replies
	ReplyCount int `json:"replyCount"`
	// The status text (Markdown)
	Text *string `json:"text,omitempty"`
	// The url for the activity page on the AniList website
	SiteURL *string `json:"siteUrl,omitempty"`
	// If the activity is locked and can receive replies
	IsLocked *bool `json:"isLocked,omitempty"`
	// If the currently authenticated user is subscribed to the activity
	IsSubscribed *bool `json:"isSubscribed,omitempty"`
	// The amount of likes the activity has
	LikeCount int `json:"likeCount"`
	// If the currently authenticated user liked the activity
	IsLiked *bool `json:"isLiked,omitempty"`
	// If the activity is pinned to the top of the users activity feed
	IsPinned *bool `json:"isPinned,omitempty"`
	// The time the activity was created at
	CreatedAt int `json:"createdAt"`
	// The user who created the activity
	User *User `json:"user,omitempty"`
	// The written replies to the activity
	Replies []*ActivityReply `json:"replies,omitempty"`
	// The users who liked the activity
	Likes []*User `json:"likes,omitempty"`
}

func (TextActivity) IsActivityUnion() {}

func (TextActivity) IsLikeableUnion() {}

// Forum Thread
type Thread struct {
	// The id of the thread
	ID int `json:"id"`
	// The title of the thread
	Title *string `json:"title,omitempty"`
	// The text body of the thread (Markdown)
	Body *string `json:"body,omitempty"`
	// The id of the thread owner user
	UserID int `json:"userId"`
	// The id of the user who most recently commented on the thread
	ReplyUserID *int `json:"replyUserId,omitempty"`
	// The id of the most recent comment on the thread
	ReplyCommentID *int `json:"replyCommentId,omitempty"`
	// The number of comments on the thread
	ReplyCount *int `json:"replyCount,omitempty"`
	// The number of times users have viewed the thread
	ViewCount *int `json:"viewCount,omitempty"`
	// If the thread is locked and can receive comments
	IsLocked *bool `json:"isLocked,omitempty"`
	// If the thread is stickied and should be displayed at the top of the page
	IsSticky *bool `json:"isSticky,omitempty"`
	// If the currently authenticated user is subscribed to the thread
	IsSubscribed *bool `json:"isSubscribed,omitempty"`
	// The amount of likes the thread has
	LikeCount int `json:"likeCount"`
	// If the currently authenticated user liked the thread
	IsLiked *bool `json:"isLiked,omitempty"`
	// The time of the last reply
	RepliedAt *int `json:"repliedAt,omitempty"`
	// The time of the thread creation
	CreatedAt int `json:"createdAt"`
	// The time of the thread last update
	UpdatedAt int `json:"updatedAt"`
	// The owner of the thread
	User *User `json:"user,omitempty"`
	// The user to last reply to the thread
	ReplyUser *User `json:"replyUser,omitempty"`
	// The users who liked the thread
	Likes []*User `json:"likes,omitempty"`
	// The url for the thread page on the AniList website
	SiteURL *string `json:"siteUrl,omitempty"`
	// The categories of the thread
	Categories []*ThreadCategory `json:"categories,omitempty"`
	// The media categories of the thread
	MediaCategories []*Media `json:"mediaCategories,omitempty"`
}

func (Thread) IsLikeableUnion() {}

// A forum thread category
type ThreadCategory struct {
	// The id of the category
	ID int `json:"id"`
	// The name of the category
	Name string `json:"name"`
}

// Forum Thread Comment
type ThreadComment struct {
	// The id of the comment
	ID int `json:"id"`
	// The user id of the comment's owner
	UserID *int `json:"userId,omitempty"`
	// The id of thread the comment belongs to
	ThreadID *int `json:"threadId,omitempty"`
	// The text content of the comment (Markdown)
	Comment *string `json:"comment,omitempty"`
	// The amount of likes the comment has
	LikeCount int `json:"likeCount"`
	// If the currently authenticated user liked the comment
	IsLiked *bool `json:"isLiked,omitempty"`
	// The url for the comment page on the AniList website
	SiteURL *string `json:"siteUrl,omitempty"`
	// The time of the comments creation
	CreatedAt int `json:"createdAt"`
	// The time of the comments last update
	UpdatedAt int `json:"updatedAt"`
	// The thread the comment belongs to
	Thread *Thread `json:"thread,omitempty"`
	// The user who created the comment
	User *User `json:"user,omitempty"`
	// The users who liked the comment
	Likes []*User `json:"likes,omitempty"`
	// The comment's child reply comments
	ChildComments *string `json:"childComments,omitempty"`
	// If the comment tree is locked and may not receive replies or edits
	IsLocked *bool `json:"isLocked,omitempty"`
}

func (ThreadComment) IsLikeableUnion() {}

// Notification for when a thread comment is liked
type ThreadCommentLikeNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The id of the user who liked to the activity
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the activity which was liked
	CommentID int `json:"commentId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The thread that the relevant comment belongs to
	Thread *Thread `json:"thread,omitempty"`
	// The thread comment that was liked
	Comment *ThreadComment `json:"comment,omitempty"`
	// The user who liked the activity
	User *User `json:"user,omitempty"`
}

func (ThreadCommentLikeNotification) IsNotificationUnion() {}

// Notification for when authenticated user is @ mentioned in a forum thread comment
type ThreadCommentMentionNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The id of the user who mentioned the authenticated user
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the comment where mentioned
	CommentID int `json:"commentId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The thread that the relevant comment belongs to
	Thread *Thread `json:"thread,omitempty"`
	// The thread comment that included the @ mention
	Comment *ThreadComment `json:"comment,omitempty"`
	// The user who mentioned the authenticated user
	User *User `json:"user,omitempty"`
}

func (ThreadCommentMentionNotification) IsNotificationUnion() {}

// Notification for when a user replies to your forum thread comment
type ThreadCommentReplyNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The id of the user who create the comment reply
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the reply comment
	CommentID int `json:"commentId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The thread that the relevant comment belongs to
	Thread *Thread `json:"thread,omitempty"`
	// The reply thread comment
	Comment *ThreadComment `json:"comment,omitempty"`
	// The user who replied to the activity
	User *User `json:"user,omitempty"`
}

func (ThreadCommentReplyNotification) IsNotificationUnion() {}

// Notification for when a user replies to a subscribed forum thread
type ThreadCommentSubscribedNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The id of the user who commented on the thread
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the new comment in the subscribed thread
	CommentID int `json:"commentId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The thread that the relevant comment belongs to
	Thread *Thread `json:"thread,omitempty"`
	// The reply thread comment
	Comment *ThreadComment `json:"comment,omitempty"`
	// The user who replied to the subscribed thread
	User *User `json:"user,omitempty"`
}

func (ThreadCommentSubscribedNotification) IsNotificationUnion() {}

// Notification for when a thread is liked
type ThreadLikeNotification struct {
	// The id of the Notification
	ID int `json:"id"`
	// The id of the user who liked to the activity
	UserID int `json:"userId"`
	// The type of notification
	Type *NotificationType `json:"type,omitempty"`
	// The id of the thread which was liked
	ThreadID int `json:"threadId"`
	// The notification context text
	Context *string `json:"context,omitempty"`
	// The time the notification was created at
	CreatedAt *int `json:"createdAt,omitempty"`
	// The thread that the relevant comment belongs to
	Thread *Thread `json:"thread,omitempty"`
	// The liked thread comment
	Comment *ThreadComment `json:"comment,omitempty"`
	// The user who liked the activity
	User *User `json:"user,omitempty"`
}

func (ThreadLikeNotification) IsNotificationUnion() {}

// A user
type User struct {
	// The id of the user
	ID int `json:"id"`
	// The name of the user
	Name string `json:"name"`
	// The bio written by user (Markdown)
	About *string `json:"about,omitempty"`
	// The user's avatar images
	Avatar *UserAvatar `json:"avatar,omitempty"`
	// The user's banner images
	BannerImage *string `json:"bannerImage,omitempty"`
	// If the authenticated user if following this user
	IsFollowing *bool `json:"isFollowing,omitempty"`
	// If this user if following the authenticated user
	IsFollower *bool `json:"isFollower,omitempty"`
	// If the user is blocked by the authenticated user
	IsBlocked *bool   `json:"isBlocked,omitempty"`
	Bans      *string `json:"bans,omitempty"`
	// The user's general options
	Options *UserOptions `json:"options,omitempty"`
	// The user's media list options
	MediaListOptions *MediaListOptions `json:"mediaListOptions,omitempty"`
	// The users favourites
	Favourites *Favourites `json:"favourites,omitempty"`
	// The users anime & manga list statistics
	Statistics *UserStatisticTypes `json:"statistics,omitempty"`
	// The number of unread notifications the user has
	UnreadNotificationCount *int `json:"unreadNotificationCount,omitempty"`
	// The url for the user page on the AniList website
	SiteURL *string `json:"siteUrl,omitempty"`
	// The donation tier of the user
	DonatorTier *int `json:"donatorTier,omitempty"`
	// Custom donation badge text
	DonatorBadge *string `json:"donatorBadge,omitempty"`
	// The user's moderator roles if they are a site moderator
	ModeratorRoles []*ModRole `json:"moderatorRoles,omitempty"`
	// When the user's account was created. (Does not exist for accounts created before 2020)
	CreatedAt *int `json:"createdAt,omitempty"`
	// When the user's data was last updated
	UpdatedAt *int `json:"updatedAt,omitempty"`
	// The user's statistics
	Stats *UserStats `json:"stats,omitempty"`
	// If the user is a moderator or data moderator
	ModeratorStatus *string `json:"moderatorStatus,omitempty"`
	// The user's previously used names.
	PreviousNames []*UserPreviousName `json:"previousNames,omitempty"`
}

// A user's activity history stats.
type UserActivityHistory struct {
	// The day the activity took place (Unix timestamp)
	Date *int `json:"date,omitempty"`
	// The amount of activity on the day
	Amount *int `json:"amount,omitempty"`
	// The level of activity represented on a 1-10 scale
	Level *int `json:"level,omitempty"`
}

// A user's avatars
type UserAvatar struct {
	// The avatar of user at its largest size
	Large *string `json:"large,omitempty"`
	// The avatar of user at medium size
	Medium *string `json:"medium,omitempty"`
}

type UserCountryStatistic struct {
	Count          int     `json:"count"`
	MeanScore      float64 `json:"meanScore"`
	MinutesWatched int     `json:"minutesWatched"`
	ChaptersRead   int     `json:"chaptersRead"`
	MediaIds       []*int  `json:"mediaIds"`
	Country        *string `json:"country,omitempty"`
}

type UserFormatStatistic struct {
	Count          int          `json:"count"`
	MeanScore      float64      `json:"meanScore"`
	MinutesWatched int          `json:"minutesWatched"`
	ChaptersRead   int          `json:"chaptersRead"`
	MediaIds       []*int       `json:"mediaIds"`
	Format         *MediaFormat `json:"format,omitempty"`
}

type UserGenreStatistic struct {
	Count          int     `json:"count"`
	MeanScore      float64 `json:"meanScore"`
	MinutesWatched int     `json:"minutesWatched"`
	ChaptersRead   int     `json:"chaptersRead"`
	MediaIds       []*int  `json:"mediaIds"`
	Genre          *string `json:"genre,omitempty"`
}

type UserLengthStatistic struct {
	Count          int     `json:"count"`
	MeanScore      float64 `json:"meanScore"`
	MinutesWatched int     `json:"minutesWatched"`
	ChaptersRead   int     `json:"chaptersRead"`
	MediaIds       []*int  `json:"mediaIds"`
	Length         *string `json:"length,omitempty"`
}

// User data for moderators
type UserModData struct {
	Alts    []*User `json:"alts,omitempty"`
	Bans    *string `json:"bans,omitempty"`
	IP      *string `json:"ip,omitempty"`
	Counts  *string `json:"counts,omitempty"`
	Privacy *int    `json:"privacy,omitempty"`
	Email   *string `json:"email,omitempty"`
}

// A user's general options
type UserOptions struct {
	// The language the user wants to see media titles in
	TitleLanguage *UserTitleLanguage `json:"titleLanguage,omitempty"`
	// Whether the user has enabled viewing of 18+ content
	DisplayAdultContent *bool `json:"displayAdultContent,omitempty"`
	// Whether the user receives notifications when a show they are watching aires
	AiringNotifications *bool `json:"airingNotifications,omitempty"`
	// Profile highlight color (blue, purple, pink, orange, red, green, gray)
	ProfileColor *string `json:"profileColor,omitempty"`
	// Notification options
	NotificationOptions []*NotificationOption `json:"notificationOptions,omitempty"`
	// The user's timezone offset (Auth user only)
	Timezone *string `json:"timezone,omitempty"`
	// Minutes between activity for them to be merged together. 0 is Never, Above 2 weeks (20160 mins) is Always.
	ActivityMergeTime *int `json:"activityMergeTime,omitempty"`
	// The language the user wants to see staff and character names in
	StaffNameLanguage *UserStaffNameLanguage `json:"staffNameLanguage,omitempty"`
	// Whether the user only allow messages from users they follow
	RestrictMessagesToFollowing *bool `json:"restrictMessagesToFollowing,omitempty"`
	// The list activity types the user has disabled from being created from list updates
	DisabledListActivity []*ListActivityOption `json:"disabledListActivity,omitempty"`
}

// A user's previous name
type UserPreviousName struct {
	// A previous name of the user.
	Name *string `json:"name,omitempty"`
	// When the user first changed from this name.
	CreatedAt *int `json:"createdAt,omitempty"`
	// When the user most recently changed from this name.
	UpdatedAt *int `json:"updatedAt,omitempty"`
}

type UserReleaseYearStatistic struct {
	Count          int     `json:"count"`
	MeanScore      float64 `json:"meanScore"`
	MinutesWatched int     `json:"minutesWatched"`
	ChaptersRead   int     `json:"chaptersRead"`
	MediaIds       []*int  `json:"mediaIds"`
	ReleaseYear    *int    `json:"releaseYear,omitempty"`
}

type UserScoreStatistic struct {
	Count          int     `json:"count"`
	MeanScore      float64 `json:"meanScore"`
	MinutesWatched int     `json:"minutesWatched"`
	ChaptersRead   int     `json:"chaptersRead"`
	MediaIds       []*int  `json:"mediaIds"`
	Score          *int    `json:"score,omitempty"`
}

type UserStaffStatistic struct {
	Count          int     `json:"count"`
	MeanScore      float64 `json:"meanScore"`
	MinutesWatched int     `json:"minutesWatched"`
	ChaptersRead   int     `json:"chaptersRead"`
	MediaIds       []*int  `json:"mediaIds"`
	Staff          *Staff  `json:"staff,omitempty"`
}

type UserStartYearStatistic struct {
	Count          int     `json:"count"`
	MeanScore      float64 `json:"meanScore"`
	MinutesWatched int     `json:"minutesWatched"`
	ChaptersRead   int     `json:"chaptersRead"`
	MediaIds       []*int  `json:"mediaIds"`
	StartYear      *int    `json:"startYear,omitempty"`
}

type UserStatisticTypes struct {
	Anime *UserStatistics `json:"anime,omitempty"`
	Manga *UserStatistics `json:"manga,omitempty"`
}

type UserStatistics struct {
	Count             int                         `json:"count"`
	MeanScore         float64                     `json:"meanScore"`
	StandardDeviation float64                     `json:"standardDeviation"`
	MinutesWatched    int                         `json:"minutesWatched"`
	EpisodesWatched   int                         `json:"episodesWatched"`
	ChaptersRead      int                         `json:"chaptersRead"`
	VolumesRead       int                         `json:"volumesRead"`
	Formats           []*UserFormatStatistic      `json:"formats,omitempty"`
	Statuses          []*UserStatusStatistic      `json:"statuses,omitempty"`
	Scores            []*UserScoreStatistic       `json:"scores,omitempty"`
	Lengths           []*UserLengthStatistic      `json:"lengths,omitempty"`
	ReleaseYears      []*UserReleaseYearStatistic `json:"releaseYears,omitempty"`
	StartYears        []*UserStartYearStatistic   `json:"startYears,omitempty"`
	Genres            []*UserGenreStatistic       `json:"genres,omitempty"`
	Tags              []*UserTagStatistic         `json:"tags,omitempty"`
	Countries         []*UserCountryStatistic     `json:"countries,omitempty"`
	VoiceActors       []*UserVoiceActorStatistic  `json:"voiceActors,omitempty"`
	Staff             []*UserStaffStatistic       `json:"staff,omitempty"`
	Studios           []*UserStudioStatistic      `json:"studios,omitempty"`
}

// A user's statistics
type UserStats struct {
	// The amount of anime the user has watched in minutes
	WatchedTime *int `json:"watchedTime,omitempty"`
	// The amount of manga chapters the user has read
	ChaptersRead            *int                   `json:"chaptersRead,omitempty"`
	ActivityHistory         []*UserActivityHistory `json:"activityHistory,omitempty"`
	AnimeStatusDistribution []*StatusDistribution  `json:"animeStatusDistribution,omitempty"`
	MangaStatusDistribution []*StatusDistribution  `json:"mangaStatusDistribution,omitempty"`
	AnimeScoreDistribution  []*ScoreDistribution   `json:"animeScoreDistribution,omitempty"`
	MangaScoreDistribution  []*ScoreDistribution   `json:"mangaScoreDistribution,omitempty"`
	AnimeListScores         *ListScoreStats        `json:"animeListScores,omitempty"`
	MangaListScores         *ListScoreStats        `json:"mangaListScores,omitempty"`
	FavouredGenresOverview  []*GenreStats          `json:"favouredGenresOverview,omitempty"`
	FavouredGenres          []*GenreStats          `json:"favouredGenres,omitempty"`
	FavouredTags            []*TagStats            `json:"favouredTags,omitempty"`
	FavouredActors          []*StaffStats          `json:"favouredActors,omitempty"`
	FavouredStaff           []*StaffStats          `json:"favouredStaff,omitempty"`
	FavouredStudios         []*StudioStats         `json:"favouredStudios,omitempty"`
	FavouredYears           []*YearStats           `json:"favouredYears,omitempty"`
	FavouredFormats         []*FormatStats         `json:"favouredFormats,omitempty"`
}

type UserStatusStatistic struct {
	Count          int              `json:"count"`
	MeanScore      float64          `json:"meanScore"`
	MinutesWatched int              `json:"minutesWatched"`
	ChaptersRead   int              `json:"chaptersRead"`
	MediaIds       []*int           `json:"mediaIds"`
	Status         *MediaListStatus `json:"status,omitempty"`
}

type UserStudioStatistic struct {
	Count          int     `json:"count"`
	MeanScore      float64 `json:"meanScore"`
	MinutesWatched int     `json:"minutesWatched"`
	ChaptersRead   int     `json:"chaptersRead"`
	MediaIds       []*int  `json:"mediaIds"`
	Studio         *Studio `json:"studio,omitempty"`
}

type UserTagStatistic struct {
	Count          int       `json:"count"`
	MeanScore      float64   `json:"meanScore"`
	MinutesWatched int       `json:"minutesWatched"`
	ChaptersRead   int       `json:"chaptersRead"`
	MediaIds       []*int    `json:"mediaIds"`
	Tag            *MediaTag `json:"tag,omitempty"`
}

type UserVoiceActorStatistic struct {
	Count          int     `json:"count"`
	MeanScore      float64 `json:"meanScore"`
	MinutesWatched int     `json:"minutesWatched"`
	ChaptersRead   int     `json:"chaptersRead"`
	MediaIds       []*int  `json:"mediaIds"`
	VoiceActor     *Staff  `json:"voiceActor,omitempty"`
	CharacterIds   []*int  `json:"characterIds"`
}

// User's year statistics
type YearStats struct {
	Year      *int `json:"year,omitempty"`
	Amount    *int `json:"amount,omitempty"`
	MeanScore *int `json:"meanScore,omitempty"`
}

// Activity sort enums
type ActivitySort string

const (
	ActivitySortID     ActivitySort = "ID"
	ActivitySortIDDesc ActivitySort = "ID_DESC"
	ActivitySortPinned ActivitySort = "PINNED"
)

var AllActivitySort = []ActivitySort{
	ActivitySortID,
	ActivitySortIDDesc,
	ActivitySortPinned,
}

func (e ActivitySort) IsValid() bool {
	switch e {
	case ActivitySortID, ActivitySortIDDesc, ActivitySortPinned:
		return true
	}
	return false
}

func (e ActivitySort) String() string {
	return string(e)
}

func (e *ActivitySort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActivitySort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActivitySort", str)
	}
	return nil
}

func (e ActivitySort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ActivitySort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ActivitySort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Activity type enum.
type ActivityType string

const (
	// A text activity
	ActivityTypeText ActivityType = "TEXT"
	// A anime list update activity
	ActivityTypeAnimeList ActivityType = "ANIME_LIST"
	// A manga list update activity
	ActivityTypeMangaList ActivityType = "MANGA_LIST"
	// A text message activity sent to another user
	ActivityTypeMessage ActivityType = "MESSAGE"
	// Anime & Manga list update, only used in query arguments
	ActivityTypeMediaList ActivityType = "MEDIA_LIST"
)

var AllActivityType = []ActivityType{
	ActivityTypeText,
	ActivityTypeAnimeList,
	ActivityTypeMangaList,
	ActivityTypeMessage,
	ActivityTypeMediaList,
}

func (e ActivityType) IsValid() bool {
	switch e {
	case ActivityTypeText, ActivityTypeAnimeList, ActivityTypeMangaList, ActivityTypeMessage, ActivityTypeMediaList:
		return true
	}
	return false
}

func (e ActivityType) String() string {
	return string(e)
}

func (e *ActivityType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActivityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActivityType", str)
	}
	return nil
}

func (e ActivityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ActivityType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ActivityType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Airing schedule sort enums
type AiringSort string

const (
	AiringSortID          AiringSort = "ID"
	AiringSortIDDesc      AiringSort = "ID_DESC"
	AiringSortMediaID     AiringSort = "MEDIA_ID"
	AiringSortMediaIDDesc AiringSort = "MEDIA_ID_DESC"
	AiringSortTime        AiringSort = "TIME"
	AiringSortTimeDesc    AiringSort = "TIME_DESC"
	AiringSortEpisode     AiringSort = "EPISODE"
	AiringSortEpisodeDesc AiringSort = "EPISODE_DESC"
)

var AllAiringSort = []AiringSort{
	AiringSortID,
	AiringSortIDDesc,
	AiringSortMediaID,
	AiringSortMediaIDDesc,
	AiringSortTime,
	AiringSortTimeDesc,
	AiringSortEpisode,
	AiringSortEpisodeDesc,
}

func (e AiringSort) IsValid() bool {
	switch e {
	case AiringSortID, AiringSortIDDesc, AiringSortMediaID, AiringSortMediaIDDesc, AiringSortTime, AiringSortTimeDesc, AiringSortEpisode, AiringSortEpisodeDesc:
		return true
	}
	return false
}

func (e AiringSort) String() string {
	return string(e)
}

func (e *AiringSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AiringSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AiringSort", str)
	}
	return nil
}

func (e AiringSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AiringSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AiringSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The role the character plays in the media
type CharacterRole string

const (
	// A primary character role in the media
	CharacterRoleMain CharacterRole = "MAIN"
	// A supporting character role in the media
	CharacterRoleSupporting CharacterRole = "SUPPORTING"
	// A background character in the media
	CharacterRoleBackground CharacterRole = "BACKGROUND"
)

var AllCharacterRole = []CharacterRole{
	CharacterRoleMain,
	CharacterRoleSupporting,
	CharacterRoleBackground,
}

func (e CharacterRole) IsValid() bool {
	switch e {
	case CharacterRoleMain, CharacterRoleSupporting, CharacterRoleBackground:
		return true
	}
	return false
}

func (e CharacterRole) String() string {
	return string(e)
}

func (e *CharacterRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CharacterRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CharacterRole", str)
	}
	return nil
}

func (e CharacterRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CharacterRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CharacterRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Character sort enums
type CharacterSort string

const (
	CharacterSortID             CharacterSort = "ID"
	CharacterSortIDDesc         CharacterSort = "ID_DESC"
	CharacterSortRole           CharacterSort = "ROLE"
	CharacterSortRoleDesc       CharacterSort = "ROLE_DESC"
	CharacterSortSearchMatch    CharacterSort = "SEARCH_MATCH"
	CharacterSortFavourites     CharacterSort = "FAVOURITES"
	CharacterSortFavouritesDesc CharacterSort = "FAVOURITES_DESC"
	// Order manually decided by moderators
	CharacterSortRelevance CharacterSort = "RELEVANCE"
)

var AllCharacterSort = []CharacterSort{
	CharacterSortID,
	CharacterSortIDDesc,
	CharacterSortRole,
	CharacterSortRoleDesc,
	CharacterSortSearchMatch,
	CharacterSortFavourites,
	CharacterSortFavouritesDesc,
	CharacterSortRelevance,
}

func (e CharacterSort) IsValid() bool {
	switch e {
	case CharacterSortID, CharacterSortIDDesc, CharacterSortRole, CharacterSortRoleDesc, CharacterSortSearchMatch, CharacterSortFavourites, CharacterSortFavouritesDesc, CharacterSortRelevance:
		return true
	}
	return false
}

func (e CharacterSort) String() string {
	return string(e)
}

func (e *CharacterSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CharacterSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CharacterSort", str)
	}
	return nil
}

func (e CharacterSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CharacterSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CharacterSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ExternalLinkMediaType string

const (
	ExternalLinkMediaTypeAnime ExternalLinkMediaType = "ANIME"
	ExternalLinkMediaTypeManga ExternalLinkMediaType = "MANGA"
	ExternalLinkMediaTypeStaff ExternalLinkMediaType = "STAFF"
)

var AllExternalLinkMediaType = []ExternalLinkMediaType{
	ExternalLinkMediaTypeAnime,
	ExternalLinkMediaTypeManga,
	ExternalLinkMediaTypeStaff,
}

func (e ExternalLinkMediaType) IsValid() bool {
	switch e {
	case ExternalLinkMediaTypeAnime, ExternalLinkMediaTypeManga, ExternalLinkMediaTypeStaff:
		return true
	}
	return false
}

func (e ExternalLinkMediaType) String() string {
	return string(e)
}

func (e *ExternalLinkMediaType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExternalLinkMediaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExternalLinkMediaType", str)
	}
	return nil
}

func (e ExternalLinkMediaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ExternalLinkMediaType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ExternalLinkMediaType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ExternalLinkType string

const (
	ExternalLinkTypeInfo      ExternalLinkType = "INFO"
	ExternalLinkTypeStreaming ExternalLinkType = "STREAMING"
	ExternalLinkTypeSocial    ExternalLinkType = "SOCIAL"
)

var AllExternalLinkType = []ExternalLinkType{
	ExternalLinkTypeInfo,
	ExternalLinkTypeStreaming,
	ExternalLinkTypeSocial,
}

func (e ExternalLinkType) IsValid() bool {
	switch e {
	case ExternalLinkTypeInfo, ExternalLinkTypeStreaming, ExternalLinkTypeSocial:
		return true
	}
	return false
}

func (e ExternalLinkType) String() string {
	return string(e)
}

func (e *ExternalLinkType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExternalLinkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExternalLinkType", str)
	}
	return nil
}

func (e ExternalLinkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ExternalLinkType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ExternalLinkType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Types that can be liked
type LikeableType string

const (
	LikeableTypeThread        LikeableType = "THREAD"
	LikeableTypeThreadComment LikeableType = "THREAD_COMMENT"
	LikeableTypeActivity      LikeableType = "ACTIVITY"
	LikeableTypeActivityReply LikeableType = "ACTIVITY_REPLY"
)

var AllLikeableType = []LikeableType{
	LikeableTypeThread,
	LikeableTypeThreadComment,
	LikeableTypeActivity,
	LikeableTypeActivityReply,
}

func (e LikeableType) IsValid() bool {
	switch e {
	case LikeableTypeThread, LikeableTypeThreadComment, LikeableTypeActivity, LikeableTypeActivityReply:
		return true
	}
	return false
}

func (e LikeableType) String() string {
	return string(e)
}

func (e *LikeableType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LikeableType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LikeableType", str)
	}
	return nil
}

func (e LikeableType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LikeableType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LikeableType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The format the media was released in
type MediaFormat string

const (
	// Anime broadcast on television
	MediaFormatTv MediaFormat = "TV"
	// Anime which are under 15 minutes in length and broadcast on television
	MediaFormatTvShort MediaFormat = "TV_SHORT"
	// Anime movies with a theatrical release
	MediaFormatMovie MediaFormat = "MOVIE"
	// Special episodes that have been included in DVD/Blu-ray releases, picture dramas, pilots, etc
	MediaFormatSpecial MediaFormat = "SPECIAL"
	// (Original Video Animation) Anime that have been released directly on DVD/Blu-ray without originally going through a theatrical release or television broadcast
	MediaFormatOva MediaFormat = "OVA"
	// (Original Net Animation) Anime that have been originally released online or are only available through streaming services.
	MediaFormatOna MediaFormat = "ONA"
	// Short anime released as a music video
	MediaFormatMusic MediaFormat = "MUSIC"
	// Professionally published manga with more than one chapter
	MediaFormatManga MediaFormat = "MANGA"
	// Written books released as a series of light novels
	MediaFormatNovel MediaFormat = "NOVEL"
	// Manga with just one chapter
	MediaFormatOneShot MediaFormat = "ONE_SHOT"
)

var AllMediaFormat = []MediaFormat{
	MediaFormatTv,
	MediaFormatTvShort,
	MediaFormatMovie,
	MediaFormatSpecial,
	MediaFormatOva,
	MediaFormatOna,
	MediaFormatMusic,
	MediaFormatManga,
	MediaFormatNovel,
	MediaFormatOneShot,
}

func (e MediaFormat) IsValid() bool {
	switch e {
	case MediaFormatTv, MediaFormatTvShort, MediaFormatMovie, MediaFormatSpecial, MediaFormatOva, MediaFormatOna, MediaFormatMusic, MediaFormatManga, MediaFormatNovel, MediaFormatOneShot:
		return true
	}
	return false
}

func (e MediaFormat) String() string {
	return string(e)
}

func (e *MediaFormat) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaFormat", str)
	}
	return nil
}

func (e MediaFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaFormat) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaFormat) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Media list sort enums
type MediaListSort string

const (
	MediaListSortMediaID               MediaListSort = "MEDIA_ID"
	MediaListSortMediaIDDesc           MediaListSort = "MEDIA_ID_DESC"
	MediaListSortScore                 MediaListSort = "SCORE"
	MediaListSortScoreDesc             MediaListSort = "SCORE_DESC"
	MediaListSortStatus                MediaListSort = "STATUS"
	MediaListSortStatusDesc            MediaListSort = "STATUS_DESC"
	MediaListSortProgress              MediaListSort = "PROGRESS"
	MediaListSortProgressDesc          MediaListSort = "PROGRESS_DESC"
	MediaListSortProgressVolumes       MediaListSort = "PROGRESS_VOLUMES"
	MediaListSortProgressVolumesDesc   MediaListSort = "PROGRESS_VOLUMES_DESC"
	MediaListSortRepeat                MediaListSort = "REPEAT"
	MediaListSortRepeatDesc            MediaListSort = "REPEAT_DESC"
	MediaListSortPriority              MediaListSort = "PRIORITY"
	MediaListSortPriorityDesc          MediaListSort = "PRIORITY_DESC"
	MediaListSortStartedOn             MediaListSort = "STARTED_ON"
	MediaListSortStartedOnDesc         MediaListSort = "STARTED_ON_DESC"
	MediaListSortFinishedOn            MediaListSort = "FINISHED_ON"
	MediaListSortFinishedOnDesc        MediaListSort = "FINISHED_ON_DESC"
	MediaListSortAddedTime             MediaListSort = "ADDED_TIME"
	MediaListSortAddedTimeDesc         MediaListSort = "ADDED_TIME_DESC"
	MediaListSortUpdatedTime           MediaListSort = "UPDATED_TIME"
	MediaListSortUpdatedTimeDesc       MediaListSort = "UPDATED_TIME_DESC"
	MediaListSortMediaTitleRomaji      MediaListSort = "MEDIA_TITLE_ROMAJI"
	MediaListSortMediaTitleRomajiDesc  MediaListSort = "MEDIA_TITLE_ROMAJI_DESC"
	MediaListSortMediaTitleEnglish     MediaListSort = "MEDIA_TITLE_ENGLISH"
	MediaListSortMediaTitleEnglishDesc MediaListSort = "MEDIA_TITLE_ENGLISH_DESC"
	MediaListSortMediaTitleNative      MediaListSort = "MEDIA_TITLE_NATIVE"
	MediaListSortMediaTitleNativeDesc  MediaListSort = "MEDIA_TITLE_NATIVE_DESC"
	MediaListSortMediaPopularity       MediaListSort = "MEDIA_POPULARITY"
	MediaListSortMediaPopularityDesc   MediaListSort = "MEDIA_POPULARITY_DESC"
)

var AllMediaListSort = []MediaListSort{
	MediaListSortMediaID,
	MediaListSortMediaIDDesc,
	MediaListSortScore,
	MediaListSortScoreDesc,
	MediaListSortStatus,
	MediaListSortStatusDesc,
	MediaListSortProgress,
	MediaListSortProgressDesc,
	MediaListSortProgressVolumes,
	MediaListSortProgressVolumesDesc,
	MediaListSortRepeat,
	MediaListSortRepeatDesc,
	MediaListSortPriority,
	MediaListSortPriorityDesc,
	MediaListSortStartedOn,
	MediaListSortStartedOnDesc,
	MediaListSortFinishedOn,
	MediaListSortFinishedOnDesc,
	MediaListSortAddedTime,
	MediaListSortAddedTimeDesc,
	MediaListSortUpdatedTime,
	MediaListSortUpdatedTimeDesc,
	MediaListSortMediaTitleRomaji,
	MediaListSortMediaTitleRomajiDesc,
	MediaListSortMediaTitleEnglish,
	MediaListSortMediaTitleEnglishDesc,
	MediaListSortMediaTitleNative,
	MediaListSortMediaTitleNativeDesc,
	MediaListSortMediaPopularity,
	MediaListSortMediaPopularityDesc,
}

func (e MediaListSort) IsValid() bool {
	switch e {
	case MediaListSortMediaID, MediaListSortMediaIDDesc, MediaListSortScore, MediaListSortScoreDesc, MediaListSortStatus, MediaListSortStatusDesc, MediaListSortProgress, MediaListSortProgressDesc, MediaListSortProgressVolumes, MediaListSortProgressVolumesDesc, MediaListSortRepeat, MediaListSortRepeatDesc, MediaListSortPriority, MediaListSortPriorityDesc, MediaListSortStartedOn, MediaListSortStartedOnDesc, MediaListSortFinishedOn, MediaListSortFinishedOnDesc, MediaListSortAddedTime, MediaListSortAddedTimeDesc, MediaListSortUpdatedTime, MediaListSortUpdatedTimeDesc, MediaListSortMediaTitleRomaji, MediaListSortMediaTitleRomajiDesc, MediaListSortMediaTitleEnglish, MediaListSortMediaTitleEnglishDesc, MediaListSortMediaTitleNative, MediaListSortMediaTitleNativeDesc, MediaListSortMediaPopularity, MediaListSortMediaPopularityDesc:
		return true
	}
	return false
}

func (e MediaListSort) String() string {
	return string(e)
}

func (e *MediaListSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaListSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaListSort", str)
	}
	return nil
}

func (e MediaListSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaListSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaListSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Media list watching/reading status enum.
type MediaListStatus string

const (
	// Currently watching/reading
	MediaListStatusCurrent MediaListStatus = "CURRENT"
	// Planning to watch/read
	MediaListStatusPlanning MediaListStatus = "PLANNING"
	// Finished watching/reading
	MediaListStatusCompleted MediaListStatus = "COMPLETED"
	// Stopped watching/reading before completing
	MediaListStatusDropped MediaListStatus = "DROPPED"
	// Paused watching/reading
	MediaListStatusPaused MediaListStatus = "PAUSED"
	// Re-watching/reading
	MediaListStatusRepeating MediaListStatus = "REPEATING"
)

var AllMediaListStatus = []MediaListStatus{
	MediaListStatusCurrent,
	MediaListStatusPlanning,
	MediaListStatusCompleted,
	MediaListStatusDropped,
	MediaListStatusPaused,
	MediaListStatusRepeating,
}

func (e MediaListStatus) IsValid() bool {
	switch e {
	case MediaListStatusCurrent, MediaListStatusPlanning, MediaListStatusCompleted, MediaListStatusDropped, MediaListStatusPaused, MediaListStatusRepeating:
		return true
	}
	return false
}

func (e MediaListStatus) String() string {
	return string(e)
}

func (e *MediaListStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaListStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaListStatus", str)
	}
	return nil
}

func (e MediaListStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaListStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaListStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The type of ranking
type MediaRankType string

const (
	// Ranking is based on the media's ratings/score
	MediaRankTypeRated MediaRankType = "RATED"
	// Ranking is based on the media's popularity
	MediaRankTypePopular MediaRankType = "POPULAR"
)

var AllMediaRankType = []MediaRankType{
	MediaRankTypeRated,
	MediaRankTypePopular,
}

func (e MediaRankType) IsValid() bool {
	switch e {
	case MediaRankTypeRated, MediaRankTypePopular:
		return true
	}
	return false
}

func (e MediaRankType) String() string {
	return string(e)
}

func (e *MediaRankType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaRankType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaRankType", str)
	}
	return nil
}

func (e MediaRankType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaRankType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaRankType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of relation media has to its parent.
type MediaRelation string

const (
	// An adaption of this media into a different format
	MediaRelationAdaptation MediaRelation = "ADAPTATION"
	// Released before the relation
	MediaRelationPrequel MediaRelation = "PREQUEL"
	// Released after the relation
	MediaRelationSequel MediaRelation = "SEQUEL"
	// The media a side story is from
	MediaRelationParent MediaRelation = "PARENT"
	// A side story of the parent media
	MediaRelationSideStory MediaRelation = "SIDE_STORY"
	// Shares at least 1 character
	MediaRelationCharacter MediaRelation = "CHARACTER"
	// A shortened and summarized version
	MediaRelationSummary MediaRelation = "SUMMARY"
	// An alternative version of the same media
	MediaRelationAlternative MediaRelation = "ALTERNATIVE"
	// An alternative version of the media with a different primary focus
	MediaRelationSpinOff MediaRelation = "SPIN_OFF"
	// Other
	MediaRelationOther MediaRelation = "OTHER"
	// Version 2 only. The source material the media was adapted from
	MediaRelationSource MediaRelation = "SOURCE"
	// Version 2 only.
	MediaRelationCompilation MediaRelation = "COMPILATION"
	// Version 2 only.
	MediaRelationContains MediaRelation = "CONTAINS"
)

var AllMediaRelation = []MediaRelation{
	MediaRelationAdaptation,
	MediaRelationPrequel,
	MediaRelationSequel,
	MediaRelationParent,
	MediaRelationSideStory,
	MediaRelationCharacter,
	MediaRelationSummary,
	MediaRelationAlternative,
	MediaRelationSpinOff,
	MediaRelationOther,
	MediaRelationSource,
	MediaRelationCompilation,
	MediaRelationContains,
}

func (e MediaRelation) IsValid() bool {
	switch e {
	case MediaRelationAdaptation, MediaRelationPrequel, MediaRelationSequel, MediaRelationParent, MediaRelationSideStory, MediaRelationCharacter, MediaRelationSummary, MediaRelationAlternative, MediaRelationSpinOff, MediaRelationOther, MediaRelationSource, MediaRelationCompilation, MediaRelationContains:
		return true
	}
	return false
}

func (e MediaRelation) String() string {
	return string(e)
}

func (e *MediaRelation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaRelation", str)
	}
	return nil
}

func (e MediaRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaRelation) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaRelation) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MediaSeason string

const (
	// Months December to February
	MediaSeasonWinter MediaSeason = "WINTER"
	// Months March to May
	MediaSeasonSpring MediaSeason = "SPRING"
	// Months June to August
	MediaSeasonSummer MediaSeason = "SUMMER"
	// Months September to November
	MediaSeasonFall MediaSeason = "FALL"
)

var AllMediaSeason = []MediaSeason{
	MediaSeasonWinter,
	MediaSeasonSpring,
	MediaSeasonSummer,
	MediaSeasonFall,
}

func (e MediaSeason) IsValid() bool {
	switch e {
	case MediaSeasonWinter, MediaSeasonSpring, MediaSeasonSummer, MediaSeasonFall:
		return true
	}
	return false
}

func (e MediaSeason) String() string {
	return string(e)
}

func (e *MediaSeason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaSeason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaSeason", str)
	}
	return nil
}

func (e MediaSeason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaSeason) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaSeason) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Media sort enums
type MediaSort string

const (
	MediaSortID               MediaSort = "ID"
	MediaSortIDDesc           MediaSort = "ID_DESC"
	MediaSortTitleRomaji      MediaSort = "TITLE_ROMAJI"
	MediaSortTitleRomajiDesc  MediaSort = "TITLE_ROMAJI_DESC"
	MediaSortTitleEnglish     MediaSort = "TITLE_ENGLISH"
	MediaSortTitleEnglishDesc MediaSort = "TITLE_ENGLISH_DESC"
	MediaSortTitleNative      MediaSort = "TITLE_NATIVE"
	MediaSortTitleNativeDesc  MediaSort = "TITLE_NATIVE_DESC"
	MediaSortType             MediaSort = "TYPE"
	MediaSortTypeDesc         MediaSort = "TYPE_DESC"
	MediaSortFormat           MediaSort = "FORMAT"
	MediaSortFormatDesc       MediaSort = "FORMAT_DESC"
	MediaSortStartDate        MediaSort = "START_DATE"
	MediaSortStartDateDesc    MediaSort = "START_DATE_DESC"
	MediaSortEndDate          MediaSort = "END_DATE"
	MediaSortEndDateDesc      MediaSort = "END_DATE_DESC"
	MediaSortScore            MediaSort = "SCORE"
	MediaSortScoreDesc        MediaSort = "SCORE_DESC"
	MediaSortPopularity       MediaSort = "POPULARITY"
	MediaSortPopularityDesc   MediaSort = "POPULARITY_DESC"
	MediaSortTrending         MediaSort = "TRENDING"
	MediaSortTrendingDesc     MediaSort = "TRENDING_DESC"
	MediaSortEpisodes         MediaSort = "EPISODES"
	MediaSortEpisodesDesc     MediaSort = "EPISODES_DESC"
	MediaSortDuration         MediaSort = "DURATION"
	MediaSortDurationDesc     MediaSort = "DURATION_DESC"
	MediaSortStatus           MediaSort = "STATUS"
	MediaSortStatusDesc       MediaSort = "STATUS_DESC"
	MediaSortChapters         MediaSort = "CHAPTERS"
	MediaSortChaptersDesc     MediaSort = "CHAPTERS_DESC"
	MediaSortVolumes          MediaSort = "VOLUMES"
	MediaSortVolumesDesc      MediaSort = "VOLUMES_DESC"
	MediaSortUpdatedAt        MediaSort = "UPDATED_AT"
	MediaSortUpdatedAtDesc    MediaSort = "UPDATED_AT_DESC"
	MediaSortSearchMatch      MediaSort = "SEARCH_MATCH"
	MediaSortFavourites       MediaSort = "FAVOURITES"
	MediaSortFavouritesDesc   MediaSort = "FAVOURITES_DESC"
)

var AllMediaSort = []MediaSort{
	MediaSortID,
	MediaSortIDDesc,
	MediaSortTitleRomaji,
	MediaSortTitleRomajiDesc,
	MediaSortTitleEnglish,
	MediaSortTitleEnglishDesc,
	MediaSortTitleNative,
	MediaSortTitleNativeDesc,
	MediaSortType,
	MediaSortTypeDesc,
	MediaSortFormat,
	MediaSortFormatDesc,
	MediaSortStartDate,
	MediaSortStartDateDesc,
	MediaSortEndDate,
	MediaSortEndDateDesc,
	MediaSortScore,
	MediaSortScoreDesc,
	MediaSortPopularity,
	MediaSortPopularityDesc,
	MediaSortTrending,
	MediaSortTrendingDesc,
	MediaSortEpisodes,
	MediaSortEpisodesDesc,
	MediaSortDuration,
	MediaSortDurationDesc,
	MediaSortStatus,
	MediaSortStatusDesc,
	MediaSortChapters,
	MediaSortChaptersDesc,
	MediaSortVolumes,
	MediaSortVolumesDesc,
	MediaSortUpdatedAt,
	MediaSortUpdatedAtDesc,
	MediaSortSearchMatch,
	MediaSortFavourites,
	MediaSortFavouritesDesc,
}

func (e MediaSort) IsValid() bool {
	switch e {
	case MediaSortID, MediaSortIDDesc, MediaSortTitleRomaji, MediaSortTitleRomajiDesc, MediaSortTitleEnglish, MediaSortTitleEnglishDesc, MediaSortTitleNative, MediaSortTitleNativeDesc, MediaSortType, MediaSortTypeDesc, MediaSortFormat, MediaSortFormatDesc, MediaSortStartDate, MediaSortStartDateDesc, MediaSortEndDate, MediaSortEndDateDesc, MediaSortScore, MediaSortScoreDesc, MediaSortPopularity, MediaSortPopularityDesc, MediaSortTrending, MediaSortTrendingDesc, MediaSortEpisodes, MediaSortEpisodesDesc, MediaSortDuration, MediaSortDurationDesc, MediaSortStatus, MediaSortStatusDesc, MediaSortChapters, MediaSortChaptersDesc, MediaSortVolumes, MediaSortVolumesDesc, MediaSortUpdatedAt, MediaSortUpdatedAtDesc, MediaSortSearchMatch, MediaSortFavourites, MediaSortFavouritesDesc:
		return true
	}
	return false
}

func (e MediaSort) String() string {
	return string(e)
}

func (e *MediaSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaSort", str)
	}
	return nil
}

func (e MediaSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Source type the media was adapted from
type MediaSource string

const (
	// An original production not based of another work
	MediaSourceOriginal MediaSource = "ORIGINAL"
	// Asian comic book
	MediaSourceManga MediaSource = "MANGA"
	// Written work published in volumes
	MediaSourceLightNovel MediaSource = "LIGHT_NOVEL"
	// Video game driven primary by text and narrative
	MediaSourceVisualNovel MediaSource = "VISUAL_NOVEL"
	// Video game
	MediaSourceVideoGame MediaSource = "VIDEO_GAME"
	// Other
	MediaSourceOther MediaSource = "OTHER"
	// Version 2+ only. Written works not published in volumes
	MediaSourceNovel MediaSource = "NOVEL"
	// Version 2+ only. Self-published works
	MediaSourceDoujinshi MediaSource = "DOUJINSHI"
	// Version 2+ only. Japanese Anime
	MediaSourceAnime MediaSource = "ANIME"
	// Version 3 only. Written works published online
	MediaSourceWebNovel MediaSource = "WEB_NOVEL"
	// Version 3 only. Live action media such as movies or TV show
	MediaSourceLiveAction MediaSource = "LIVE_ACTION"
	// Version 3 only. Games excluding video games
	MediaSourceGame MediaSource = "GAME"
	// Version 3 only. Comics excluding manga
	MediaSourceComic MediaSource = "COMIC"
	// Version 3 only. Multimedia project
	MediaSourceMultimediaProject MediaSource = "MULTIMEDIA_PROJECT"
	// Version 3 only. Picture book
	MediaSourcePictureBook MediaSource = "PICTURE_BOOK"
)

var AllMediaSource = []MediaSource{
	MediaSourceOriginal,
	MediaSourceManga,
	MediaSourceLightNovel,
	MediaSourceVisualNovel,
	MediaSourceVideoGame,
	MediaSourceOther,
	MediaSourceNovel,
	MediaSourceDoujinshi,
	MediaSourceAnime,
	MediaSourceWebNovel,
	MediaSourceLiveAction,
	MediaSourceGame,
	MediaSourceComic,
	MediaSourceMultimediaProject,
	MediaSourcePictureBook,
}

func (e MediaSource) IsValid() bool {
	switch e {
	case MediaSourceOriginal, MediaSourceManga, MediaSourceLightNovel, MediaSourceVisualNovel, MediaSourceVideoGame, MediaSourceOther, MediaSourceNovel, MediaSourceDoujinshi, MediaSourceAnime, MediaSourceWebNovel, MediaSourceLiveAction, MediaSourceGame, MediaSourceComic, MediaSourceMultimediaProject, MediaSourcePictureBook:
		return true
	}
	return false
}

func (e MediaSource) String() string {
	return string(e)
}

func (e *MediaSource) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaSource", str)
	}
	return nil
}

func (e MediaSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaSource) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaSource) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The current releasing status of the media
type MediaStatus string

const (
	// Has completed and is no longer being released
	MediaStatusFinished MediaStatus = "FINISHED"
	// Currently releasing
	MediaStatusReleasing MediaStatus = "RELEASING"
	// To be released at a later date
	MediaStatusNotYetReleased MediaStatus = "NOT_YET_RELEASED"
	// Ended before the work could be finished
	MediaStatusCancelled MediaStatus = "CANCELLED"
	// Version 2 only. Is currently paused from releasing and will resume at a later date
	MediaStatusHiatus MediaStatus = "HIATUS"
)

var AllMediaStatus = []MediaStatus{
	MediaStatusFinished,
	MediaStatusReleasing,
	MediaStatusNotYetReleased,
	MediaStatusCancelled,
	MediaStatusHiatus,
}

func (e MediaStatus) IsValid() bool {
	switch e {
	case MediaStatusFinished, MediaStatusReleasing, MediaStatusNotYetReleased, MediaStatusCancelled, MediaStatusHiatus:
		return true
	}
	return false
}

func (e MediaStatus) String() string {
	return string(e)
}

func (e *MediaStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaStatus", str)
	}
	return nil
}

func (e MediaStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Media trend sort enums
type MediaTrendSort string

const (
	MediaTrendSortID             MediaTrendSort = "ID"
	MediaTrendSortIDDesc         MediaTrendSort = "ID_DESC"
	MediaTrendSortMediaID        MediaTrendSort = "MEDIA_ID"
	MediaTrendSortMediaIDDesc    MediaTrendSort = "MEDIA_ID_DESC"
	MediaTrendSortDate           MediaTrendSort = "DATE"
	MediaTrendSortDateDesc       MediaTrendSort = "DATE_DESC"
	MediaTrendSortScore          MediaTrendSort = "SCORE"
	MediaTrendSortScoreDesc      MediaTrendSort = "SCORE_DESC"
	MediaTrendSortPopularity     MediaTrendSort = "POPULARITY"
	MediaTrendSortPopularityDesc MediaTrendSort = "POPULARITY_DESC"
	MediaTrendSortTrending       MediaTrendSort = "TRENDING"
	MediaTrendSortTrendingDesc   MediaTrendSort = "TRENDING_DESC"
	MediaTrendSortEpisode        MediaTrendSort = "EPISODE"
	MediaTrendSortEpisodeDesc    MediaTrendSort = "EPISODE_DESC"
)

var AllMediaTrendSort = []MediaTrendSort{
	MediaTrendSortID,
	MediaTrendSortIDDesc,
	MediaTrendSortMediaID,
	MediaTrendSortMediaIDDesc,
	MediaTrendSortDate,
	MediaTrendSortDateDesc,
	MediaTrendSortScore,
	MediaTrendSortScoreDesc,
	MediaTrendSortPopularity,
	MediaTrendSortPopularityDesc,
	MediaTrendSortTrending,
	MediaTrendSortTrendingDesc,
	MediaTrendSortEpisode,
	MediaTrendSortEpisodeDesc,
}

func (e MediaTrendSort) IsValid() bool {
	switch e {
	case MediaTrendSortID, MediaTrendSortIDDesc, MediaTrendSortMediaID, MediaTrendSortMediaIDDesc, MediaTrendSortDate, MediaTrendSortDateDesc, MediaTrendSortScore, MediaTrendSortScoreDesc, MediaTrendSortPopularity, MediaTrendSortPopularityDesc, MediaTrendSortTrending, MediaTrendSortTrendingDesc, MediaTrendSortEpisode, MediaTrendSortEpisodeDesc:
		return true
	}
	return false
}

func (e MediaTrendSort) String() string {
	return string(e)
}

func (e *MediaTrendSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaTrendSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaTrendSort", str)
	}
	return nil
}

func (e MediaTrendSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaTrendSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaTrendSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Media type enum, anime or manga.
type MediaType string

const (
	// Japanese Anime
	MediaTypeAnime MediaType = "ANIME"
	// Asian comic
	MediaTypeManga MediaType = "MANGA"
)

var AllMediaType = []MediaType{
	MediaTypeAnime,
	MediaTypeManga,
}

func (e MediaType) IsValid() bool {
	switch e {
	case MediaTypeAnime, MediaTypeManga:
		return true
	}
	return false
}

func (e MediaType) String() string {
	return string(e)
}

func (e *MediaType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaType", str)
	}
	return nil
}

func (e MediaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ModActionType string

const (
	ModActionTypeNote   ModActionType = "NOTE"
	ModActionTypeBan    ModActionType = "BAN"
	ModActionTypeDelete ModActionType = "DELETE"
	ModActionTypeEdit   ModActionType = "EDIT"
	ModActionTypeExpire ModActionType = "EXPIRE"
	ModActionTypeReport ModActionType = "REPORT"
	ModActionTypeReset  ModActionType = "RESET"
	ModActionTypeAnon   ModActionType = "ANON"
)

var AllModActionType = []ModActionType{
	ModActionTypeNote,
	ModActionTypeBan,
	ModActionTypeDelete,
	ModActionTypeEdit,
	ModActionTypeExpire,
	ModActionTypeReport,
	ModActionTypeReset,
	ModActionTypeAnon,
}

func (e ModActionType) IsValid() bool {
	switch e {
	case ModActionTypeNote, ModActionTypeBan, ModActionTypeDelete, ModActionTypeEdit, ModActionTypeExpire, ModActionTypeReport, ModActionTypeReset, ModActionTypeAnon:
		return true
	}
	return false
}

func (e ModActionType) String() string {
	return string(e)
}

func (e *ModActionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ModActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ModActionType", str)
	}
	return nil
}

func (e ModActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ModActionType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ModActionType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Mod role enums
type ModRole string

const (
	// An AniList administrator
	ModRoleAdmin ModRole = "ADMIN"
	// A head developer of AniList
	ModRoleLeadDeveloper ModRole = "LEAD_DEVELOPER"
	// An AniList developer
	ModRoleDeveloper ModRole = "DEVELOPER"
	// A lead community moderator
	ModRoleLeadCommunity ModRole = "LEAD_COMMUNITY"
	// A community moderator
	ModRoleCommunity ModRole = "COMMUNITY"
	// A discord community moderator
	ModRoleDiscordCommunity ModRole = "DISCORD_COMMUNITY"
	// A lead anime data moderator
	ModRoleLeadAnimeData ModRole = "LEAD_ANIME_DATA"
	// An anime data moderator
	ModRoleAnimeData ModRole = "ANIME_DATA"
	// A lead manga data moderator
	ModRoleLeadMangaData ModRole = "LEAD_MANGA_DATA"
	// A manga data moderator
	ModRoleMangaData ModRole = "MANGA_DATA"
	// A lead social media moderator
	ModRoleLeadSocialMedia ModRole = "LEAD_SOCIAL_MEDIA"
	// A social media moderator
	ModRoleSocialMedia ModRole = "SOCIAL_MEDIA"
	// A retired moderator
	ModRoleRetired ModRole = "RETIRED"
	// A character data moderator
	ModRoleCharacterData ModRole = "CHARACTER_DATA"
	// A staff data moderator
	ModRoleStaffData ModRole = "STAFF_DATA"
)

var AllModRole = []ModRole{
	ModRoleAdmin,
	ModRoleLeadDeveloper,
	ModRoleDeveloper,
	ModRoleLeadCommunity,
	ModRoleCommunity,
	ModRoleDiscordCommunity,
	ModRoleLeadAnimeData,
	ModRoleAnimeData,
	ModRoleLeadMangaData,
	ModRoleMangaData,
	ModRoleLeadSocialMedia,
	ModRoleSocialMedia,
	ModRoleRetired,
	ModRoleCharacterData,
	ModRoleStaffData,
}

func (e ModRole) IsValid() bool {
	switch e {
	case ModRoleAdmin, ModRoleLeadDeveloper, ModRoleDeveloper, ModRoleLeadCommunity, ModRoleCommunity, ModRoleDiscordCommunity, ModRoleLeadAnimeData, ModRoleAnimeData, ModRoleLeadMangaData, ModRoleMangaData, ModRoleLeadSocialMedia, ModRoleSocialMedia, ModRoleRetired, ModRoleCharacterData, ModRoleStaffData:
		return true
	}
	return false
}

func (e ModRole) String() string {
	return string(e)
}

func (e *ModRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ModRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ModRole", str)
	}
	return nil
}

func (e ModRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ModRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ModRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Notification type enum
type NotificationType string

const (
	// A user has sent you message
	NotificationTypeActivityMessage NotificationType = "ACTIVITY_MESSAGE"
	// A user has replied to your activity
	NotificationTypeActivityReply NotificationType = "ACTIVITY_REPLY"
	// A user has followed you
	NotificationTypeFollowing NotificationType = "FOLLOWING"
	// A user has mentioned you in their activity
	NotificationTypeActivityMention NotificationType = "ACTIVITY_MENTION"
	// A user has mentioned you in a forum comment
	NotificationTypeThreadCommentMention NotificationType = "THREAD_COMMENT_MENTION"
	// A user has commented in one of your subscribed forum threads
	NotificationTypeThreadSubscribed NotificationType = "THREAD_SUBSCRIBED"
	// A user has replied to your forum comment
	NotificationTypeThreadCommentReply NotificationType = "THREAD_COMMENT_REPLY"
	// An anime you are currently watching has aired
	NotificationTypeAiring NotificationType = "AIRING"
	// A user has liked your activity
	NotificationTypeActivityLike NotificationType = "ACTIVITY_LIKE"
	// A user has liked your activity reply
	NotificationTypeActivityReplyLike NotificationType = "ACTIVITY_REPLY_LIKE"
	// A user has liked your forum thread
	NotificationTypeThreadLike NotificationType = "THREAD_LIKE"
	// A user has liked your forum comment
	NotificationTypeThreadCommentLike NotificationType = "THREAD_COMMENT_LIKE"
	// A user has replied to activity you have also replied to
	NotificationTypeActivityReplySubscribed NotificationType = "ACTIVITY_REPLY_SUBSCRIBED"
	// A new anime or manga has been added to the site where its related media is on the user's list
	NotificationTypeRelatedMediaAddition NotificationType = "RELATED_MEDIA_ADDITION"
	// An anime or manga has had a data change that affects how a user may track it in their lists
	NotificationTypeMediaDataChange NotificationType = "MEDIA_DATA_CHANGE"
	// Anime or manga entries on the user's list have been merged into a single entry
	NotificationTypeMediaMerge NotificationType = "MEDIA_MERGE"
	// An anime or manga on the user's list has been deleted from the site
	NotificationTypeMediaDeletion NotificationType = "MEDIA_DELETION"
)

var AllNotificationType = []NotificationType{
	NotificationTypeActivityMessage,
	NotificationTypeActivityReply,
	NotificationTypeFollowing,
	NotificationTypeActivityMention,
	NotificationTypeThreadCommentMention,
	NotificationTypeThreadSubscribed,
	NotificationTypeThreadCommentReply,
	NotificationTypeAiring,
	NotificationTypeActivityLike,
	NotificationTypeActivityReplyLike,
	NotificationTypeThreadLike,
	NotificationTypeThreadCommentLike,
	NotificationTypeActivityReplySubscribed,
	NotificationTypeRelatedMediaAddition,
	NotificationTypeMediaDataChange,
	NotificationTypeMediaMerge,
	NotificationTypeMediaDeletion,
}

func (e NotificationType) IsValid() bool {
	switch e {
	case NotificationTypeActivityMessage, NotificationTypeActivityReply, NotificationTypeFollowing, NotificationTypeActivityMention, NotificationTypeThreadCommentMention, NotificationTypeThreadSubscribed, NotificationTypeThreadCommentReply, NotificationTypeAiring, NotificationTypeActivityLike, NotificationTypeActivityReplyLike, NotificationTypeThreadLike, NotificationTypeThreadCommentLike, NotificationTypeActivityReplySubscribed, NotificationTypeRelatedMediaAddition, NotificationTypeMediaDataChange, NotificationTypeMediaMerge, NotificationTypeMediaDeletion:
		return true
	}
	return false
}

func (e NotificationType) String() string {
	return string(e)
}

func (e *NotificationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationType", str)
	}
	return nil
}

func (e NotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NotificationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NotificationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Recommendation rating enums
type RecommendationRating string

const (
	RecommendationRatingNoRating RecommendationRating = "NO_RATING"
	RecommendationRatingRateUp   RecommendationRating = "RATE_UP"
	RecommendationRatingRateDown RecommendationRating = "RATE_DOWN"
)

var AllRecommendationRating = []RecommendationRating{
	RecommendationRatingNoRating,
	RecommendationRatingRateUp,
	RecommendationRatingRateDown,
}

func (e RecommendationRating) IsValid() bool {
	switch e {
	case RecommendationRatingNoRating, RecommendationRatingRateUp, RecommendationRatingRateDown:
		return true
	}
	return false
}

func (e RecommendationRating) String() string {
	return string(e)
}

func (e *RecommendationRating) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RecommendationRating(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RecommendationRating", str)
	}
	return nil
}

func (e RecommendationRating) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RecommendationRating) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RecommendationRating) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Recommendation sort enums
type RecommendationSort string

const (
	RecommendationSortID         RecommendationSort = "ID"
	RecommendationSortIDDesc     RecommendationSort = "ID_DESC"
	RecommendationSortRating     RecommendationSort = "RATING"
	RecommendationSortRatingDesc RecommendationSort = "RATING_DESC"
)

var AllRecommendationSort = []RecommendationSort{
	RecommendationSortID,
	RecommendationSortIDDesc,
	RecommendationSortRating,
	RecommendationSortRatingDesc,
}

func (e RecommendationSort) IsValid() bool {
	switch e {
	case RecommendationSortID, RecommendationSortIDDesc, RecommendationSortRating, RecommendationSortRatingDesc:
		return true
	}
	return false
}

func (e RecommendationSort) String() string {
	return string(e)
}

func (e *RecommendationSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RecommendationSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RecommendationSort", str)
	}
	return nil
}

func (e RecommendationSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RecommendationSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RecommendationSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Review rating enums
type ReviewRating string

const (
	ReviewRatingNoVote   ReviewRating = "NO_VOTE"
	ReviewRatingUpVote   ReviewRating = "UP_VOTE"
	ReviewRatingDownVote ReviewRating = "DOWN_VOTE"
)

var AllReviewRating = []ReviewRating{
	ReviewRatingNoVote,
	ReviewRatingUpVote,
	ReviewRatingDownVote,
}

func (e ReviewRating) IsValid() bool {
	switch e {
	case ReviewRatingNoVote, ReviewRatingUpVote, ReviewRatingDownVote:
		return true
	}
	return false
}

func (e ReviewRating) String() string {
	return string(e)
}

func (e *ReviewRating) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReviewRating(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReviewRating", str)
	}
	return nil
}

func (e ReviewRating) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ReviewRating) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ReviewRating) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Review sort enums
type ReviewSort string

const (
	ReviewSortID            ReviewSort = "ID"
	ReviewSortIDDesc        ReviewSort = "ID_DESC"
	ReviewSortScore         ReviewSort = "SCORE"
	ReviewSortScoreDesc     ReviewSort = "SCORE_DESC"
	ReviewSortRating        ReviewSort = "RATING"
	ReviewSortRatingDesc    ReviewSort = "RATING_DESC"
	ReviewSortCreatedAt     ReviewSort = "CREATED_AT"
	ReviewSortCreatedAtDesc ReviewSort = "CREATED_AT_DESC"
	ReviewSortUpdatedAt     ReviewSort = "UPDATED_AT"
	ReviewSortUpdatedAtDesc ReviewSort = "UPDATED_AT_DESC"
)

var AllReviewSort = []ReviewSort{
	ReviewSortID,
	ReviewSortIDDesc,
	ReviewSortScore,
	ReviewSortScoreDesc,
	ReviewSortRating,
	ReviewSortRatingDesc,
	ReviewSortCreatedAt,
	ReviewSortCreatedAtDesc,
	ReviewSortUpdatedAt,
	ReviewSortUpdatedAtDesc,
}

func (e ReviewSort) IsValid() bool {
	switch e {
	case ReviewSortID, ReviewSortIDDesc, ReviewSortScore, ReviewSortScoreDesc, ReviewSortRating, ReviewSortRatingDesc, ReviewSortCreatedAt, ReviewSortCreatedAtDesc, ReviewSortUpdatedAt, ReviewSortUpdatedAtDesc:
		return true
	}
	return false
}

func (e ReviewSort) String() string {
	return string(e)
}

func (e *ReviewSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReviewSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReviewSort", str)
	}
	return nil
}

func (e ReviewSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ReviewSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ReviewSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Revision history actions
type RevisionHistoryAction string

const (
	RevisionHistoryActionCreate RevisionHistoryAction = "CREATE"
	RevisionHistoryActionEdit   RevisionHistoryAction = "EDIT"
)

var AllRevisionHistoryAction = []RevisionHistoryAction{
	RevisionHistoryActionCreate,
	RevisionHistoryActionEdit,
}

func (e RevisionHistoryAction) IsValid() bool {
	switch e {
	case RevisionHistoryActionCreate, RevisionHistoryActionEdit:
		return true
	}
	return false
}

func (e RevisionHistoryAction) String() string {
	return string(e)
}

func (e *RevisionHistoryAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RevisionHistoryAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RevisionHistoryAction", str)
	}
	return nil
}

func (e RevisionHistoryAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RevisionHistoryAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RevisionHistoryAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Media list scoring type
type ScoreFormat string

const (
	// An integer from 0-100
	ScoreFormatPoint100 ScoreFormat = "POINT_100"
	// A float from 0-10 with 1 decimal place
	ScoreFormatPoint10Decimal ScoreFormat = "POINT_10_DECIMAL"
	// An integer from 0-10
	ScoreFormatPoint10 ScoreFormat = "POINT_10"
	// An integer from 0-5. Should be represented in Stars
	ScoreFormatPoint5 ScoreFormat = "POINT_5"
	// An integer from 0-3. Should be represented in Smileys. 0 => No Score, 1 => :(, 2 => :|, 3 => :)
	ScoreFormatPoint3 ScoreFormat = "POINT_3"
)

var AllScoreFormat = []ScoreFormat{
	ScoreFormatPoint100,
	ScoreFormatPoint10Decimal,
	ScoreFormatPoint10,
	ScoreFormatPoint5,
	ScoreFormatPoint3,
}

func (e ScoreFormat) IsValid() bool {
	switch e {
	case ScoreFormatPoint100, ScoreFormatPoint10Decimal, ScoreFormatPoint10, ScoreFormatPoint5, ScoreFormatPoint3:
		return true
	}
	return false
}

func (e ScoreFormat) String() string {
	return string(e)
}

func (e *ScoreFormat) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScoreFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScoreFormat", str)
	}
	return nil
}

func (e ScoreFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ScoreFormat) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ScoreFormat) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Site trend sort enums
type SiteTrendSort string

const (
	SiteTrendSortDate       SiteTrendSort = "DATE"
	SiteTrendSortDateDesc   SiteTrendSort = "DATE_DESC"
	SiteTrendSortCount      SiteTrendSort = "COUNT"
	SiteTrendSortCountDesc  SiteTrendSort = "COUNT_DESC"
	SiteTrendSortChange     SiteTrendSort = "CHANGE"
	SiteTrendSortChangeDesc SiteTrendSort = "CHANGE_DESC"
)

var AllSiteTrendSort = []SiteTrendSort{
	SiteTrendSortDate,
	SiteTrendSortDateDesc,
	SiteTrendSortCount,
	SiteTrendSortCountDesc,
	SiteTrendSortChange,
	SiteTrendSortChangeDesc,
}

func (e SiteTrendSort) IsValid() bool {
	switch e {
	case SiteTrendSortDate, SiteTrendSortDateDesc, SiteTrendSortCount, SiteTrendSortCountDesc, SiteTrendSortChange, SiteTrendSortChangeDesc:
		return true
	}
	return false
}

func (e SiteTrendSort) String() string {
	return string(e)
}

func (e *SiteTrendSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SiteTrendSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SiteTrendSort", str)
	}
	return nil
}

func (e SiteTrendSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SiteTrendSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SiteTrendSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The primary language of the voice actor
type StaffLanguage string

const (
	// Japanese
	StaffLanguageJapanese StaffLanguage = "JAPANESE"
	// English
	StaffLanguageEnglish StaffLanguage = "ENGLISH"
	// Korean
	StaffLanguageKorean StaffLanguage = "KOREAN"
	// Italian
	StaffLanguageItalian StaffLanguage = "ITALIAN"
	// Spanish
	StaffLanguageSpanish StaffLanguage = "SPANISH"
	// Portuguese
	StaffLanguagePortuguese StaffLanguage = "PORTUGUESE"
	// French
	StaffLanguageFrench StaffLanguage = "FRENCH"
	// German
	StaffLanguageGerman StaffLanguage = "GERMAN"
	// Hebrew
	StaffLanguageHebrew StaffLanguage = "HEBREW"
	// Hungarian
	StaffLanguageHungarian StaffLanguage = "HUNGARIAN"
)

var AllStaffLanguage = []StaffLanguage{
	StaffLanguageJapanese,
	StaffLanguageEnglish,
	StaffLanguageKorean,
	StaffLanguageItalian,
	StaffLanguageSpanish,
	StaffLanguagePortuguese,
	StaffLanguageFrench,
	StaffLanguageGerman,
	StaffLanguageHebrew,
	StaffLanguageHungarian,
}

func (e StaffLanguage) IsValid() bool {
	switch e {
	case StaffLanguageJapanese, StaffLanguageEnglish, StaffLanguageKorean, StaffLanguageItalian, StaffLanguageSpanish, StaffLanguagePortuguese, StaffLanguageFrench, StaffLanguageGerman, StaffLanguageHebrew, StaffLanguageHungarian:
		return true
	}
	return false
}

func (e StaffLanguage) String() string {
	return string(e)
}

func (e *StaffLanguage) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StaffLanguage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StaffLanguage", str)
	}
	return nil
}

func (e StaffLanguage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StaffLanguage) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StaffLanguage) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Staff sort enums
type StaffSort string

const (
	StaffSortID             StaffSort = "ID"
	StaffSortIDDesc         StaffSort = "ID_DESC"
	StaffSortRole           StaffSort = "ROLE"
	StaffSortRoleDesc       StaffSort = "ROLE_DESC"
	StaffSortLanguage       StaffSort = "LANGUAGE"
	StaffSortLanguageDesc   StaffSort = "LANGUAGE_DESC"
	StaffSortSearchMatch    StaffSort = "SEARCH_MATCH"
	StaffSortFavourites     StaffSort = "FAVOURITES"
	StaffSortFavouritesDesc StaffSort = "FAVOURITES_DESC"
	// Order manually decided by moderators
	StaffSortRelevance StaffSort = "RELEVANCE"
)

var AllStaffSort = []StaffSort{
	StaffSortID,
	StaffSortIDDesc,
	StaffSortRole,
	StaffSortRoleDesc,
	StaffSortLanguage,
	StaffSortLanguageDesc,
	StaffSortSearchMatch,
	StaffSortFavourites,
	StaffSortFavouritesDesc,
	StaffSortRelevance,
}

func (e StaffSort) IsValid() bool {
	switch e {
	case StaffSortID, StaffSortIDDesc, StaffSortRole, StaffSortRoleDesc, StaffSortLanguage, StaffSortLanguageDesc, StaffSortSearchMatch, StaffSortFavourites, StaffSortFavouritesDesc, StaffSortRelevance:
		return true
	}
	return false
}

func (e StaffSort) String() string {
	return string(e)
}

func (e *StaffSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StaffSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StaffSort", str)
	}
	return nil
}

func (e StaffSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StaffSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StaffSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Studio sort enums
type StudioSort string

const (
	StudioSortID             StudioSort = "ID"
	StudioSortIDDesc         StudioSort = "ID_DESC"
	StudioSortName           StudioSort = "NAME"
	StudioSortNameDesc       StudioSort = "NAME_DESC"
	StudioSortSearchMatch    StudioSort = "SEARCH_MATCH"
	StudioSortFavourites     StudioSort = "FAVOURITES"
	StudioSortFavouritesDesc StudioSort = "FAVOURITES_DESC"
)

var AllStudioSort = []StudioSort{
	StudioSortID,
	StudioSortIDDesc,
	StudioSortName,
	StudioSortNameDesc,
	StudioSortSearchMatch,
	StudioSortFavourites,
	StudioSortFavouritesDesc,
}

func (e StudioSort) IsValid() bool {
	switch e {
	case StudioSortID, StudioSortIDDesc, StudioSortName, StudioSortNameDesc, StudioSortSearchMatch, StudioSortFavourites, StudioSortFavouritesDesc:
		return true
	}
	return false
}

func (e StudioSort) String() string {
	return string(e)
}

func (e *StudioSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StudioSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StudioSort", str)
	}
	return nil
}

func (e StudioSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StudioSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StudioSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Submission sort enums
type SubmissionSort string

const (
	SubmissionSortID     SubmissionSort = "ID"
	SubmissionSortIDDesc SubmissionSort = "ID_DESC"
)

var AllSubmissionSort = []SubmissionSort{
	SubmissionSortID,
	SubmissionSortIDDesc,
}

func (e SubmissionSort) IsValid() bool {
	switch e {
	case SubmissionSortID, SubmissionSortIDDesc:
		return true
	}
	return false
}

func (e SubmissionSort) String() string {
	return string(e)
}

func (e *SubmissionSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubmissionSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubmissionSort", str)
	}
	return nil
}

func (e SubmissionSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SubmissionSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SubmissionSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Submission status
type SubmissionStatus string

const (
	SubmissionStatusPending           SubmissionStatus = "PENDING"
	SubmissionStatusRejected          SubmissionStatus = "REJECTED"
	SubmissionStatusPartiallyAccepted SubmissionStatus = "PARTIALLY_ACCEPTED"
	SubmissionStatusAccepted          SubmissionStatus = "ACCEPTED"
)

var AllSubmissionStatus = []SubmissionStatus{
	SubmissionStatusPending,
	SubmissionStatusRejected,
	SubmissionStatusPartiallyAccepted,
	SubmissionStatusAccepted,
}

func (e SubmissionStatus) IsValid() bool {
	switch e {
	case SubmissionStatusPending, SubmissionStatusRejected, SubmissionStatusPartiallyAccepted, SubmissionStatusAccepted:
		return true
	}
	return false
}

func (e SubmissionStatus) String() string {
	return string(e)
}

func (e *SubmissionStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubmissionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SubmissionStatus", str)
	}
	return nil
}

func (e SubmissionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SubmissionStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SubmissionStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Thread comments sort enums
type ThreadCommentSort string

const (
	ThreadCommentSortID     ThreadCommentSort = "ID"
	ThreadCommentSortIDDesc ThreadCommentSort = "ID_DESC"
)

var AllThreadCommentSort = []ThreadCommentSort{
	ThreadCommentSortID,
	ThreadCommentSortIDDesc,
}

func (e ThreadCommentSort) IsValid() bool {
	switch e {
	case ThreadCommentSortID, ThreadCommentSortIDDesc:
		return true
	}
	return false
}

func (e ThreadCommentSort) String() string {
	return string(e)
}

func (e *ThreadCommentSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ThreadCommentSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ThreadCommentSort", str)
	}
	return nil
}

func (e ThreadCommentSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ThreadCommentSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ThreadCommentSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Thread sort enums
type ThreadSort string

const (
	ThreadSortID             ThreadSort = "ID"
	ThreadSortIDDesc         ThreadSort = "ID_DESC"
	ThreadSortTitle          ThreadSort = "TITLE"
	ThreadSortTitleDesc      ThreadSort = "TITLE_DESC"
	ThreadSortCreatedAt      ThreadSort = "CREATED_AT"
	ThreadSortCreatedAtDesc  ThreadSort = "CREATED_AT_DESC"
	ThreadSortUpdatedAt      ThreadSort = "UPDATED_AT"
	ThreadSortUpdatedAtDesc  ThreadSort = "UPDATED_AT_DESC"
	ThreadSortRepliedAt      ThreadSort = "REPLIED_AT"
	ThreadSortRepliedAtDesc  ThreadSort = "REPLIED_AT_DESC"
	ThreadSortReplyCount     ThreadSort = "REPLY_COUNT"
	ThreadSortReplyCountDesc ThreadSort = "REPLY_COUNT_DESC"
	ThreadSortViewCount      ThreadSort = "VIEW_COUNT"
	ThreadSortViewCountDesc  ThreadSort = "VIEW_COUNT_DESC"
	ThreadSortIsSticky       ThreadSort = "IS_STICKY"
	ThreadSortSearchMatch    ThreadSort = "SEARCH_MATCH"
)

var AllThreadSort = []ThreadSort{
	ThreadSortID,
	ThreadSortIDDesc,
	ThreadSortTitle,
	ThreadSortTitleDesc,
	ThreadSortCreatedAt,
	ThreadSortCreatedAtDesc,
	ThreadSortUpdatedAt,
	ThreadSortUpdatedAtDesc,
	ThreadSortRepliedAt,
	ThreadSortRepliedAtDesc,
	ThreadSortReplyCount,
	ThreadSortReplyCountDesc,
	ThreadSortViewCount,
	ThreadSortViewCountDesc,
	ThreadSortIsSticky,
	ThreadSortSearchMatch,
}

func (e ThreadSort) IsValid() bool {
	switch e {
	case ThreadSortID, ThreadSortIDDesc, ThreadSortTitle, ThreadSortTitleDesc, ThreadSortCreatedAt, ThreadSortCreatedAtDesc, ThreadSortUpdatedAt, ThreadSortUpdatedAtDesc, ThreadSortRepliedAt, ThreadSortRepliedAtDesc, ThreadSortReplyCount, ThreadSortReplyCountDesc, ThreadSortViewCount, ThreadSortViewCountDesc, ThreadSortIsSticky, ThreadSortSearchMatch:
		return true
	}
	return false
}

func (e ThreadSort) String() string {
	return string(e)
}

func (e *ThreadSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ThreadSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ThreadSort", str)
	}
	return nil
}

func (e ThreadSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ThreadSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ThreadSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// User sort enums
type UserSort string

const (
	UserSortID               UserSort = "ID"
	UserSortIDDesc           UserSort = "ID_DESC"
	UserSortUsername         UserSort = "USERNAME"
	UserSortUsernameDesc     UserSort = "USERNAME_DESC"
	UserSortWatchedTime      UserSort = "WATCHED_TIME"
	UserSortWatchedTimeDesc  UserSort = "WATCHED_TIME_DESC"
	UserSortChaptersRead     UserSort = "CHAPTERS_READ"
	UserSortChaptersReadDesc UserSort = "CHAPTERS_READ_DESC"
	UserSortSearchMatch      UserSort = "SEARCH_MATCH"
)

var AllUserSort = []UserSort{
	UserSortID,
	UserSortIDDesc,
	UserSortUsername,
	UserSortUsernameDesc,
	UserSortWatchedTime,
	UserSortWatchedTimeDesc,
	UserSortChaptersRead,
	UserSortChaptersReadDesc,
	UserSortSearchMatch,
}

func (e UserSort) IsValid() bool {
	switch e {
	case UserSortID, UserSortIDDesc, UserSortUsername, UserSortUsernameDesc, UserSortWatchedTime, UserSortWatchedTimeDesc, UserSortChaptersRead, UserSortChaptersReadDesc, UserSortSearchMatch:
		return true
	}
	return false
}

func (e UserSort) String() string {
	return string(e)
}

func (e *UserSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserSort", str)
	}
	return nil
}

func (e UserSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The language the user wants to see staff and character names in
type UserStaffNameLanguage string

const (
	// The romanization of the staff or character's native name, with western name ordering
	UserStaffNameLanguageRomajiWestern UserStaffNameLanguage = "ROMAJI_WESTERN"
	// The romanization of the staff or character's native name
	UserStaffNameLanguageRomaji UserStaffNameLanguage = "ROMAJI"
	// The staff or character's name in their native language
	UserStaffNameLanguageNative UserStaffNameLanguage = "NATIVE"
)

var AllUserStaffNameLanguage = []UserStaffNameLanguage{
	UserStaffNameLanguageRomajiWestern,
	UserStaffNameLanguageRomaji,
	UserStaffNameLanguageNative,
}

func (e UserStaffNameLanguage) IsValid() bool {
	switch e {
	case UserStaffNameLanguageRomajiWestern, UserStaffNameLanguageRomaji, UserStaffNameLanguageNative:
		return true
	}
	return false
}

func (e UserStaffNameLanguage) String() string {
	return string(e)
}

func (e *UserStaffNameLanguage) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserStaffNameLanguage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserStaffNameLanguage", str)
	}
	return nil
}

func (e UserStaffNameLanguage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserStaffNameLanguage) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserStaffNameLanguage) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// User statistics sort enum
type UserStatisticsSort string

const (
	UserStatisticsSortID            UserStatisticsSort = "ID"
	UserStatisticsSortIDDesc        UserStatisticsSort = "ID_DESC"
	UserStatisticsSortCount         UserStatisticsSort = "COUNT"
	UserStatisticsSortCountDesc     UserStatisticsSort = "COUNT_DESC"
	UserStatisticsSortProgress      UserStatisticsSort = "PROGRESS"
	UserStatisticsSortProgressDesc  UserStatisticsSort = "PROGRESS_DESC"
	UserStatisticsSortMeanScore     UserStatisticsSort = "MEAN_SCORE"
	UserStatisticsSortMeanScoreDesc UserStatisticsSort = "MEAN_SCORE_DESC"
)

var AllUserStatisticsSort = []UserStatisticsSort{
	UserStatisticsSortID,
	UserStatisticsSortIDDesc,
	UserStatisticsSortCount,
	UserStatisticsSortCountDesc,
	UserStatisticsSortProgress,
	UserStatisticsSortProgressDesc,
	UserStatisticsSortMeanScore,
	UserStatisticsSortMeanScoreDesc,
}

func (e UserStatisticsSort) IsValid() bool {
	switch e {
	case UserStatisticsSortID, UserStatisticsSortIDDesc, UserStatisticsSortCount, UserStatisticsSortCountDesc, UserStatisticsSortProgress, UserStatisticsSortProgressDesc, UserStatisticsSortMeanScore, UserStatisticsSortMeanScoreDesc:
		return true
	}
	return false
}

func (e UserStatisticsSort) String() string {
	return string(e)
}

func (e *UserStatisticsSort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserStatisticsSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserStatisticsSort", str)
	}
	return nil
}

func (e UserStatisticsSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserStatisticsSort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserStatisticsSort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// The language the user wants to see media titles in
type UserTitleLanguage string

const (
	// The romanization of the native language title
	UserTitleLanguageRomaji UserTitleLanguage = "ROMAJI"
	// The official english title
	UserTitleLanguageEnglish UserTitleLanguage = "ENGLISH"
	// Official title in it's native language
	UserTitleLanguageNative UserTitleLanguage = "NATIVE"
	// The romanization of the native language title, stylised by media creator
	UserTitleLanguageRomajiStylised UserTitleLanguage = "ROMAJI_STYLISED"
	// The official english title, stylised by media creator
	UserTitleLanguageEnglishStylised UserTitleLanguage = "ENGLISH_STYLISED"
	// Official title in it's native language, stylised by media creator
	UserTitleLanguageNativeStylised UserTitleLanguage = "NATIVE_STYLISED"
)

var AllUserTitleLanguage = []UserTitleLanguage{
	UserTitleLanguageRomaji,
	UserTitleLanguageEnglish,
	UserTitleLanguageNative,
	UserTitleLanguageRomajiStylised,
	UserTitleLanguageEnglishStylised,
	UserTitleLanguageNativeStylised,
}

func (e UserTitleLanguage) IsValid() bool {
	switch e {
	case UserTitleLanguageRomaji, UserTitleLanguageEnglish, UserTitleLanguageNative, UserTitleLanguageRomajiStylised, UserTitleLanguageEnglishStylised, UserTitleLanguageNativeStylised:
		return true
	}
	return false
}

func (e UserTitleLanguage) String() string {
	return string(e)
}

func (e *UserTitleLanguage) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserTitleLanguage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserTitleLanguage", str)
	}
	return nil
}

func (e UserTitleLanguage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserTitleLanguage) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserTitleLanguage) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
