// This file was generated by the Seanime API documentation generator.

export type ApiEndpoints = Record<string, Record<string, {
    key: string,
    methods: ("POST" | "GET" | "PATCH" | "PUT" | "DELETE")[],
    endpoint: string
}>>

export const API_ENDPOINTS = {
    ANILIST: {
        /**
         *  @description
         *  Route returns the user's AniList anime collection.
         *  Calling GET will return the cached anime collection.
         *  The manga collection is also refreshed in the background, and upon completion, a WebSocket event is sent.
         *  Calling POST will refetch both the anime and manga collections.
         */
        GetAnilistCollection: {
            key: "ANILIST-get-anilist-collection",
            methods: ["GET", "POST"],
            endpoint: "/api/v1/anilist/collection",
        },
        /**
         *  @description
         *  Route updates the user's list entry on Anilist.
         *  This is used to edit an entry on AniList.
         *  The "type" field is used to determine if the entry is an anime or manga and refreshes the collection accordingly.
         *  The client should refetch collection-dependent queries after this mutation.
         */
        EditAnilistListEntry: {
            key: "ANILIST-edit-anilist-list-entry",
            methods: ["POST"],
            endpoint: "/api/v1/anilist/list-entry",
        },
        /**
         *  @description
         *  Route returns more details about an AniList anime entry.
         *  This fetches more fields omitted from the base queries.
         */
        GetAnilistMediaDetails: {
            key: "ANILIST-get-anilist-media-details",
            methods: ["GET"],
            endpoint: "/api/v1/anilist/media-details/{id}",
        },
        /**
         *  @description
         *  Route deletes an entry from the user's AniList list.
         *  This is used to delete an entry on AniList.
         *  The "type" field is used to determine if the entry is an anime or manga and refreshes the collection accordingly.
         *  The client should refetch collection-dependent queries after this mutation.
         */
        DeleteAnilistListEntry: {
            key: "ANILIST-delete-anilist-list-entry",
            methods: ["DELETE"],
            endpoint: "/api/v1/anilist/list-entry",
        },
        /**
         *  @description
         *  Route returns a list of anime based on the search parameters.
         *  This is used by the "Discover" and "Advanced Search".
         */
        AnilistListAnime: {
            key: "ANILIST-anilist-list-anime",
            methods: ["POST"],
            endpoint: "/api/v1/anilist/list-anime",
        },
        /**
         *  @description
         *  Route returns a list of recently aired anime.
         *  This is used by the "Schedule" page to display recently aired anime.
         */
        AnilistListRecentAiringAnime: {
            key: "ANILIST-anilist-list-recent-airing-anime",
            methods: ["POST"],
            endpoint: "/api/v1/anilist/list-recent-anime",
        },
    },
    ANIME_COLLECTION: {
        /**
         *  @description
         *  Route returns the main local anime collection.
         *  This creates a new LibraryCollection struct and returns it.
         *  This is used to get the main anime collection of the user.
         *  It uses the cached Anilist anime collection for the GET method.
         *  It refreshes the AniList anime collection if the POST method is used.
         */
        GetLibraryCollection: {
            key: "ANIME-COLLECTION-get-library-collection",
            methods: ["GET", "POST"],
            endpoint: "/api/v1/library/collection",
        },
        /**
         *  @description
         *  Route adds the given media to the user's AniList planning collections
         *  Since media not found in the user's AniList collection are not displayed in the library, this route is used to add them.
         *  The response is ignored in the frontend, the client should just refetch the entire library collection.
         */
        AddUnknownMedia: {
            key: "ANIME-COLLECTION-add-unknown-media",
            methods: ["POST"],
            endpoint: "/api/v1/library/unknown-media",
        },
    },
    ANIME_ENTRIES: {
        /**
         *  @description
         *  Route return a media entry for the given AniList anime media id.
         *  This is used by the anime media entry pages to get all the data about the anime.
         *  This includes episodes and metadata (if any), AniList list data, download info...
         */
        GetAnimeEntry: {
            key: "ANIME-ENTRIES-get-anime-entry",
            methods: ["GET"],
            endpoint: "/api/v1/library/anime-entry/{id}",
        },
        /**
         *  @description
         *  Route perform given action on all the local files for the given media id.
         *  This is used to unmatch or toggle the lock status of all the local files for a specific media entry
         *  The response is not used in the frontend. The client should just refetch the entire media entry data.
         */
        AnimeEntryBulkAction: {
            key: "ANIME-ENTRIES-anime-entry-bulk-action",
            methods: ["PATCH"],
            endpoint: "/api/v1/library/anime-entry/bulk-action",
        },
        /**
         *  @description
         *  Route opens the directory of a media entry in the file explorer.
         *  This finds a common directory for all media entry local files and opens it in the file explorer.
         *  Returns 'true' whether the operation was successful or not, errors are ignored.
         */
        OpenAnimeEntryInExplorer: {
            key: "ANIME-ENTRIES-open-anime-entry-in-explorer",
            methods: ["POST"],
            endpoint: "/api/v1/library/anime-entry/open-in-explorer",
        },
        /**
         *  @description
         *  Route returns a list of media suggestions for files in the given directory.
         *  This is used by the "Resolve unmatched media" feature to suggest media entries for the local files in the given directory.
         *  If some matches files are found in the directory, it will ignore them and base the suggestions on the remaining files.
         */
        FetchAnimeEntrySuggestions: {
            key: "ANIME-ENTRIES-fetch-anime-entry-suggestions",
            methods: ["POST"],
            endpoint: "/api/v1/library/anime-entry/suggestions",
        },
        /**
         *  @description
         *  Route matches un-matched local files in the given directory to the given media.
         *  It is used by the "Resolve unmatched media" feature to manually match local files to a specific media entry.
         *  Matching involves the use of scanner.FileHydrator. It will also lock the files.
         *  The response is not used in the frontend. The client should just refetch the entire library collection.
         */
        AnimeEntryManualMatch: {
            key: "ANIME-ENTRIES-anime-entry-manual-match",
            methods: ["POST"],
            endpoint: "/api/v1/library/anime-entry/manual-match",
        },
        /**
         *  @description
         *  Route returns a list of episodes missing from the user's library collection
         *  It detects missing episodes by comparing the user's AniList collection 'next airing' data with the local files.
         *  This route can be called multiple times, as it does not bypass the cache.
         */
        GetMissingEpisodes: {
            key: "ANIME-ENTRIES-get-missing-episodes",
            methods: ["GET"],
            endpoint: "/api/v1/library/missing-episodes",
        },
        GetAnimeEntrySilenceStatus: {
            key: "ANIME-ENTRIES-get-anime-entry-silence-status",
            methods: ["GET"],
            endpoint: "/api/v1/library/anime-entry/silence/{id}",
        },
        /**
         *  @description
         *  Route toggles the silence status of a media entry.
         *  The missing episodes should be re-fetched after this.
         */
        ToggleAnimeEntrySilenceStatus: {
            key: "ANIME-ENTRIES-toggle-anime-entry-silence-status",
            methods: ["POST"],
            endpoint: "/api/v1/library/anime-entry/silence",
        },
        /**
         *  @description
         *  Route update the progress of the given anime media entry.
         *  This is used to update the progress of the given anime media entry on AniList and MyAnimeList (if an account is linked).
         *  The response is not used in the frontend, the client should just refetch the entire media entry data.
         *  NOTE: This is currently only used by the 'Online streaming' feature since anime progress updates are handled by the Playback Manager.
         */
        UpdateAnimeEntryProgress: {
            key: "ANIME-ENTRIES-update-anime-entry-progress",
            methods: ["POST"],
            endpoint: "/api/v1/library/anime-entry/update-progress",
        },
    },
    AUTH: {
        /**
         *  @description
         *  Route logs in the user by saving the JWT token in the database.
         *  This is called when the JWT token is obtained from AniList after logging in with redirection on the client.
         *  It also fetches the Viewer data from AniList and saves it in the database.
         *  It creates a new handlers.Status and refreshes App modules.
         */
        Login: {
            key: "AUTH-login",
            methods: ["POST"],
            endpoint: "/api/v1/auth/login",
        },
        /**
         *  @description
         *  Route logs out the user by removing JWT token from the database.
         *  It removes JWT token and Viewer data from the database.
         *  It creates a new handlers.Status and refreshes App modules.
         */
        Logout: {
            key: "AUTH-logout",
            methods: ["POST"],
            endpoint: "/api/v1/auth/logout",
        },
    },
    AUTO_DOWNLOADER: {
        /**
         *  @description
         *  Route tells the AutoDownloader to check for new episodes if enabled.
         *  This will run the AutoDownloader if it is enabled.
         *  It does nothing if the AutoDownloader is disabled.
         */
        RunAutoDownloader: {
            key: "AUTO-DOWNLOADER-run-auto-downloader",
            methods: ["POST"],
            endpoint: "/api/v1/auto-downloader/run",
        },
        /**
         *  @description
         *  Route returns the rule with the given DB id.
         *  This is used to get a specific rule, useful for editing.
         */
        GetAutoDownloaderRule: {
            key: "AUTO-DOWNLOADER-get-auto-downloader-rule",
            methods: ["GET"],
            endpoint: "/api/v1/auto-downloader/rule/{id}",
        },
        /**
         *  @description
         *  Route returns all rules.
         *  This is used to list all rules. It returns an empty slice if there are no rules.
         */
        GetAutoDownloaderRules: {
            key: "AUTO-DOWNLOADER-get-auto-downloader-rules",
            methods: ["GET"],
            endpoint: "/api/v1/auto-downloader/rules",
        },
        /**
         *  @description
         *  Route creates a new rule.
         *  The body should contain the same fields as entities.AutoDownloaderRule.
         *  It returns the created rule.
         */
        CreateAutoDownloaderRule: {
            key: "AUTO-DOWNLOADER-create-auto-downloader-rule",
            methods: ["POST"],
            endpoint: "/api/v1/auto-downloader/rule",
        },
        /**
         *  @description
         *  Route updates a rule.
         *  The body should contain the same fields as entities.AutoDownloaderRule.
         *  It returns the updated rule.
         */
        UpdateAutoDownloaderRule: {
            key: "AUTO-DOWNLOADER-update-auto-downloader-rule",
            methods: ["PATCH"],
            endpoint: "/api/v1/auto-downloader/rule",
        },
        /**
         *  @description
         *  Route deletes a rule.
         *  It returns 'true' if the rule was deleted.
         */
        DeleteAutoDownloaderRule: {
            key: "AUTO-DOWNLOADER-delete-auto-downloader-rule",
            methods: ["DELETE"],
            endpoint: "/api/v1/auto-downloader/rule/{id}",
        },
        /**
         *  @description
         *  Route returns all queued items.
         *  Queued items are episodes that are downloaded but not scanned or not yet downloaded.
         *  The AutoDownloader uses these items in order to not download the same episode twice.
         */
        GetAutoDownloaderItems: {
            key: "AUTO-DOWNLOADER-get-auto-downloader-items",
            methods: ["GET"],
            endpoint: "/api/v1/auto-downloader/items",
        },
        /**
         *  @description
         *  Route delete a queued item.
         *  This is used to remove a queued item from the list.
         *  Returns 'true' if the item was deleted.
         */
        DeleteAutoDownloaderItem: {
            key: "AUTO-DOWNLOADER-delete-auto-downloader-item",
            methods: ["DELETE"],
            endpoint: "/api/v1/auto-downloader/item",
        },
    },
    DIRECTORY_SELECTOR: {
        /**
         *  @description
         *  Route returns directory content based on the input path.
         *  This used by the directory selector component to get directory validation and suggestions.
         *  It returns subdirectories based on the input path.
         *  It returns 500 error if the directory does not exist (or cannot be accessed).
         */
        DirectorySelector: {
            key: "DIRECTORY-SELECTOR-directory-selector",
            methods: ["POST"],
            endpoint: "/api/v1/directory-selector",
        },
    },
    DISCORD: {
        SetDiscordMangaActivity: {
            key: "DISCORD-set-discord-manga-activity",
            methods: ["POST"],
            endpoint: "/api/v1/discord/presence/manga",
        },
        CancelDiscordActivity: {
            key: "DISCORD-cancel-discord-activity",
            methods: ["POST"],
            endpoint: "/api/v1/discord/presence/cancel",
        },
    },
    DOCS: {
        GetDocs: {
            key: "DOCS-get-docs",
            methods: ["GET"],
            endpoint: "/api/v1/internal/docs",
        },
    },
    DOWNLOAD: {
        DownloadTorrentFile: {
            key: "DOWNLOAD-download-torrent-file",
            methods: ["POST"],
            endpoint: "/api/v1/download-torrent-file",
        },
        /**
         *  @description
         *  Route downloads selected release asset to the destination folder.
         *  Downloads the selected release asset to the destination folder and extracts it if possible.
         *  If the extraction fails, the error message will be returned in the successful response.
         *  The successful response will contain the destination path of the extracted files.
         *  It only returns an error if the download fails.
         */
        DownloadRelease: {
            key: "DOWNLOAD-download-release",
            methods: ["POST"],
            endpoint: "/api/v1/download-release",
        },
    },
    EXPLORER: {
        /**
         *  @description
         *  Route opens the given directory in the file explorer.
         *  It returns 'true' whether the operation was successful or not.
         */
        OpenInExplorer: {
            key: "EXPLORER-open-in-explorer",
            methods: ["POST"],
            endpoint: "/api/v1/open-in-explorer",
        },
    },
    FILECACHE: {
        /**
         *  @description
         *  Route returns the total size of cache files.
         *  The total size of the cache files is returned in human-readable format.
         */
        GetFileCacheTotalSize: {
            key: "FILECACHE-get-file-cache-total-size",
            methods: ["GET"],
            endpoint: "/api/v1/filecache/total-size",
        },
        /**
         *  @description
         *  Route deletes all buckets with the given prefix.
         *  The bucket value is the prefix of the cache files that should be deleted.
         *  Returns 'true' if the operation was successful.
         */
        RemoveFileCacheBucket: {
            key: "FILECACHE-remove-file-cache-bucket",
            methods: ["DELETE"],
            endpoint: "/api/v1/filecache/bucket",
        },
    },
    LIST_SYNC: {
        /**
         *  @description
         *  Route deletes the list sync cache.
         *  This will delete the list sync cache and allows the client to fetch an up-to-date list sync instance in the next request.
         */
        DeleteListSyncCache: {
            key: "LIST-SYNC-delete-list-sync-cache",
            methods: ["POST"],
            endpoint: "/api/v1/list-sync/cache",
        },
        /**
         *  @description
         *  Route returns the anime diffs from the list sync instance.
         *  If the instance is not cached, it will generate a new listsync.ListSync and cache them for 10 minutes
         */
        GetListSyncAnimeDiffs: {
            key: "LIST-SYNC-get-list-sync-anime-diffs",
            methods: ["GET"],
            endpoint: "/api/v1/list-sync/anime-diffs",
        },
        SyncAnime: {
            key: "LIST-SYNC-sync-anime",
            methods: ["POST"],
            endpoint: "/api/v1/list-sync/anime",
        },
    },
    LOCALFILES: {
        /**
         *  @description
         *  Route returns all local files.
         *  Reminder that local files are scanned from the library path.
         */
        GetLocalFiles: {
            key: "LOCALFILES-get-local-files",
            methods: ["GET"],
            endpoint: "/api/v1/library/local-files",
        },
        /**
         *  @description
         *  Route performs an action on all local files.
         *  This will perform the given action on all local files.
         *  The response is ignored, the client should refetch the entire library collection and media entry.
         */
        LocalFileBulkAction: {
            key: "LOCALFILES-local-file-bulk-action",
            methods: ["POST"],
            endpoint: "/api/v1/library/local-files",
        },
        /**
         *  @description
         *  Route updates the local file with the given path.
         *  This will update the local file with the given path.
         *  The response is ignored, the client should refetch the entire library collection and media entry.
         */
        UpdateLocalFileData: {
            key: "LOCALFILES-update-local-file-data",
            methods: ["PATCH"],
            endpoint: "/api/v1/library/local-file",
        },
        /**
         *  @description
         *  Route deletes the local file with the given paths.
         *  The response is ignored, the client should refetch the entire library collection and media entry.
         */
        DeleteLocalFiles: {
            key: "LOCALFILES-delete-local-files",
            methods: ["DELETE"],
            endpoint: "/api/v1/library/local-files",
        },
        RemoveEmptyDirectories: {
            key: "LOCALFILES-remove-empty-directories",
            methods: ["DELETE"],
            endpoint: "/api/v1/library/empty-directories",
        },
    },
    MAL: {
        /**
         *  @description
         *  Route fetches the access and refresh tokens for the given code.
         *  This is used to authenticate the user with MyAnimeList.
         *  It will save the info in the database, effectively logging the user in.
         *  The client should re-fetch the server status after this.
         */
        MALAuth: {
            key: "MAL-mal-auth",
            methods: ["POST"],
            endpoint: "/api/v1/mal/auth",
        },
        EditMALListEntryProgress: {
            key: "MAL-edit-mal-list-entry-progress",
            methods: ["POST"],
            endpoint: "/api/v1/mal/list-entry/progress",
        },
        /**
         *  @description
         *  Route logs the user out of MyAnimeList.
         *  This will delete the MAL info from the database, effectively logging the user out.
         *  The client should re-fetch the server status after this.
         */
        MALLogout: {
            key: "MAL-mal-logout",
            methods: ["POST"],
            endpoint: "/api/v1/mal/logout",
        },
    },
    MANGA: {
        GetAnilistMangaCollection: {
            key: "MANGA-get-anilist-manga-collection",
            methods: ["GET"],
            endpoint: "/api/v1/manga/anilist/collection",
        },
        /**
         *  @description
         *  Route returns the user's main manga collection.
         *  This is an object that contains all the user's manga entries in a structured format.
         */
        GetMangaCollection: {
            key: "MANGA-get-manga-collection",
            methods: ["GET"],
            endpoint: "/api/v1/manga/collection",
        },
        /**
         *  @description
         *  Route returns a manga entry for the given AniList manga id.
         *  This is used by the manga media entry pages to get all the data about the anime. It includes metadata and AniList list data.
         */
        GetMangaEntry: {
            key: "MANGA-get-manga-entry",
            methods: ["GET"],
            endpoint: "/api/v1/manga/entry/{id}",
        },
        /**
         *  @description
         *  Route returns more details about an AniList manga entry.
         *  This fetches more fields omitted from the base queries.
         */
        GetMangaEntryDetails: {
            key: "MANGA-get-manga-entry-details",
            methods: ["GET"],
            endpoint: "/api/v1/manga/entry/{id}/details",
        },
        /**
         *  @description
         *  Route empties the cache for a manga entry.
         *  This will empty the cache for a manga entry (chapter lists and pages), allowing the client to fetch fresh data.
         *  HandleGetMangaEntryChapters should be called after this to fetch the new chapter list.
         *  Returns 'true' if the operation was successful.
         */
        EmptyMangaEntryCache: {
            key: "MANGA-empty-manga-entry-cache",
            methods: ["DELETE"],
            endpoint: "/api/v1/manga/entry/cache",
        },
        GetMangaEntryChapters: {
            key: "MANGA-get-manga-entry-chapters",
            methods: ["POST"],
            endpoint: "/api/v1/manga/chapters",
        },
        /**
         *  @description
         *  Route returns the pages for a manga entry based on the provider and chapter id.
         *  This will return the pages for a manga chapter.
         *  If the app is offline and the chapter is not downloaded, it will return an error.
         *  If the app is online and the chapter is not downloaded, it will return the pages from the provider.
         *  If the chapter is downloaded, it will return the appropriate struct.
         *  If 'double page' is requested, it will fetch image sizes and include the dimensions in the response.
         */
        GetMangaEntryPages: {
            key: "MANGA-get-manga-entry-pages",
            methods: ["POST"],
            endpoint: "/api/v1/manga/pages",
        },
        /**
         *  @description
         *  Route returns a list of manga based on the search parameters.
         *  This is used by "Advanced Search" and search function.
         */
        AnilistListManga: {
            key: "MANGA-anilist-list-manga",
            methods: ["POST"],
            endpoint: "/api/v1/manga/anilist/list",
        },
        /**
         *  @description
         *  Route updates the progress of a manga entry.
         *  Note: MyAnimeList is not supported
         */
        UpdateMangaProgress: {
            key: "MANGA-update-manga-progress",
            methods: ["POST"],
            endpoint: "/api/v1/manga/update-progress",
        },
    },
    MANGA_DOWNLOAD: {
        DownloadMangaChapters: {
            key: "MANGA-DOWNLOAD-download-manga-chapters",
            methods: ["POST"],
            endpoint: "/api/v1/manga/download-chapters",
        },
        /**
         *  @description
         *  Route returns the download data for a specific media.
         *  This is used to display information about the downloaded and queued chapters in the UI.
         *  If the 'cached' parameter is false, it will refresh the data by rescanning the download folder.
         */
        GetMangaDownloadData: {
            key: "MANGA-DOWNLOAD-get-manga-download-data",
            methods: ["POST"],
            endpoint: "/api/v1/manga/download-data",
        },
        GetMangaDownloadQueue: {
            key: "MANGA-DOWNLOAD-get-manga-download-queue",
            methods: ["GET"],
            endpoint: "/api/v1/manga/download-queue",
        },
        /**
         *  @description
         *  Route starts the download queue if it's not already running.
         *  This will start the download queue if it's not already running.
         *  Returns 'true' whether the queue was started or not.
         */
        StartMangaDownloadQueue: {
            key: "MANGA-DOWNLOAD-start-manga-download-queue",
            methods: ["POST"],
            endpoint: "/api/v1/manga/download-queue/start",
        },
        /**
         *  @description
         *  Route stops the manga download queue.
         *  This will stop the manga download queue.
         *  Returns 'true' whether the queue was stopped or not.
         */
        StopMangaDownloadQueue: {
            key: "MANGA-DOWNLOAD-stop-manga-download-queue",
            methods: ["POST"],
            endpoint: "/api/v1/manga/download-queue/stop",
        },
        /**
         *  @description
         *  Route clears all chapters from the download queue.
         *  This will clear all chapters from the download queue.
         *  Returns 'true' whether the queue was cleared or not.
         *  This will also send a websocket event telling the client to refetch the download queue.
         */
        ClearAllChapterDownloadQueue: {
            key: "MANGA-DOWNLOAD-clear-all-chapter-download-queue",
            methods: ["DELETE"],
            endpoint: "/api/v1/manga/download-queue",
        },
        /**
         *  @description
         *  Route resets the errored chapters in the download queue.
         *  This will reset the errored chapters in the download queue, so they can be re-downloaded.
         *  Returns 'true' whether the queue was reset or not.
         *  This will also send a websocket event telling the client to refetch the download queue.
         */
        ResetErroredChapterDownloadQueue: {
            key: "MANGA-DOWNLOAD-reset-errored-chapter-download-queue",
            methods: ["POST"],
            endpoint: "/api/v1/manga/download-queue/reset-errored",
        },
        /**
         *  @description
         *  Route deletes downloaded chapters.
         *  This will delete downloaded chapters from the filesystem.
         *  Returns 'true' whether the chapters were deleted or not.
         *  The client should refetch the download data after this.
         */
        DeleteMangaDownloadedChapters: {
            key: "MANGA-DOWNLOAD-delete-manga-downloaded-chapters",
            methods: ["DELETE"],
            endpoint: "/api/v1/manga/download-chapter",
        },
        /**
         *  @description
         *  Route displays the list of downloaded manga.
         *  This analyzes the download folder and returns a well-formatted structure for displaying downloaded manga.
         *  It returns a list of manga.DownloadListItem where the media data might be nil if it's not in the AniList collection.
         */
        GetMangaDownloadsList: {
            key: "MANGA-DOWNLOAD-get-manga-downloads-list",
            methods: ["GET"],
            endpoint: "/api/v1/manga/downloads",
        },
    },
    MANUAL_DUMP: {
        TestDump: {
            key: "MANUAL-DUMP-test-dump",
            methods: ["POST"],
            endpoint: "/api/v1/test-dump",
        },
    },
    MEDIAPLAYER: {
        StartDefaultMediaPlayer: {
            key: "MEDIAPLAYER-start-default-media-player",
            methods: ["POST"],
            endpoint: "/api/v1/media-player/start",
        },
    },
    METADATA: {
        /**
         *  @description
         *  Route populate cache with TVDB episode metadata.
         *  This will populate the cache with TVDB episode metadata for the given media.
         */
        PopulateTVDBEpisodes: {
            key: "METADATA-populate-tvdb-episodes",
            methods: ["POST"],
            endpoint: "/api/v1/metadata-provider/tvdb-episodes",
        },
        /**
         *  @description
         *  Route empties TVDB episode metadata cache.
         *  This will empty the TVDB episode metadata cache for the given media.
         */
        EmptyTVDBEpisodes: {
            key: "METADATA-empty-tvdb-episodes",
            methods: ["DELETE"],
            endpoint: "/api/v1/metadata-provider/tvdb-episodes",
        },
    },
    OFFLINE: {
        /**
         *  @description
         *  Route creates an offline snapshot.
         *  This will create an offline snapshot of the given anime media ids and downloaded manga chapters.
         *  It sends a websocket event when the snapshot is created, telling the client to refetch the offline snapshot.
         *  This is a non-blocking operation.
         */
        CreateOfflineSnapshot: {
            key: "OFFLINE-create-offline-snapshot",
            methods: ["POST"],
            endpoint: "/api/v1/offline/snapshot",
        },
        /**
         *  @description
         *  Route retrieves the offline snapshot.
         *  This will return the latest offline snapshot. (Offline only)
         */
        GetOfflineSnapshot: {
            key: "OFFLINE-get-offline-snapshot",
            methods: ["GET"],
            endpoint: "/api/v1/offline/snapshot",
        },
        /**
         *  @description
         *  Route retrieves an offline snapshot entry.
         *  This will return the latest offline snapshot entry so the client can display the data.
         */
        GetOfflineSnapshotEntry: {
            key: "OFFLINE-get-offline-snapshot-entry",
            methods: ["GET"],
            endpoint: "/api/v1/offline/snapshot-entry",
        },
        /**
         *  @description
         *  Route updates data for an offline entry list.
         *  This will update the offline entry list data. (Offline only)
         */
        UpdateOfflineEntryListData: {
            key: "OFFLINE-update-offline-entry-list-data",
            methods: ["PATCH"],
            endpoint: "/api/v1/offline/snapshot-entry",
        },
        SyncOfflineData: {
            key: "OFFLINE-sync-offline-data",
            methods: ["POST"],
            endpoint: "/api/v1/offline/sync",
        },
    },
    ONLINESTREAM: {
        /**
         *  @description
         *  Route returns the episode list for the given media and provider.
         *  It returns the episode list for the given media and provider.
         *  The episodes are cached using a file cache.
         *  The episode list is just a list of episodes with no video sources, it's what the client uses to display the episodes and subsequently
         *     fetch the sources. The episode list might be nil or empty if nothing could be found, but the media will always be returned.
         */
        GetOnlineStreamEpisodeList: {
            key: "ONLINESTREAM-get-online-stream-episode-list",
            methods: ["POST"],
            endpoint: "/api/v1/onlinestream/episode-list",
        },
        GetOnlineStreamEpisodeSource: {
            key: "ONLINESTREAM-get-online-stream-episode-source",
            methods: ["POST"],
            endpoint: "/api/v1/onlinestream/episode-source",
        },
        OnlineStreamEmptyCache: {
            key: "ONLINESTREAM-online-stream-empty-cache",
            methods: ["DELETE"],
            endpoint: "/api/v1/onlinestream/cache",
        },
    },
    PLAYBACK_MANAGER: {
        /**
         *  @description
         *  Route plays the video with the given path using the default media player.
         *  This tells the Playback Manager to play the video using the default media player and start tracking progress.
         *  This returns 'true' if the video was successfully played.
         */
        PlaybackPlayVideo: {
            key: "PLAYBACK-MANAGER-playback-play-video",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/play",
        },
        /**
         *  @description
         *  Route plays a random, unwatched video using the default media player.
         *  This tells the Playback Manager to play a random, unwatched video using the media player and start tracking progress.
         *  It respects the user's progress data and will prioritize "current" and "repeating" media if they are many of them.
         *  This returns 'true' if the video was successfully played.
         */
        PlaybackPlayRandomVideo: {
            key: "PLAYBACK-MANAGER-playback-play-random-video",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/play-random",
        },
        /**
         *  @description
         *  Route updates the AniList progress of the currently playing media.
         *  This is called after 'Update progress' is clicked when watching a media.
         *  This route returns the media ID of the currently playing media, so the client can refetch the media entry data.
         */
        PlaybackSyncCurrentProgress: {
            key: "PLAYBACK-MANAGER-playback-sync-current-progress",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/sync-current-progress",
        },
        /**
         *  @description
         *  Route plays the next episode of the currently playing media.
         *  This will play the next episode of the currently playing media.
         *  This is non-blocking so the client should prevent multiple calls until the next status is received.
         */
        PlaybackPlayNextEpisode: {
            key: "PLAYBACK-MANAGER-playback-play-next-episode",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/next-episode",
        },
        /**
         *  @description
         *  Route starts playing a playlist.
         *  The client should refetch playlists.
         */
        PlaybackStartPlaylist: {
            key: "PLAYBACK-MANAGER-playback-start-playlist",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/start-playlist",
        },
        /**
         *  @description
         *  Route ends the current playlist.
         *  This will stop the current playlist. This is non-blocking.
         */
        PlaybackCancelCurrentPlaylist: {
            key: "PLAYBACK-MANAGER-playback-cancel-current-playlist",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/cancel-playlist",
        },
        /**
         *  @description
         *  Route moves to the next item in the current playlist.
         *  This is non-blocking so the client should prevent multiple calls until the next status is received.
         */
        PlaybackPlaylistNext: {
            key: "PLAYBACK-MANAGER-playback-playlist-next",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/playlist-next",
        },
    },
    PLAYLIST: {
        /**
         *  @description
         *  Route creates a new playlist.
         *  This will create a new playlist with the given name and local file paths.
         *  The response is ignored, the client should re-fetch the playlists after this.
         */
        CreatePlaylist: {
            key: "PLAYLIST-create-playlist",
            methods: ["POST"],
            endpoint: "/api/v1/playlist",
        },
        GetPlaylists: {
            key: "PLAYLIST-get-playlists",
            methods: ["GET"],
            endpoint: "/api/v1/playlists",
        },
        /**
         *  @description
         *  Route updates a playlist.
         *  The response is ignored, the client should re-fetch the playlists after this.
         */
        UpdatePlaylist: {
            key: "PLAYLIST-update-playlist",
            methods: ["PATCH"],
            endpoint: "/api/v1/playlist",
        },
        DeletePlaylist: {
            key: "PLAYLIST-delete-playlist",
            methods: ["DELETE"],
            endpoint: "/api/v1/playlist",
        },
        GetPlaylistEpisodes: {
            key: "PLAYLIST-get-playlist-episodes",
            methods: ["GET"],
            endpoint: "/api/v1/playlist/episodes/{id}/{progress}",
        },
    },
    RELEASES: {
        /**
         *  @description
         *  Route returns the latest update.
         *  This will return the latest update.
         *  If an error occurs, it will return an empty update.
         */
        GetLatestUpdate: {
            key: "RELEASES-get-latest-update",
            methods: ["GET"],
            endpoint: "/api/v1/latest-update",
        },
    },
    SCAN: {
        /**
         *  @description
         *  Route scans the user's library.
         *  This will scan the user's library.
         *  The response is ignored, the client should re-fetch the library after this.
         */
        ScanLocalFiles: {
            key: "SCAN-scan-local-files",
            methods: ["POST"],
            endpoint: "/api/v1/library/scan",
        },
    },
    SCAN_SUMMARY: {
        GetScanSummaries: {
            key: "SCAN-SUMMARY-get-scan-summaries",
            methods: ["GET"],
            endpoint: "/api/v1/library/scan-summaries",
        },
    },
    SETTINGS: {
        GetSettings: {
            key: "SETTINGS-get-settings",
            methods: ["GET"],
            endpoint: "/api/v1/settings",
        },
        /**
         *  @description
         *  Route updates the app settings.
         *  This will update the app settings.
         *  The client should re-fetch the server status after this.
         */
        SaveSettings: {
            key: "SETTINGS-save-settings",
            methods: ["PATCH"],
            endpoint: "/api/v1/settings",
        },
        /**
         *  @description
         *  Route updates the list sync settings
         *  This will update the ListSync settings and clear the ListSync cache.
         */
        SaveListSyncSettings: {
            key: "SETTINGS-save-list-sync-settings",
            methods: ["PATCH"],
            endpoint: "/api/v1/settings/list-sync",
        },
        SaveAutoDownloaderSettings: {
            key: "SETTINGS-save-auto-downloader-settings",
            methods: ["PATCH"],
            endpoint: "/api/v1/settings/auto-downloader",
        },
    },
    STATUS: {
        /**
         *  @description
         *  Route returns the server status.
         *  The server status includes app info, auth info and settings.
         *  The client uses this to set the UI.
         *  It is called on every page load to get the most up-to-date data.
         *  It should be called right after updating the settings.
         */
        GetStatus: {
            key: "STATUS-get-status",
            methods: ["GET"],
            endpoint: "/api/v1/status",
        },
    },
    THEME: {
        GetTheme: {
            key: "THEME-get-theme",
            methods: ["GET"],
            endpoint: "/api/v1/theme",
        },
        /**
         *  @description
         *  Route updates the theme settings.
         *  The server status should be re-fetched after this on the client.
         */
        UpdateTheme: {
            key: "THEME-update-theme",
            methods: ["PATCH"],
            endpoint: "/api/v1/theme",
        },
    },
    TORRENT_CLIENT: {
        /**
         *  @description
         *  Route returns all active torrents.
         *  This handler is used by the client to display the active torrents.
         */
        GetActiveTorrentList: {
            key: "TORRENT-CLIENT-get-active-torrent-list",
            methods: ["GET"],
            endpoint: "/api/v1/torrent-client/list",
        },
        /**
         *  @description
         *  Route performs an action on a torrent.
         *  This handler is used to pause, resume or remove a torrent.
         */
        TorrentClientAction: {
            key: "TORRENT-CLIENT-torrent-client-action",
            methods: ["POST"],
            endpoint: "/api/v1/torrent-client/action",
        },
        /**
         *  @description
         *  Route adds torrents to the torrent client.
         *  It fetches the magnets from the provided URLs and adds them to the torrent client.
         *  If smart select is enabled, it will try to select the best torrent based on the missing episodes.
         */
        TorrentClientDownload: {
            key: "TORRENT-CLIENT-torrent-client-download",
            methods: ["POST"],
            endpoint: "/api/v1/torrent-client/download",
        },
        /**
         *  @description
         *  Route adds magnets to the torrent client based on the AutoDownloader item.
         *  This is used to download torrents that were queued by the AutoDownloader.
         *  The item will be removed from the queue if the magnet was added successfully.
         *  The AutoDownloader items should be re-fetched after this.
         */
        TorrentClientAddMagnetFromRule: {
            key: "TORRENT-CLIENT-torrent-client-add-magnet-from-rule",
            methods: ["POST"],
            endpoint: "/api/v1/torrent-client/rule-magnet",
        },
    },
    TORRENT_SEARCH: {
        /**
         *  @description
         *  Route searches torrents and returns a list of torrents and their previews.
         *  This will search for torrents and return a list of torrents with previews.
         *  If smart search is enabled, it will filter the torrents based on search parameters.
         */
        SearchTorrent: {
            key: "TORRENT-SEARCH-search-torrent",
            methods: ["POST"],
            endpoint: "/api/v1/torrent/search",
        },
        /**
         *  @description
         *  Route searches NSFW torrents and returns a list of torrents without previews.
         *  This will search for NSFW torrents and return a list of torrents without previews.
         */
        SearchNsfwTorrent: {
            key: "TORRENT-SEARCH-search-nsfw-torrent",
            methods: ["POST"],
            endpoint: "/api/v1/torrent/nsfw-search",
        },
    },
} satisfies ApiEndpoints

