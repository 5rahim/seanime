// This code was generated by codegen/main.go. DO NOT EDIT.

export type ApiEndpoints = Record<string, Record<string, {
     key: string,
     methods: ("POST" | "GET" | "PATCH" | "PUT" | "DELETE")[],
     endpoint: string
}>>

export const API_ENDPOINTS = {
    ANILIST: {
        /**
         *  @description
         *  Route returns the user's AniList anime collection.
         *  Calling GET will return the cached anime collection.
         *  The manga collection is also refreshed in the background, and upon completion, a WebSocket event is sent.
         *  Calling POST will refetch both the anime and manga collections.
         */
        GetAnimeCollection: {
            key: "ANILIST-get-anime-collection",
            methods: ["GET", "POST"],
            endpoint: "/api/v1/anilist/collection",
        },
        /**
         *  @description
         *  Route returns the user's AniList anime collection without filtering out custom lists.
         *  Calling GET will return the cached anime collection.
         */
        GetRawAnimeCollection: {
            key: "ANILIST-get-raw-anime-collection",
            methods: ["GET", "POST"],
            endpoint: "/api/v1/anilist/collection/raw",
        },
        /**
         *  @description
         *  Route updates the user's list entry on Anilist.
         *  This is used to edit an entry on AniList.
         *  The "type" field is used to determine if the entry is an anime or manga and refreshes the collection accordingly.
         *  The client should refetch collection-dependent queries after this mutation.
         */
        EditAnilistListEntry: {
            key: "ANILIST-edit-anilist-list-entry",
            methods: ["POST"],
            endpoint: "/api/v1/anilist/list-entry",
        },
        /**
         *  @description
         *  Route returns more details about an AniList anime entry.
         *  This fetches more fields omitted from the base queries.
         */
        GetAnilistAnimeDetails: {
            key: "ANILIST-get-anilist-anime-details",
            methods: ["GET"],
            endpoint: "/api/v1/anilist/media-details/{id}",
        },
        /**
         *  @description
         *  Route returns details about a studio.
         *  This fetches media produced by the studio.
         */
        GetAnilistStudioDetails: {
            key: "ANILIST-get-anilist-studio-details",
            methods: ["GET"],
            endpoint: "/api/v1/anilist/studio-details/{id}",
        },
        /**
         *  @description
         *  Route deletes an entry from the user's AniList list.
         *  This is used to delete an entry on AniList.
         *  The "type" field is used to determine if the entry is an anime or manga and refreshes the collection accordingly.
         *  The client should refetch collection-dependent queries after this mutation.
         */
        DeleteAnilistListEntry: {
            key: "ANILIST-delete-anilist-list-entry",
            methods: ["DELETE"],
            endpoint: "/api/v1/anilist/list-entry",
        },
        /**
         *  @description
         *  Route returns a list of anime based on the search parameters.
         *  This is used by the "Discover" and "Advanced Search".
         */
        AnilistListAnime: {
            key: "ANILIST-anilist-list-anime",
            methods: ["POST"],
            endpoint: "/api/v1/anilist/list-anime",
        },
        /**
         *  @description
         *  Route returns a list of recently aired anime.
         *  This is used by the "Schedule" page to display recently aired anime.
         */
        AnilistListRecentAiringAnime: {
            key: "ANILIST-anilist-list-recent-airing-anime",
            methods: ["POST"],
            endpoint: "/api/v1/anilist/list-recent-anime",
        },
        /**
         *  @description
         *  Route returns a list of sequels not in the user's list.
         *  This is used by the "Discover" page to display sequels the user may have missed.
         */
        AnilistListMissedSequels: {
            key: "ANILIST-anilist-list-missed-sequels",
            methods: ["GET"],
            endpoint: "/api/v1/anilist/list-missed-sequels",
        },
        /**
         *  @description
         *  Route returns the anilist stats.
         *  This returns the AniList stats for the user.
         */
        GetAniListStats: {
            key: "ANILIST-get-ani-list-stats",
            methods: ["GET"],
            endpoint: "/api/v1/anilist/stats",
        },
    },
    ANIME: {
        /**
         *  @description
         *  Route gets list of main episodes
         *  This returns a list of main episodes for the given AniList anime media id.
         *  It also loads the episode list into the different modules.
         */
        GetAnimeEpisodeCollection: {
            key: "ANIME-get-anime-episode-collection",
            methods: ["GET"],
            endpoint: "/api/v1/anime/episode-collection/{id}",
        },
    },
    ANIME_COLLECTION: {
        /**
         *  @description
         *  Route returns the main local anime collection.
         *  This creates a new LibraryCollection struct and returns it.
         *  This is used to get the main anime collection of the user.
         *  It uses the cached Anilist anime collection for the GET method.
         *  It refreshes the AniList anime collection if the POST method is used.
         */
        GetLibraryCollection: {
            key: "ANIME-COLLECTION-get-library-collection",
            methods: ["GET", "POST"],
            endpoint: "/api/v1/library/collection",
        },
        /**
         *  @description
         *  Route returns anime collection schedule
         *  This is used by the "Schedule" page to display the anime schedule.
         */
        GetAnimeCollectionSchedule: {
            key: "ANIME-COLLECTION-get-anime-collection-schedule",
            methods: ["GET"],
            endpoint: "/api/v1/library/schedule",
        },
        /**
         *  @description
         *  Route adds the given media to the user's AniList planning collections
         *  Since media not found in the user's AniList collection are not displayed in the library, this route is used to add them.
         *  The response is ignored in the frontend, the client should just refetch the entire library collection.
         */
        AddUnknownMedia: {
            key: "ANIME-COLLECTION-add-unknown-media",
            methods: ["POST"],
            endpoint: "/api/v1/library/unknown-media",
        },
    },
    ANIME_ENTRIES: {
        /**
         *  @description
         *  Route return a media entry for the given AniList anime media id.
         *  This is used by the anime media entry pages to get all the data about the anime.
         *  This includes episodes and metadata (if any), AniList list data, download info...
         */
        GetAnimeEntry: {
            key: "ANIME-ENTRIES-get-anime-entry",
            methods: ["GET"],
            endpoint: "/api/v1/library/anime-entry/{id}",
        },
        /**
         *  @description
         *  Route perform given action on all the local files for the given media id.
         *  This is used to unmatch or toggle the lock status of all the local files for a specific media entry
         *  The response is not used in the frontend. The client should just refetch the entire media entry data.
         */
        AnimeEntryBulkAction: {
            key: "ANIME-ENTRIES-anime-entry-bulk-action",
            methods: ["PATCH"],
            endpoint: "/api/v1/library/anime-entry/bulk-action",
        },
        /**
         *  @description
         *  Route opens the directory of a media entry in the file explorer.
         *  This finds a common directory for all media entry local files and opens it in the file explorer.
         *  Returns 'true' whether the operation was successful or not, errors are ignored.
         */
        OpenAnimeEntryInExplorer: {
            key: "ANIME-ENTRIES-open-anime-entry-in-explorer",
            methods: ["POST"],
            endpoint: "/api/v1/library/anime-entry/open-in-explorer",
        },
        /**
         *  @description
         *  Route returns a list of media suggestions for files in the given directory.
         *  This is used by the "Resolve unmatched media" feature to suggest media entries for the local files in the given directory.
         *  If some matches files are found in the directory, it will ignore them and base the suggestions on the remaining files.
         */
        FetchAnimeEntrySuggestions: {
            key: "ANIME-ENTRIES-fetch-anime-entry-suggestions",
            methods: ["POST"],
            endpoint: "/api/v1/library/anime-entry/suggestions",
        },
        /**
         *  @description
         *  Route matches un-matched local files in the given directory to the given media.
         *  It is used by the "Resolve unmatched media" feature to manually match local files to a specific media entry.
         *  Matching involves the use of scanner.FileHydrator. It will also lock the files.
         *  The response is not used in the frontend. The client should just refetch the entire library collection.
         */
        AnimeEntryManualMatch: {
            key: "ANIME-ENTRIES-anime-entry-manual-match",
            methods: ["POST"],
            endpoint: "/api/v1/library/anime-entry/manual-match",
        },
        /**
         *  @description
         *  Route returns a list of episodes missing from the user's library collection
         *  It detects missing episodes by comparing the user's AniList collection 'next airing' data with the local files.
         *  This route can be called multiple times, as it does not bypass the cache.
         */
        GetMissingEpisodes: {
            key: "ANIME-ENTRIES-get-missing-episodes",
            methods: ["GET"],
            endpoint: "/api/v1/library/missing-episodes",
        },
        GetAnimeEntrySilenceStatus: {
            key: "ANIME-ENTRIES-get-anime-entry-silence-status",
            methods: ["GET"],
            endpoint: "/api/v1/library/anime-entry/silence/{id}",
        },
        /**
         *  @description
         *  Route toggles the silence status of a media entry.
         *  The missing episodes should be re-fetched after this.
         */
        ToggleAnimeEntrySilenceStatus: {
            key: "ANIME-ENTRIES-toggle-anime-entry-silence-status",
            methods: ["POST"],
            endpoint: "/api/v1/library/anime-entry/silence",
        },
        /**
         *  @description
         *  Route update the progress of the given anime media entry.
         *  This is used to update the progress of the given anime media entry on AniList.
         *  The response is not used in the frontend, the client should just refetch the entire media entry data.
         *  NOTE: This is currently only used by the 'Online streaming' feature since anime progress updates are handled by the Playback Manager.
         */
        UpdateAnimeEntryProgress: {
            key: "ANIME-ENTRIES-update-anime-entry-progress",
            methods: ["POST"],
            endpoint: "/api/v1/library/anime-entry/update-progress",
        },
        /**
         *  @description
         *  Route update the repeat value of the given anime media entry.
         *  This is used to update the repeat value of the given anime media entry on AniList.
         *  The response is not used in the frontend, the client should just refetch the entire media entry data.
         */
        UpdateAnimeEntryRepeat: {
            key: "ANIME-ENTRIES-update-anime-entry-repeat",
            methods: ["POST"],
            endpoint: "/api/v1/library/anime-entry/update-repeat",
        },
    },
    AUTH: {
        /**
         *  @description
         *  Route logs in the user by saving the JWT token in the database.
         *  This is called when the JWT token is obtained from AniList after logging in with redirection on the client.
         *  It also fetches the Viewer data from AniList and saves it in the database.
         *  It creates a new handlers.Status and refreshes App modules.
         */
        Login: {
            key: "AUTH-login",
            methods: ["POST"],
            endpoint: "/api/v1/auth/login",
        },
        /**
         *  @description
         *  Route logs out the user by removing JWT token from the database.
         *  It removes JWT token and Viewer data from the database.
         *  It creates a new handlers.Status and refreshes App modules.
         */
        Logout: {
            key: "AUTH-logout",
            methods: ["POST"],
            endpoint: "/api/v1/auth/logout",
        },
    },
    AUTO_DOWNLOADER: {
        /**
         *  @description
         *  Route tells the AutoDownloader to check for new episodes if enabled.
         *  This will run the AutoDownloader if it is enabled.
         *  It does nothing if the AutoDownloader is disabled.
         */
        RunAutoDownloader: {
            key: "AUTO-DOWNLOADER-run-auto-downloader",
            methods: ["POST"],
            endpoint: "/api/v1/auto-downloader/run",
        },
        /**
         *  @description
         *  Route returns the rule with the given DB id.
         *  This is used to get a specific rule, useful for editing.
         */
        GetAutoDownloaderRule: {
            key: "AUTO-DOWNLOADER-get-auto-downloader-rule",
            methods: ["GET"],
            endpoint: "/api/v1/auto-downloader/rule/{id}",
        },
        GetAutoDownloaderRulesByAnime: {
            key: "AUTO-DOWNLOADER-get-auto-downloader-rules-by-anime",
            methods: ["GET"],
            endpoint: "/api/v1/auto-downloader/rule/anime/{id}",
        },
        /**
         *  @description
         *  Route returns all rules.
         *  This is used to list all rules. It returns an empty slice if there are no rules.
         */
        GetAutoDownloaderRules: {
            key: "AUTO-DOWNLOADER-get-auto-downloader-rules",
            methods: ["GET"],
            endpoint: "/api/v1/auto-downloader/rules",
        },
        /**
         *  @description
         *  Route creates a new rule.
         *  The body should contain the same fields as entities.AutoDownloaderRule.
         *  It returns the created rule.
         */
        CreateAutoDownloaderRule: {
            key: "AUTO-DOWNLOADER-create-auto-downloader-rule",
            methods: ["POST"],
            endpoint: "/api/v1/auto-downloader/rule",
        },
        /**
         *  @description
         *  Route updates a rule.
         *  The body should contain the same fields as entities.AutoDownloaderRule.
         *  It returns the updated rule.
         */
        UpdateAutoDownloaderRule: {
            key: "AUTO-DOWNLOADER-update-auto-downloader-rule",
            methods: ["PATCH"],
            endpoint: "/api/v1/auto-downloader/rule",
        },
        /**
         *  @description
         *  Route deletes a rule.
         *  It returns 'true' if the rule was deleted.
         */
        DeleteAutoDownloaderRule: {
            key: "AUTO-DOWNLOADER-delete-auto-downloader-rule",
            methods: ["DELETE"],
            endpoint: "/api/v1/auto-downloader/rule/{id}",
        },
        /**
         *  @description
         *  Route returns all queued items.
         *  Queued items are episodes that are downloaded but not scanned or not yet downloaded.
         *  The AutoDownloader uses these items in order to not download the same episode twice.
         */
        GetAutoDownloaderItems: {
            key: "AUTO-DOWNLOADER-get-auto-downloader-items",
            methods: ["GET"],
            endpoint: "/api/v1/auto-downloader/items",
        },
        /**
         *  @description
         *  Route delete a queued item.
         *  This is used to remove a queued item from the list.
         *  Returns 'true' if the item was deleted.
         */
        DeleteAutoDownloaderItem: {
            key: "AUTO-DOWNLOADER-delete-auto-downloader-item",
            methods: ["DELETE"],
            endpoint: "/api/v1/auto-downloader/item",
        },
    },
    CONTINUITY: {
        /**
         *  @description
         *  Route Updates watch history item.
         *  This endpoint is used to update a watch history item.
         *  Since this is low priority, we ignore any errors.
         */
        UpdateContinuityWatchHistoryItem: {
            key: "CONTINUITY-update-continuity-watch-history-item",
            methods: ["PATCH"],
            endpoint: "/api/v1/continuity/item",
        },
        /**
         *  @description
         *  Route Returns a watch history item.
         *  This endpoint is used to retrieve a watch history item.
         */
        GetContinuityWatchHistoryItem: {
            key: "CONTINUITY-get-continuity-watch-history-item",
            methods: ["GET"],
            endpoint: "/api/v1/continuity/item/{id}",
        },
        /**
         *  @description
         *  Route Returns the continuity watch history
         *  This endpoint is used to retrieve all watch history items.
         */
        GetContinuityWatchHistory: {
            key: "CONTINUITY-get-continuity-watch-history",
            methods: ["GET"],
            endpoint: "/api/v1/continuity/history",
        },
    },
    DEBRID: {
        /**
         *  @description
         *  Route get debrid settings.
         *  This returns the debrid settings.
         */
        GetDebridSettings: {
            key: "DEBRID-get-debrid-settings",
            methods: ["GET"],
            endpoint: "/api/v1/debrid/settings",
        },
        /**
         *  @description
         *  Route save debrid settings.
         *  This saves the debrid settings.
         *  The client should refetch the server status.
         */
        SaveDebridSettings: {
            key: "DEBRID-save-debrid-settings",
            methods: ["PATCH"],
            endpoint: "/api/v1/debrid/settings",
        },
        /**
         *  @description
         *  Route add torrent to debrid.
         *  This adds a torrent to the debrid service.
         */
        DebridAddTorrents: {
            key: "DEBRID-debrid-add-torrents",
            methods: ["POST"],
            endpoint: "/api/v1/debrid/torrents",
        },
        /**
         *  @description
         *  Route download torrent from debrid.
         *  Manually downloads a torrent from the debrid service locally.
         */
        DebridDownloadTorrent: {
            key: "DEBRID-debrid-download-torrent",
            methods: ["POST"],
            endpoint: "/api/v1/debrid/torrents/download",
        },
        /**
         *  @description
         *  Route cancel download from debrid.
         *  This cancels a download from the debrid service.
         */
        DebridCancelDownload: {
            key: "DEBRID-debrid-cancel-download",
            methods: ["POST"],
            endpoint: "/api/v1/debrid/torrents/cancel",
        },
        /**
         *  @description
         *  Route remove torrent from debrid.
         *  This removes a torrent from the debrid service.
         */
        DebridDeleteTorrent: {
            key: "DEBRID-debrid-delete-torrent",
            methods: ["DELETE"],
            endpoint: "/api/v1/debrid/torrent",
        },
        /**
         *  @description
         *  Route get torrents from debrid.
         *  This gets the torrents from the debrid service.
         */
        DebridGetTorrents: {
            key: "DEBRID-debrid-get-torrents",
            methods: ["GET"],
            endpoint: "/api/v1/debrid/torrents",
        },
        /**
         *  @description
         *  Route get torrent info from debrid.
         *  This gets the torrent info from the debrid service.
         */
        DebridGetTorrentInfo: {
            key: "DEBRID-debrid-get-torrent-info",
            methods: ["POST"],
            endpoint: "/api/v1/debrid/torrents/info",
        },
        DebridGetTorrentFilePreviews: {
            key: "DEBRID-debrid-get-torrent-file-previews",
            methods: ["POST"],
            endpoint: "/api/v1/debrid/torrents/file-previews",
        },
        /**
         *  @description
         *  Route start stream from debrid.
         *  This starts streaming a torrent from the debrid service.
         */
        DebridStartStream: {
            key: "DEBRID-debrid-start-stream",
            methods: ["POST"],
            endpoint: "/api/v1/debrid/stream/start",
        },
        /**
         *  @description
         *  Route cancel stream from debrid.
         *  This cancels a stream from the debrid service.
         */
        DebridCancelStream: {
            key: "DEBRID-debrid-cancel-stream",
            methods: ["POST"],
            endpoint: "/api/v1/debrid/stream/cancel",
        },
    },
    DIRECTORY_SELECTOR: {
        /**
         *  @description
         *  Route returns directory content based on the input path.
         *  This used by the directory selector component to get directory validation and suggestions.
         *  It returns subdirectories based on the input path.
         *  It returns 500 error if the directory does not exist (or cannot be accessed).
         */
        DirectorySelector: {
            key: "DIRECTORY-SELECTOR-directory-selector",
            methods: ["POST"],
            endpoint: "/api/v1/directory-selector",
        },
    },
    DIRECTSTREAM: {
        /**
         *  @description
         *  Route request local file stream.
         *  This requests a local file stream and returns the media container to start the playback.
         */
        DirectstreamPlayLocalFile: {
            key: "DIRECTSTREAM-directstream-play-local-file",
            methods: ["POST"],
            endpoint: "/api/v1/directstream/play/localfile",
        },
    },
    DISCORD: {
        SetDiscordMangaActivity: {
            key: "DISCORD-set-discord-manga-activity",
            methods: ["POST"],
            endpoint: "/api/v1/discord/presence/manga",
        },
        SetDiscordLegacyAnimeActivity: {
            key: "DISCORD-set-discord-legacy-anime-activity",
            methods: ["POST"],
            endpoint: "/api/v1/discord/presence/legacy-anime",
        },
        SetDiscordAnimeActivityWithProgress: {
            key: "DISCORD-set-discord-anime-activity-with-progress",
            methods: ["POST"],
            endpoint: "/api/v1/discord/presence/anime",
        },
        UpdateDiscordAnimeActivityWithProgress: {
            key: "DISCORD-update-discord-anime-activity-with-progress",
            methods: ["POST"],
            endpoint: "/api/v1/discord/presence/anime-update",
        },
        CancelDiscordActivity: {
            key: "DISCORD-cancel-discord-activity",
            methods: ["POST"],
            endpoint: "/api/v1/discord/presence/cancel",
        },
    },
    DOCS: {
        GetDocs: {
            key: "DOCS-get-docs",
            methods: ["GET"],
            endpoint: "/api/v1/internal/docs",
        },
    },
    DOWNLOAD: {
        DownloadTorrentFile: {
            key: "DOWNLOAD-download-torrent-file",
            methods: ["POST"],
            endpoint: "/api/v1/download-torrent-file",
        },
        /**
         *  @description
         *  Route downloads selected release asset to the destination folder.
         *  Downloads the selected release asset to the destination folder and extracts it if possible.
         *  If the extraction fails, the error message will be returned in the successful response.
         *  The successful response will contain the destination path of the extracted files.
         *  It only returns an error if the download fails.
         */
        DownloadRelease: {
            key: "DOWNLOAD-download-release",
            methods: ["POST"],
            endpoint: "/api/v1/download-release",
        },
    },
    EXPLORER: {
        /**
         *  @description
         *  Route opens the given directory in the file explorer.
         *  It returns 'true' whether the operation was successful or not.
         */
        OpenInExplorer: {
            key: "EXPLORER-open-in-explorer",
            methods: ["POST"],
            endpoint: "/api/v1/open-in-explorer",
        },
    },
    EXTENSIONS: {
        FetchExternalExtensionData: {
            key: "EXTENSIONS-fetch-external-extension-data",
            methods: ["POST"],
            endpoint: "/api/v1/extensions/external/fetch",
        },
        InstallExternalExtension: {
            key: "EXTENSIONS-install-external-extension",
            methods: ["POST"],
            endpoint: "/api/v1/extensions/external/install",
        },
        UninstallExternalExtension: {
            key: "EXTENSIONS-uninstall-external-extension",
            methods: ["POST"],
            endpoint: "/api/v1/extensions/external/uninstall",
        },
        UpdateExtensionCode: {
            key: "EXTENSIONS-update-extension-code",
            methods: ["POST"],
            endpoint: "/api/v1/extensions/external/edit-payload",
        },
        ReloadExternalExtensions: {
            key: "EXTENSIONS-reload-external-extensions",
            methods: ["POST"],
            endpoint: "/api/v1/extensions/external/reload",
        },
        ReloadExternalExtension: {
            key: "EXTENSIONS-reload-external-extension",
            methods: ["POST"],
            endpoint: "/api/v1/extensions/external/reload",
        },
        ListExtensionData: {
            key: "EXTENSIONS-list-extension-data",
            methods: ["GET"],
            endpoint: "/api/v1/extensions/list",
        },
        GetExtensionPayload: {
            key: "EXTENSIONS-get-extension-payload",
            methods: ["GET"],
            endpoint: "/api/v1/extensions/payload/{id}",
        },
        ListDevelopmentModeExtensions: {
            key: "EXTENSIONS-list-development-mode-extensions",
            methods: ["GET"],
            endpoint: "/api/v1/extensions/list/development",
        },
        GetAllExtensions: {
            key: "EXTENSIONS-get-all-extensions",
            methods: ["POST"],
            endpoint: "/api/v1/extensions/all",
        },
        GetExtensionUpdateData: {
            key: "EXTENSIONS-get-extension-update-data",
            methods: ["GET"],
            endpoint: "/api/v1/extensions/updates",
        },
        ListMangaProviderExtensions: {
            key: "EXTENSIONS-list-manga-provider-extensions",
            methods: ["GET"],
            endpoint: "/api/v1/extensions/list/manga-provider",
        },
        ListOnlinestreamProviderExtensions: {
            key: "EXTENSIONS-list-onlinestream-provider-extensions",
            methods: ["GET"],
            endpoint: "/api/v1/extensions/list/onlinestream-provider",
        },
        ListAnimeTorrentProviderExtensions: {
            key: "EXTENSIONS-list-anime-torrent-provider-extensions",
            methods: ["GET"],
            endpoint: "/api/v1/extensions/list/anime-torrent-provider",
        },
        GetPluginSettings: {
            key: "EXTENSIONS-get-plugin-settings",
            methods: ["GET"],
            endpoint: "/api/v1/extensions/plugin-settings",
        },
        SetPluginSettingsPinnedTrays: {
            key: "EXTENSIONS-set-plugin-settings-pinned-trays",
            methods: ["POST"],
            endpoint: "/api/v1/extensions/plugin-settings/pinned-trays",
        },
        GrantPluginPermissions: {
            key: "EXTENSIONS-grant-plugin-permissions",
            methods: ["POST"],
            endpoint: "/api/v1/extensions/plugin-permissions/grant",
        },
        /**
         *  @description
         *  Route runs the code in the extension playground.
         *  Returns the logs
         */
        RunExtensionPlaygroundCode: {
            key: "EXTENSIONS-run-extension-playground-code",
            methods: ["POST"],
            endpoint: "/api/v1/extensions/playground/run",
        },
        GetExtensionUserConfig: {
            key: "EXTENSIONS-get-extension-user-config",
            methods: ["GET"],
            endpoint: "/api/v1/extensions/user-config/{id}",
        },
        SaveExtensionUserConfig: {
            key: "EXTENSIONS-save-extension-user-config",
            methods: ["POST"],
            endpoint: "/api/v1/extensions/user-config",
        },
        GetMarketplaceExtensions: {
            key: "EXTENSIONS-get-marketplace-extensions",
            methods: ["GET"],
            endpoint: "/api/v1/extensions/marketplace",
        },
    },
    FILECACHE: {
        /**
         *  @description
         *  Route returns the total size of cache files.
         *  The total size of the cache files is returned in human-readable format.
         */
        GetFileCacheTotalSize: {
            key: "FILECACHE-get-file-cache-total-size",
            methods: ["GET"],
            endpoint: "/api/v1/filecache/total-size",
        },
        /**
         *  @description
         *  Route deletes all buckets with the given prefix.
         *  The bucket value is the prefix of the cache files that should be deleted.
         *  Returns 'true' if the operation was successful.
         */
        RemoveFileCacheBucket: {
            key: "FILECACHE-remove-file-cache-bucket",
            methods: ["DELETE"],
            endpoint: "/api/v1/filecache/bucket",
        },
        /**
         *  @description
         *  Route returns the total size of cached video file data.
         *  The total size of the cache video file data is returned in human-readable format.
         */
        GetFileCacheMediastreamVideoFilesTotalSize: {
            key: "FILECACHE-get-file-cache-mediastream-video-files-total-size",
            methods: ["GET"],
            endpoint: "/api/v1/filecache/mediastream/videofiles/total-size",
        },
        /**
         *  @description
         *  Route deletes the contents of the mediastream video file cache directory.
         *  Returns 'true' if the operation was successful.
         */
        ClearFileCacheMediastreamVideoFiles: {
            key: "FILECACHE-clear-file-cache-mediastream-video-files",
            methods: ["DELETE"],
            endpoint: "/api/v1/filecache/mediastream/videofiles",
        },
    },
    LOCAL: {
        /**
         *  @description
         *  Route sets the offline mode.
         *  Returns true if the offline mode is active, false otherwise.
         */
        SetOfflineMode: {
            key: "LOCAL-set-offline-mode",
            methods: ["POST"],
            endpoint: "/api/v1/local/offline",
        },
        LocalGetTrackedMediaItems: {
            key: "LOCAL-local-get-tracked-media-items",
            methods: ["GET"],
            endpoint: "/api/v1/local/track",
        },
        LocalAddTrackedMedia: {
            key: "LOCAL-local-add-tracked-media",
            methods: ["POST"],
            endpoint: "/api/v1/local/track",
        },
        /**
         *  @description
         *  Route remove media from being tracked for offline sync.
         *  This will remove anime from being tracked for offline sync and delete any associated data.
         */
        LocalRemoveTrackedMedia: {
            key: "LOCAL-local-remove-tracked-media",
            methods: ["DELETE"],
            endpoint: "/api/v1/local/track",
        },
        LocalGetIsMediaTracked: {
            key: "LOCAL-local-get-is-media-tracked",
            methods: ["GET"],
            endpoint: "/api/v1/local/track/{id}/{type}",
        },
        LocalSyncData: {
            key: "LOCAL-local-sync-data",
            methods: ["POST"],
            endpoint: "/api/v1/local/local",
        },
        /**
         *  @description
         *  Route gets the current sync queue state.
         *  This will return the list of media that are currently queued for syncing.
         */
        LocalGetSyncQueueState: {
            key: "LOCAL-local-get-sync-queue-state",
            methods: ["GET"],
            endpoint: "/api/v1/local/queue",
        },
        LocalSyncAnilistData: {
            key: "LOCAL-local-sync-anilist-data",
            methods: ["POST"],
            endpoint: "/api/v1/local/anilist",
        },
        LocalSetHasLocalChanges: {
            key: "LOCAL-local-set-has-local-changes",
            methods: ["POST"],
            endpoint: "/api/v1/local/updated",
        },
        LocalGetHasLocalChanges: {
            key: "LOCAL-local-get-has-local-changes",
            methods: ["GET"],
            endpoint: "/api/v1/local/updated",
        },
        LocalGetLocalStorageSize: {
            key: "LOCAL-local-get-local-storage-size",
            methods: ["GET"],
            endpoint: "/api/v1/local/storage/size",
        },
        LocalSyncSimulatedDataToAnilist: {
            key: "LOCAL-local-sync-simulated-data-to-anilist",
            methods: ["POST"],
            endpoint: "/api/v1/local/sync-simulated-to-anilist",
        },
    },
    LOCALFILES: {
        /**
         *  @description
         *  Route returns all local files.
         *  Reminder that local files are scanned from the library path.
         */
        GetLocalFiles: {
            key: "LOCALFILES-get-local-files",
            methods: ["GET"],
            endpoint: "/api/v1/library/local-files",
        },
        /**
         *  @description
         *  Route imports local files from the given path.
         *  This will import local files from the given path.
         *  The response is ignored, the client should refetch the entire library collection and media entry.
         */
        ImportLocalFiles: {
            key: "LOCALFILES-import-local-files",
            methods: ["POST"],
            endpoint: "/api/v1/library/local-files/import",
        },
        /**
         *  @description
         *  Route performs an action on all local files.
         *  This will perform the given action on all local files.
         *  The response is ignored, the client should refetch the entire library collection and media entry.
         */
        LocalFileBulkAction: {
            key: "LOCALFILES-local-file-bulk-action",
            methods: ["POST"],
            endpoint: "/api/v1/library/local-files",
        },
        /**
         *  @description
         *  Route updates the local file with the given path.
         *  This will update the local file with the given path.
         *  The response is ignored, the client should refetch the entire library collection and media entry.
         */
        UpdateLocalFileData: {
            key: "LOCALFILES-update-local-file-data",
            methods: ["PATCH"],
            endpoint: "/api/v1/library/local-file",
        },
        /**
         *  @description
         *  Route updates local files with the given paths.
         *  The client should refetch the entire library collection and media entry.
         */
        UpdateLocalFiles: {
            key: "LOCALFILES-update-local-files",
            methods: ["PATCH"],
            endpoint: "/api/v1/library/local-files",
        },
        /**
         *  @description
         *  Route deletes local files with the given paths.
         *  This will delete the local files with the given paths.
         *  The client should refetch the entire library collection and media entry.
         */
        DeleteLocalFiles: {
            key: "LOCALFILES-delete-local-files",
            methods: ["DELETE"],
            endpoint: "/api/v1/library/local-files",
        },
        /**
         *  @description
         *  Route removes empty directories.
         *  This will remove empty directories in the library path.
         */
        RemoveEmptyDirectories: {
            key: "LOCALFILES-remove-empty-directories",
            methods: ["DELETE"],
            endpoint: "/api/v1/library/empty-directories",
        },
    },
    MAL: {
        /**
         *  @description
         *  Route fetches the access and refresh tokens for the given code.
         *  This is used to authenticate the user with MyAnimeList.
         *  It will save the info in the database, effectively logging the user in.
         *  The client should re-fetch the server status after this.
         */
        MALAuth: {
            key: "MAL-mal-auth",
            methods: ["POST"],
            endpoint: "/api/v1/mal/auth",
        },
        EditMALListEntryProgress: {
            key: "MAL-edit-mal-list-entry-progress",
            methods: ["POST"],
            endpoint: "/api/v1/mal/list-entry/progress",
        },
        /**
         *  @description
         *  Route logs the user out of MyAnimeList.
         *  This will delete the MAL info from the database, effectively logging the user out.
         *  The client should re-fetch the server status after this.
         */
        MALLogout: {
            key: "MAL-mal-logout",
            methods: ["POST"],
            endpoint: "/api/v1/mal/logout",
        },
    },
    MANGA: {
        GetAnilistMangaCollection: {
            key: "MANGA-get-anilist-manga-collection",
            methods: ["GET"],
            endpoint: "/api/v1/manga/anilist/collection",
        },
        GetRawAnilistMangaCollection: {
            key: "MANGA-get-raw-anilist-manga-collection",
            methods: ["GET", "POST"],
            endpoint: "/api/v1/manga/anilist/collection/raw",
        },
        /**
         *  @description
         *  Route returns the user's main manga collection.
         *  This is an object that contains all the user's manga entries in a structured format.
         */
        GetMangaCollection: {
            key: "MANGA-get-manga-collection",
            methods: ["GET"],
            endpoint: "/api/v1/manga/collection",
        },
        /**
         *  @description
         *  Route returns a manga entry for the given AniList manga id.
         *  This is used by the manga media entry pages to get all the data about the anime. It includes metadata and AniList list data.
         */
        GetMangaEntry: {
            key: "MANGA-get-manga-entry",
            methods: ["GET"],
            endpoint: "/api/v1/manga/entry/{id}",
        },
        /**
         *  @description
         *  Route returns more details about an AniList manga entry.
         *  This fetches more fields omitted from the base queries.
         */
        GetMangaEntryDetails: {
            key: "MANGA-get-manga-entry-details",
            methods: ["GET"],
            endpoint: "/api/v1/manga/entry/{id}/details",
        },
        GetMangaLatestChapterNumbersMap: {
            key: "MANGA-get-manga-latest-chapter-numbers-map",
            methods: ["GET"],
            endpoint: "/api/v1/manga/latest-chapter-numbers",
        },
        RefetchMangaChapterContainers: {
            key: "MANGA-refetch-manga-chapter-containers",
            methods: ["POST"],
            endpoint: "/api/v1/manga/refetch-chapter-containers",
        },
        /**
         *  @description
         *  Route empties the cache for a manga entry.
         *  This will empty the cache for a manga entry (chapter lists and pages), allowing the client to fetch fresh data.
         *  HandleGetMangaEntryChapters should be called after this to fetch the new chapter list.
         *  Returns 'true' if the operation was successful.
         */
        EmptyMangaEntryCache: {
            key: "MANGA-empty-manga-entry-cache",
            methods: ["DELETE"],
            endpoint: "/api/v1/manga/entry/cache",
        },
        GetMangaEntryChapters: {
            key: "MANGA-get-manga-entry-chapters",
            methods: ["POST"],
            endpoint: "/api/v1/manga/chapters",
        },
        /**
         *  @description
         *  Route returns the pages for a manga entry based on the provider and chapter id.
         *  This will return the pages for a manga chapter.
         *  If the app is offline and the chapter is not downloaded, it will return an error.
         *  If the app is online and the chapter is not downloaded, it will return the pages from the provider.
         *  If the chapter is downloaded, it will return the appropriate struct.
         *  If 'double page' is requested, it will fetch image sizes and include the dimensions in the response.
         */
        GetMangaEntryPages: {
            key: "MANGA-get-manga-entry-pages",
            methods: ["POST"],
            endpoint: "/api/v1/manga/pages",
        },
        GetMangaEntryDownloadedChapters: {
            key: "MANGA-get-manga-entry-downloaded-chapters",
            methods: ["GET"],
            endpoint: "/api/v1/manga/downloaded-chapters/{id}",
        },
        /**
         *  @description
         *  Route returns a list of manga based on the search parameters.
         *  This is used by "Advanced Search" and search function.
         */
        AnilistListManga: {
            key: "MANGA-anilist-list-manga",
            methods: ["POST"],
            endpoint: "/api/v1/manga/anilist/list",
        },
        /**
         *  @description
         *  Route updates the progress of a manga entry.
         *  Note: MyAnimeList is not supported
         */
        UpdateMangaProgress: {
            key: "MANGA-update-manga-progress",
            methods: ["POST"],
            endpoint: "/api/v1/manga/update-progress",
        },
        /**
         *  @description
         *  Route returns search results for a manual search.
         *  Returns search results for a manual search.
         */
        MangaManualSearch: {
            key: "MANGA-manga-manual-search",
            methods: ["POST"],
            endpoint: "/api/v1/manga/search",
        },
        /**
         *  @description
         *  Route manually maps a manga entry to a manga ID from the provider.
         *  This is used to manually map a manga entry to a manga ID from the provider.
         *  The client should re-fetch the chapter container after this.
         */
        MangaManualMapping: {
            key: "MANGA-manga-manual-mapping",
            methods: ["POST"],
            endpoint: "/api/v1/manga/manual-mapping",
        },
        /**
         *  @description
         *  Route returns the mapping for a manga entry.
         *  This is used to get the mapping for a manga entry.
         *  An empty string is returned if there's no manual mapping. If there is, the manga ID will be returned.
         */
        GetMangaMapping: {
            key: "MANGA-get-manga-mapping",
            methods: ["POST"],
            endpoint: "/api/v1/manga/get-mapping",
        },
        /**
         *  @description
         *  Route removes the mapping for a manga entry.
         *  This is used to remove the mapping for a manga entry.
         *  The client should re-fetch the chapter container after this.
         */
        RemoveMangaMapping: {
            key: "MANGA-remove-manga-mapping",
            methods: ["POST"],
            endpoint: "/api/v1/manga/remove-mapping",
        },
        GetLocalMangaPage: {
            key: "MANGA-get-local-manga-page",
            methods: ["GET"],
            endpoint: "/api/v1/manga/local-page/{path}",
        },
    },
    MANGA_DOWNLOAD: {
        DownloadMangaChapters: {
            key: "MANGA-DOWNLOAD-download-manga-chapters",
            methods: ["POST"],
            endpoint: "/api/v1/manga/download-chapters",
        },
        /**
         *  @description
         *  Route returns the download data for a specific media.
         *  This is used to display information about the downloaded and queued chapters in the UI.
         *  If the 'cached' parameter is false, it will refresh the data by rescanning the download folder.
         */
        GetMangaDownloadData: {
            key: "MANGA-DOWNLOAD-get-manga-download-data",
            methods: ["POST"],
            endpoint: "/api/v1/manga/download-data",
        },
        GetMangaDownloadQueue: {
            key: "MANGA-DOWNLOAD-get-manga-download-queue",
            methods: ["GET"],
            endpoint: "/api/v1/manga/download-queue",
        },
        /**
         *  @description
         *  Route starts the download queue if it's not already running.
         *  This will start the download queue if it's not already running.
         *  Returns 'true' whether the queue was started or not.
         */
        StartMangaDownloadQueue: {
            key: "MANGA-DOWNLOAD-start-manga-download-queue",
            methods: ["POST"],
            endpoint: "/api/v1/manga/download-queue/start",
        },
        /**
         *  @description
         *  Route stops the manga download queue.
         *  This will stop the manga download queue.
         *  Returns 'true' whether the queue was stopped or not.
         */
        StopMangaDownloadQueue: {
            key: "MANGA-DOWNLOAD-stop-manga-download-queue",
            methods: ["POST"],
            endpoint: "/api/v1/manga/download-queue/stop",
        },
        /**
         *  @description
         *  Route clears all chapters from the download queue.
         *  This will clear all chapters from the download queue.
         *  Returns 'true' whether the queue was cleared or not.
         *  This will also send a websocket event telling the client to refetch the download queue.
         */
        ClearAllChapterDownloadQueue: {
            key: "MANGA-DOWNLOAD-clear-all-chapter-download-queue",
            methods: ["DELETE"],
            endpoint: "/api/v1/manga/download-queue",
        },
        /**
         *  @description
         *  Route resets the errored chapters in the download queue.
         *  This will reset the errored chapters in the download queue, so they can be re-downloaded.
         *  Returns 'true' whether the queue was reset or not.
         *  This will also send a websocket event telling the client to refetch the download queue.
         */
        ResetErroredChapterDownloadQueue: {
            key: "MANGA-DOWNLOAD-reset-errored-chapter-download-queue",
            methods: ["POST"],
            endpoint: "/api/v1/manga/download-queue/reset-errored",
        },
        /**
         *  @description
         *  Route deletes downloaded chapters.
         *  This will delete downloaded chapters from the filesystem.
         *  Returns 'true' whether the chapters were deleted or not.
         *  The client should refetch the download data after this.
         */
        DeleteMangaDownloadedChapters: {
            key: "MANGA-DOWNLOAD-delete-manga-downloaded-chapters",
            methods: ["DELETE"],
            endpoint: "/api/v1/manga/download-chapter",
        },
        /**
         *  @description
         *  Route displays the list of downloaded manga.
         *  This analyzes the download folder and returns a well-formatted structure for displaying downloaded manga.
         *  It returns a list of manga.DownloadListItem where the media data might be nil if it's not in the AniList collection.
         */
        GetMangaDownloadsList: {
            key: "MANGA-DOWNLOAD-get-manga-downloads-list",
            methods: ["GET"],
            endpoint: "/api/v1/manga/downloads",
        },
    },
    MANUAL_DUMP: {
        TestDump: {
            key: "MANUAL-DUMP-test-dump",
            methods: ["POST"],
            endpoint: "/api/v1/test-dump",
        },
    },
    MEDIAPLAYER: {
        StartDefaultMediaPlayer: {
            key: "MEDIAPLAYER-start-default-media-player",
            methods: ["POST"],
            endpoint: "/api/v1/media-player/start",
        },
    },
    MEDIASTREAM: {
        /**
         *  @description
         *  Route get mediastream settings.
         *  This returns the mediastream settings.
         */
        GetMediastreamSettings: {
            key: "MEDIASTREAM-get-mediastream-settings",
            methods: ["GET"],
            endpoint: "/api/v1/mediastream/settings",
        },
        /**
         *  @description
         *  Route save mediastream settings.
         *  This saves the mediastream settings.
         */
        SaveMediastreamSettings: {
            key: "MEDIASTREAM-save-mediastream-settings",
            methods: ["PATCH"],
            endpoint: "/api/v1/mediastream/settings",
        },
        /**
         *  @description
         *  Route request media stream.
         *  This requests a media stream and returns the media container to start the playback.
         */
        RequestMediastreamMediaContainer: {
            key: "MEDIASTREAM-request-mediastream-media-container",
            methods: ["POST"],
            endpoint: "/api/v1/mediastream/request",
        },
        /**
         *  @description
         *  Route preloads media stream for playback.
         *  This preloads a media stream by extracting the media information and attachments.
         */
        PreloadMediastreamMediaContainer: {
            key: "MEDIASTREAM-preload-mediastream-media-container",
            methods: ["POST"],
            endpoint: "/api/v1/mediastream/preload",
        },
        /**
         *  @description
         *  Route shuts down the transcode stream
         *  This requests the transcoder to shut down. It should be called when unmounting the player (playback is no longer needed).
         *  This will also send an events.MediastreamShutdownStream event.
         *  It will not return any error and is safe to call multiple times.
         */
        MediastreamShutdownTranscodeStream: {
            key: "MEDIASTREAM-mediastream-shutdown-transcode-stream",
            methods: ["POST"],
            endpoint: "/api/v1/mediastream/shutdown-transcode",
        },
    },
    METADATA: {
        /**
         *  @description
         *  Route populate cache with TVDB episode metadata.
         *  This will populate the cache with TVDB episode metadata for the given media.
         */
        PopulateTVDBEpisodes: {
            key: "METADATA-populate-tvdb-episodes",
            methods: ["POST"],
            endpoint: "/api/v1/metadata-provider/tvdb-episodes",
        },
        /**
         *  @description
         *  Route empties TVDB episode metadata cache.
         *  This will empty the TVDB episode metadata cache for the given media.
         */
        EmptyTVDBEpisodes: {
            key: "METADATA-empty-tvdb-episodes",
            methods: ["DELETE"],
            endpoint: "/api/v1/metadata-provider/tvdb-episodes",
        },
        /**
         *  @description
         *  Route fetches and caches filler data for the given media.
         *  This will fetch and cache filler data for the given media.
         */
        PopulateFillerData: {
            key: "METADATA-populate-filler-data",
            methods: ["POST"],
            endpoint: "/api/v1/metadata-provider/filler",
        },
        /**
         *  @description
         *  Route removes filler data cache.
         *  This will remove the filler data cache for the given media.
         */
        RemoveFillerData: {
            key: "METADATA-remove-filler-data",
            methods: ["DELETE"],
            endpoint: "/api/v1/metadata-provider/filler",
        },
    },
    NAKAMA: {
        /**
         *  @description
         *  Route handles WebSocket connections for Nakama peers.
         *  This endpoint handles WebSocket connections from Nakama peers when this instance is acting as a host.
         */
        NakamaWebSocket: {
            key: "NAKAMA-nakama-web-socket",
            methods: ["GET"],
            endpoint: "/api/v1/nakama/ws",
        },
        /**
         *  @description
         *  Route sends a custom message through Nakama.
         *  This allows sending custom messages to connected peers or the host.
         */
        SendNakamaMessage: {
            key: "NAKAMA-send-nakama-message",
            methods: ["POST"],
            endpoint: "/api/v1/nakama/message",
        },
        /**
         *  @description
         *  Route shares the local anime collection with Nakama clients.
         *  This creates a new LibraryCollection struct and returns it.
         *  This is used to share the local anime collection with Nakama clients.
         */
        GetNakamaAnimeLibrary: {
            key: "NAKAMA-get-nakama-anime-library",
            methods: ["GET"],
            endpoint: "/api/v1/nakama/host/anime/library/collection",
        },
        /**
         *  @description
         *  Route shares the local anime collection with Nakama clients.
         *  This creates a new LibraryCollection struct and returns it.
         *  This is used to share the local anime collection with Nakama clients.
         */
        GetNakamaAnimeLibraryCollection: {
            key: "NAKAMA-get-nakama-anime-library-collection",
            methods: ["GET"],
            endpoint: "/api/v1/nakama/host/anime/library/collection",
        },
        /**
         *  @description
         *  Route return the local files for the given AniList anime media id.
         *  This is used by the anime media entry pages to get all the data about the anime.
         */
        GetNakamaAnimeLibraryFiles: {
            key: "NAKAMA-get-nakama-anime-library-files",
            methods: ["POST"],
            endpoint: "/api/v1/nakama/host/anime/library/files/{id}",
        },
        /**
         *  @description
         *  Route return all the local files for the host.
         *  This is used to share the local anime collection with Nakama clients.
         */
        GetNakamaAnimeAllLibraryFiles: {
            key: "NAKAMA-get-nakama-anime-all-library-files",
            methods: ["POST"],
            endpoint: "/api/v1/nakama/host/anime/library/files",
        },
        NakamaPlayVideo: {
            key: "NAKAMA-nakama-play-video",
            methods: ["POST"],
            endpoint: "/api/v1/nakama/play",
        },
        /**
         *  @description
         *  Route reconnects to the Nakama host.
         *  This attempts to reconnect to the configured Nakama host if the connection was lost.
         */
        NakamaReconnectToHost: {
            key: "NAKAMA-nakama-reconnect-to-host",
            methods: ["POST"],
            endpoint: "/api/v1/nakama/reconnect",
        },
        /**
         *  @description
         *  Route removes stale peer connections.
         *  This removes peer connections that haven't responded to ping messages for a while.
         */
        NakamaRemoveStaleConnections: {
            key: "NAKAMA-nakama-remove-stale-connections",
            methods: ["POST"],
            endpoint: "/api/v1/nakama/cleanup",
        },
        /**
         *  @description
         *  Route creates a new watch party session.
         *  This creates a new watch party that peers can join to watch content together in sync.
         */
        NakamaCreateWatchParty: {
            key: "NAKAMA-nakama-create-watch-party",
            methods: ["POST"],
            endpoint: "/api/v1/nakama/watch-party/create",
        },
        /**
         *  @description
         *  Route joins an existing watch party.
         *  This allows a peer to join an active watch party session.
         */
        NakamaJoinWatchParty: {
            key: "NAKAMA-nakama-join-watch-party",
            methods: ["POST"],
            endpoint: "/api/v1/nakama/watch-party/join",
        },
        /**
         *  @description
         *  Route leaves the current watch party.
         *  This removes the user from the active watch party session.
         */
        NakamaLeaveWatchParty: {
            key: "NAKAMA-nakama-leave-watch-party",
            methods: ["POST"],
            endpoint: "/api/v1/nakama/watch-party/leave",
        },
    },
    ONLINESTREAM: {
        /**
         *  @description
         *  Route returns the episode list for the given media and provider.
         *  It returns the episode list for the given media and provider.
         *  The episodes are cached using a file cache.
         *  The episode list is just a list of episodes with no video sources, it's what the client uses to display the episodes and subsequently
         *     fetch the sources. The episode list might be nil or empty if nothing could be found, but the media will always be returned.
         */
        GetOnlineStreamEpisodeList: {
            key: "ONLINESTREAM-get-online-stream-episode-list",
            methods: ["POST"],
            endpoint: "/api/v1/onlinestream/episode-list",
        },
        GetOnlineStreamEpisodeSource: {
            key: "ONLINESTREAM-get-online-stream-episode-source",
            methods: ["POST"],
            endpoint: "/api/v1/onlinestream/episode-source",
        },
        OnlineStreamEmptyCache: {
            key: "ONLINESTREAM-online-stream-empty-cache",
            methods: ["DELETE"],
            endpoint: "/api/v1/onlinestream/cache",
        },
        /**
         *  @description
         *  Route returns search results for a manual search.
         *  Returns search results for a manual search.
         */
        OnlinestreamManualSearch: {
            key: "ONLINESTREAM-onlinestream-manual-search",
            methods: ["POST"],
            endpoint: "/api/v1/onlinestream/search",
        },
        /**
         *  @description
         *  Route manually maps an anime entry to an anime ID from the provider.
         *  This is used to manually map an anime entry to an anime ID from the provider.
         *  The client should re-fetch the chapter container after this.
         */
        OnlinestreamManualMapping: {
            key: "ONLINESTREAM-onlinestream-manual-mapping",
            methods: ["POST"],
            endpoint: "/api/v1/onlinestream/manual-mapping",
        },
        /**
         *  @description
         *  Route returns the mapping for an anime entry.
         *  This is used to get the mapping for an anime entry.
         *  An empty string is returned if there's no manual mapping. If there is, the anime ID will be returned.
         */
        GetOnlinestreamMapping: {
            key: "ONLINESTREAM-get-onlinestream-mapping",
            methods: ["POST"],
            endpoint: "/api/v1/onlinestream/get-mapping",
        },
        /**
         *  @description
         *  Route removes the mapping for an anime entry.
         *  This is used to remove the mapping for an anime entry.
         *  The client should re-fetch the chapter container after this.
         */
        RemoveOnlinestreamMapping: {
            key: "ONLINESTREAM-remove-onlinestream-mapping",
            methods: ["POST"],
            endpoint: "/api/v1/onlinestream/remove-mapping",
        },
    },
    PLAYBACK_MANAGER: {
        /**
         *  @description
         *  Route plays the video with the given path using the default media player.
         *  This tells the Playback Manager to play the video using the default media player and start tracking progress.
         *  This returns 'true' if the video was successfully played.
         */
        PlaybackPlayVideo: {
            key: "PLAYBACK-MANAGER-playback-play-video",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/play",
        },
        /**
         *  @description
         *  Route plays a random, unwatched video using the default media player.
         *  This tells the Playback Manager to play a random, unwatched video using the media player and start tracking progress.
         *  It respects the user's progress data and will prioritize "current" and "repeating" media if they are many of them.
         *  This returns 'true' if the video was successfully played.
         */
        PlaybackPlayRandomVideo: {
            key: "PLAYBACK-MANAGER-playback-play-random-video",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/play-random",
        },
        /**
         *  @description
         *  Route updates the AniList progress of the currently playing media.
         *  This is called after 'Update progress' is clicked when watching a media.
         *  This route returns the media ID of the currently playing media, so the client can refetch the media entry data.
         */
        PlaybackSyncCurrentProgress: {
            key: "PLAYBACK-MANAGER-playback-sync-current-progress",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/sync-current-progress",
        },
        /**
         *  @description
         *  Route plays the next episode of the currently playing media.
         *  This will play the next episode of the currently playing media.
         *  This is non-blocking so the client should prevent multiple calls until the next status is received.
         */
        PlaybackPlayNextEpisode: {
            key: "PLAYBACK-MANAGER-playback-play-next-episode",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/next-episode",
        },
        /**
         *  @description
         *  Route gets the next episode of the currently playing media.
         *  This is used by the client's autoplay feature
         */
        PlaybackGetNextEpisode: {
            key: "PLAYBACK-MANAGER-playback-get-next-episode",
            methods: ["GET"],
            endpoint: "/api/v1/playback-manager/next-episode",
        },
        /**
         *  @description
         *  Route plays the next episode of the currently playing media.
         *  This will play the next episode of the currently playing media.
         */
        PlaybackAutoPlayNextEpisode: {
            key: "PLAYBACK-MANAGER-playback-auto-play-next-episode",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/autoplay-next-episode",
        },
        /**
         *  @description
         *  Route starts playing a playlist.
         *  The client should refetch playlists.
         */
        PlaybackStartPlaylist: {
            key: "PLAYBACK-MANAGER-playback-start-playlist",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/start-playlist",
        },
        /**
         *  @description
         *  Route ends the current playlist.
         *  This will stop the current playlist. This is non-blocking.
         */
        PlaybackCancelCurrentPlaylist: {
            key: "PLAYBACK-MANAGER-playback-cancel-current-playlist",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/cancel-playlist",
        },
        /**
         *  @description
         *  Route moves to the next item in the current playlist.
         *  This is non-blocking so the client should prevent multiple calls until the next status is received.
         */
        PlaybackPlaylistNext: {
            key: "PLAYBACK-MANAGER-playback-playlist-next",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/playlist-next",
        },
        /**
         *  @description
         *  Route starts manual tracking of a media.
         *  Used for tracking progress of media that is not played through any integrated media player.
         *  This should only be used for trackable episodes (episodes that count towards progress).
         *  This returns 'true' if the tracking was successfully started.
         */
        PlaybackStartManualTracking: {
            key: "PLAYBACK-MANAGER-playback-start-manual-tracking",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/manual-tracking/start",
        },
        /**
         *  @description
         *  Route cancels manual tracking of a media.
         *  This will stop the server from expecting progress updates for the media.
         */
        PlaybackCancelManualTracking: {
            key: "PLAYBACK-MANAGER-playback-cancel-manual-tracking",
            methods: ["POST"],
            endpoint: "/api/v1/playback-manager/manual-tracking/cancel",
        },
    },
    PLAYLIST: {
        /**
         *  @description
         *  Route creates a new playlist.
         *  This will create a new playlist with the given name and local file paths.
         *  The response is ignored, the client should re-fetch the playlists after this.
         */
        CreatePlaylist: {
            key: "PLAYLIST-create-playlist",
            methods: ["POST"],
            endpoint: "/api/v1/playlist",
        },
        GetPlaylists: {
            key: "PLAYLIST-get-playlists",
            methods: ["GET"],
            endpoint: "/api/v1/playlists",
        },
        /**
         *  @description
         *  Route updates a playlist.
         *  The response is ignored, the client should re-fetch the playlists after this.
         */
        UpdatePlaylist: {
            key: "PLAYLIST-update-playlist",
            methods: ["PATCH"],
            endpoint: "/api/v1/playlist",
        },
        DeletePlaylist: {
            key: "PLAYLIST-delete-playlist",
            methods: ["DELETE"],
            endpoint: "/api/v1/playlist",
        },
        GetPlaylistEpisodes: {
            key: "PLAYLIST-get-playlist-episodes",
            methods: ["GET"],
            endpoint: "/api/v1/playlist/episodes/{id}/{progress}",
        },
    },
    RELEASES: {
        /**
         *  @description
         *  Route installs the latest update.
         *  This will install the latest update and launch the new version.
         */
        InstallLatestUpdate: {
            key: "RELEASES-install-latest-update",
            methods: ["POST"],
            endpoint: "/api/v1/install-update",
        },
        /**
         *  @description
         *  Route returns the latest update.
         *  This will return the latest update.
         *  If an error occurs, it will return an empty update.
         */
        GetLatestUpdate: {
            key: "RELEASES-get-latest-update",
            methods: ["GET"],
            endpoint: "/api/v1/latest-update",
        },
        GetChangelog: {
            key: "RELEASES-get-changelog",
            methods: ["GET"],
            endpoint: "/api/v1/changelog",
        },
    },
    REPORT: {
        SaveIssueReport: {
            key: "REPORT-save-issue-report",
            methods: ["POST"],
            endpoint: "/api/v1/report/issue",
        },
        DownloadIssueReport: {
            key: "REPORT-download-issue-report",
            methods: ["GET"],
            endpoint: "/api/v1/report/issue/download",
        },
    },
    SCAN: {
        /**
         *  @description
         *  Route scans the user's library.
         *  This will scan the user's library.
         *  The response is ignored, the client should re-fetch the library after this.
         */
        ScanLocalFiles: {
            key: "SCAN-scan-local-files",
            methods: ["POST"],
            endpoint: "/api/v1/library/scan",
        },
    },
    SCAN_SUMMARY: {
        GetScanSummaries: {
            key: "SCAN-SUMMARY-get-scan-summaries",
            methods: ["GET"],
            endpoint: "/api/v1/library/scan-summaries",
        },
    },
    SETTINGS: {
        GetSettings: {
            key: "SETTINGS-get-settings",
            methods: ["GET"],
            endpoint: "/api/v1/settings",
        },
        /**
         *  @description
         *  Route updates the app settings.
         *  This will update the app settings.
         *  The client should re-fetch the server status after this.
         */
        GettingStarted: {
            key: "SETTINGS-getting-started",
            methods: ["POST"],
            endpoint: "/api/v1/start",
        },
        /**
         *  @description
         *  Route updates the app settings.
         *  This will update the app settings.
         *  The client should re-fetch the server status after this.
         */
        SaveSettings: {
            key: "SETTINGS-save-settings",
            methods: ["PATCH"],
            endpoint: "/api/v1/settings",
        },
        SaveAutoDownloaderSettings: {
            key: "SETTINGS-save-auto-downloader-settings",
            methods: ["PATCH"],
            endpoint: "/api/v1/settings/auto-downloader",
        },
    },
    STATUS: {
        /**
         *  @description
         *  Route returns the server status.
         *  The server status includes app info, auth info and settings.
         *  The client uses this to set the UI.
         *  It is called on every page load to get the most up-to-date data.
         *  It should be called right after updating the settings.
         */
        GetStatus: {
            key: "STATUS-get-status",
            methods: ["GET"],
            endpoint: "/api/v1/status",
        },
        /**
         *  @description
         *  Route returns the log filenames.
         *  This returns the filenames of all log files in the logs directory.
         */
        GetLogFilenames: {
            key: "STATUS-get-log-filenames",
            methods: ["GET"],
            endpoint: "/api/v1/logs/filenames",
        },
        /**
         *  @description
         *  Route deletes certain log files.
         *  This deletes the log files with the given filenames.
         */
        DeleteLogs: {
            key: "STATUS-delete-logs",
            methods: ["DELETE"],
            endpoint: "/api/v1/logs",
        },
        /**
         *  @description
         *  Route returns the content of the latest server log file.
         *  This returns the content of the most recent seanime- log file after flushing logs.
         */
        GetLatestLogContent: {
            key: "STATUS-get-latest-log-content",
            methods: ["GET"],
            endpoint: "/api/v1/logs/latest",
        },
        /**
         *  @description
         *  Route returns the server announcements.
         *  This returns the announcements for the server.
         */
        GetAnnouncements: {
            key: "STATUS-get-announcements",
            methods: ["POST"],
            endpoint: "/api/v1/announcements",
        },
    },
    THEME: {
        GetTheme: {
            key: "THEME-get-theme",
            methods: ["GET"],
            endpoint: "/api/v1/theme",
        },
        /**
         *  @description
         *  Route updates the theme settings.
         *  The server status should be re-fetched after this on the client.
         */
        UpdateTheme: {
            key: "THEME-update-theme",
            methods: ["PATCH"],
            endpoint: "/api/v1/theme",
        },
    },
    TORRENT_CLIENT: {
        /**
         *  @description
         *  Route returns all active torrents.
         *  This handler is used by the client to display the active torrents.
         */
        GetActiveTorrentList: {
            key: "TORRENT-CLIENT-get-active-torrent-list",
            methods: ["GET"],
            endpoint: "/api/v1/torrent-client/list",
        },
        /**
         *  @description
         *  Route performs an action on a torrent.
         *  This handler is used to pause, resume or remove a torrent.
         */
        TorrentClientAction: {
            key: "TORRENT-CLIENT-torrent-client-action",
            methods: ["POST"],
            endpoint: "/api/v1/torrent-client/action",
        },
        /**
         *  @description
         *  Route adds torrents to the torrent client.
         *  It fetches the magnets from the provided URLs and adds them to the torrent client.
         *  If smart select is enabled, it will try to select the best torrent based on the missing episodes.
         */
        TorrentClientDownload: {
            key: "TORRENT-CLIENT-torrent-client-download",
            methods: ["POST"],
            endpoint: "/api/v1/torrent-client/download",
        },
        /**
         *  @description
         *  Route adds magnets to the torrent client based on the AutoDownloader item.
         *  This is used to download torrents that were queued by the AutoDownloader.
         *  The item will be removed from the queue if the magnet was added successfully.
         *  The AutoDownloader items should be re-fetched after this.
         */
        TorrentClientAddMagnetFromRule: {
            key: "TORRENT-CLIENT-torrent-client-add-magnet-from-rule",
            methods: ["POST"],
            endpoint: "/api/v1/torrent-client/rule-magnet",
        },
    },
    TORRENT_SEARCH: {
        /**
         *  @description
         *  Route searches torrents and returns a list of torrents and their previews.
         *  This will search for torrents and return a list of torrents with previews.
         *  If smart search is enabled, it will filter the torrents based on search parameters.
         */
        SearchTorrent: {
            key: "TORRENT-SEARCH-search-torrent",
            methods: ["POST"],
            endpoint: "/api/v1/torrent/search",
        },
    },
    TORRENTSTREAM: {
        /**
         *  @description
         *  Route get torrentstream settings.
         *  This returns the torrentstream settings.
         */
        GetTorrentstreamSettings: {
            key: "TORRENTSTREAM-get-torrentstream-settings",
            methods: ["GET"],
            endpoint: "/api/v1/torrentstream/settings",
        },
        /**
         *  @description
         *  Route save torrentstream settings.
         *  This saves the torrentstream settings.
         *  The client should refetch the server status.
         */
        SaveTorrentstreamSettings: {
            key: "TORRENTSTREAM-save-torrentstream-settings",
            methods: ["PATCH"],
            endpoint: "/api/v1/torrentstream/settings",
        },
        /**
         *  @description
         *  Route get list of torrent files from a batch
         *  This returns a list of file previews from the torrent
         */
        GetTorrentstreamTorrentFilePreviews: {
            key: "TORRENTSTREAM-get-torrentstream-torrent-file-previews",
            methods: ["POST"],
            endpoint: "/api/v1/torrentstream/torrent-file-previews",
        },
        /**
         *  @description
         *  Route starts a torrent stream.
         *  This starts the entire streaming process.
         */
        TorrentstreamStartStream: {
            key: "TORRENTSTREAM-torrentstream-start-stream",
            methods: ["POST"],
            endpoint: "/api/v1/torrentstream/start",
        },
        /**
         *  @description
         *  Route stop a torrent stream.
         *  This stops the entire streaming process and drops the torrent if it's below a threshold.
         *  This is made to be used while the stream is running.
         */
        TorrentstreamStopStream: {
            key: "TORRENTSTREAM-torrentstream-stop-stream",
            methods: ["POST"],
            endpoint: "/api/v1/torrentstream/stop",
        },
        /**
         *  @description
         *  Route drops a torrent stream.
         *  This stops the entire streaming process and drops the torrent completely.
         *  This is made to be used to force drop a torrent.
         */
        TorrentstreamDropTorrent: {
            key: "TORRENTSTREAM-torrentstream-drop-torrent",
            methods: ["POST"],
            endpoint: "/api/v1/torrentstream/drop",
        },
        /**
         *  @description
         *  Route returns the most recent batch selected.
         *  This returns the most recent batch selected.
         */
        GetTorrentstreamBatchHistory: {
            key: "TORRENTSTREAM-get-torrentstream-batch-history",
            methods: ["POST"],
            endpoint: "/api/v1/torrentstream/batch-history",
        },
    },
} satisfies ApiEndpoints

