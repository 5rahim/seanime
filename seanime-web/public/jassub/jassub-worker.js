(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // node_modules/lfa-ponyfill/fonts.json
  var fonts_exports = {};
  __export(fonts_exports, {
    default: () => fonts_default
  });
  var fonts_default;
  var init_fonts = __esm({
    "node_modules/lfa-ponyfill/fonts.json"() {
      fonts_default = [["ABeeZee", [4, "4i"]], ["ADLaM Display", [4]], ["AR One Sans", ["4a7"]], ["Abel", [4]], ["Abhaya Libre", [4, 5, 6, 7, 8]], ["Aboreto", [4]], ["Abril Fatface", [4]], ["Abyssinica SIL", [4]], ["Aclonica", [4]], ["Acme", [4]], ["Actor", [4]], ["Adamina", [4]], ["Advent Pro", ["1a9", "1a9i"]], ["Afacad", ["4a7", "4a7i"]], ["Afacad Flux", ["1a10"]], ["Agbalumo", [4]], ["Agdasima", [4, 7]], ["Agu Display", [4]], ["Aguafina Script", [4]], ["Akatab", [4, 5, 6, 7, 8, 9]], ["Akaya Kanadaka", [4]], ["Akaya Telivigala", [4]], ["Akronim", [4]], ["Akshar", ["3a7"]], ["Aladin", [4]], ["Alan Sans", ["3a9"]], ["Alata", [4]], ["Alatsi", [4]], ["Albert Sans", ["1a9", "1a9i"]], ["Aldrich", [4]], ["Alef", [4, 7]], ["Alegreya", ["4a9", "4a9i"]], ["Alegreya SC", [4, 5, 7, 8, 9, "4i", "5i", "7i", "8i", "9i"]], ["Alegreya Sans", [1, 3, 4, 5, 7, 8, 9, "1i", "3i", "4i", "5i", "7i", "8i", "9i"]], ["Alegreya Sans SC", [1, 3, 4, 5, 7, 8, 9, "1i", "3i", "4i", "5i", "7i", "8i", "9i"]], ["Aleo", ["1a9", "1a9i"]], ["Alex Brush", [4]], ["Alexandria", ["1a9"]], ["Alfa Slab One", [4]], ["Alice", [4]], ["Alike", [4]], ["Alike Angular", [4]], ["Alkalami", [4]], ["Alkatra", ["4a7"]], ["Allan", [4, 7]], ["Allerta", [4]], ["Allerta Stencil", [4]], ["Allison", [4]], ["Allura", [4]], ["Almarai", [3, 4, 7, 8]], ["Almendra", [4, 7, "4i", "7i"]], ["Almendra Display", [4]], ["Almendra SC", [4]], ["Alumni Sans", ["1a9", "1a9i"]], ["Alumni Sans Collegiate One", [4, "4i"]], ["Alumni Sans Inline One", [4, "4i"]], ["Alumni Sans Pinstripe", [4, "4i"]], ["Alumni Sans SC", ["1a9", "1a9i"]], ["Amarante", [4]], ["Amaranth", [4, 7, "4i", "7i"]], ["Amarna", ["1a7", "1a7i"]], ["Amatic SC", [4, 7]], ["Amethysta", [4]], ["Amiko", [4, 6, 7]], ["Amiri", [4, 7, "4i", "7i"]], ["Amiri Quran", [4]], ["Amita", [4, 7]], ["Anaheim", ["4a8"]], ["Ancizar Sans", ["1a10", "1a10i"]], ["Ancizar Serif", ["3a9", "3a9i"]], ["Andada Pro", ["4a8", "4a8i"]], ["Andika", [4, 7, "4i", "7i"]], ["Anek Bangla", ["1a8"]], ["Anek Devanagari", ["1a8"]], ["Anek Gujarati", ["1a8"]], ["Anek Gurmukhi", ["1a8"]], ["Anek Kannada", ["1a8"]], ["Anek Latin", ["1a8"]], ["Anek Malayalam", ["1a8"]], ["Anek Odia", ["1a8"]], ["Anek Tamil", ["1a8"]], ["Anek Telugu", ["1a8"]], ["Angkor", [4]], ["Annapurna SIL", [4, 7]], ["Annie Use Your Telescope", [4]], ["Anonymous Pro", [4, 7, "4i", "7i"]], ["Anta", [4]], ["Antic", [4]], ["Antic Didone", [4]], ["Antic Slab", [4]], ["Anton", [4]], ["Anton SC", [4]], ["Antonio", ["1a7"]], ["Anuphan", ["1a7"]], ["Anybody", ["1a9", "1a9i"]], ["Aoboshi One", [4]], ["Arapey", [4, "4i"]], ["Arbutus", [4]], ["Arbutus Slab", [4]], ["Architects Daughter", [4]], ["Archivo", ["1a9", "1a9i"]], ["Archivo Black", [4]], ["Archivo Narrow", ["4a7", "4a7i"]], ["Are You Serious", [4]], ["Aref Ruqaa", [4, 7]], ["Aref Ruqaa Ink", [4, 7]], ["Arima", ["1a7"]], ["Arimo", ["4a7", "4a7i"]], ["Arizonia", [4]], ["Armata", [4]], ["Arsenal", [4, 7, "4i", "7i"]], ["Arsenal SC", [4, 7, "4i", "7i"]], ["Artifika", [4]], ["Arvo", [4, 7, "4i", "7i"]], ["Arya", [4, 7]], ["Asap", ["1a9", "1a9i"]], ["Asap Condensed", [2, 3, 4, 5, 6, 7, 8, 9, "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Asar", [4]], ["Asimovian", [4]], ["Asset", [4]], ["Assistant", ["2a8"]], ["Asta Sans", ["3a8"]], ["Astloch", [4, 7]], ["Asul", [4, 7]], ["Athiti", [2, 3, 4, 5, 6, 7]], ["Atkinson Hyperlegible", [4, 7, "4i", "7i"]], ["Atkinson Hyperlegible Mono", ["2a8", "2a8i"]], ["Atkinson Hyperlegible Next", ["2a8", "2a8i"]], ["Atma", [3, 4, 5, 6, 7]], ["Atomic Age", [4]], ["Aubrey", [4]], ["Audiowide", [4]], ["Autour One", [4]], ["Average", [4]], ["Average Sans", [4]], ["Averia Gruesa Libre", [4]], ["Averia Libre", [3, 4, 7, "3i", "4i", "7i"]], ["Averia Sans Libre", [3, 4, 7, "3i", "4i", "7i"]], ["Averia Serif Libre", [3, 4, 7, "3i", "4i", "7i"]], ["Azeret Mono", ["1a9", "1a9i"]], ["B612", [4, 7, "4i", "7i"]], ["B612 Mono", [4, 7, "4i", "7i"]], ["BBH Bartle", [4]], ["BBH Bogle", [4]], ["BBH Hegarty", [4]], ["BIZ UDGothic", [4, 7]], ["BIZ UDMincho", [4, 7]], ["BIZ UDPGothic", [4, 7]], ["BIZ UDPMincho", [4, 7]], ["Babylonica", [4]], ["Bacasime Antique", [4]], ["Bad Script", [4]], ["Badeen Display", [4]], ["Bagel Fat One", [4]], ["Bahiana", [4]], ["Bahianita", [4]], ["Bai Jamjuree", [2, 3, 4, 5, 6, 7, "2i", "3i", "4i", "5i", "6i", "7i"]], ["Bakbak One", [4]], ["Ballet", [4]], ["Baloo 2", ["4a8"]], ["Baloo Bhai 2", ["4a8"]], ["Baloo Bhaijaan 2", ["4a8"]], ["Baloo Bhaina 2", ["4a8"]], ["Baloo Chettan 2", ["4a8"]], ["Baloo Da 2", ["4a8"]], ["Baloo Paaji 2", ["4a8"]], ["Baloo Tamma 2", ["4a8"]], ["Baloo Tammudu 2", ["4a8"]], ["Baloo Thambi 2", ["4a8"]], ["Balsamiq Sans", [4, 7, "4i", "7i"]], ["Balthazar", [4]], ["Bangers", [4]], ["Barlow", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Barlow Condensed", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Barlow Semi Condensed", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Barriecito", [4]], ["Barrio", [4]], ["Basic", [4]], ["Baskervville", ["4a7", "4a7i"]], ["Baskervville SC", ["4a7"]], ["Battambang", [1, 3, 4, 7, 9]], ["Baumans", [4]], ["Bayon", [4]], ["Be Vietnam Pro", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Beau Rivage", [4]], ["Bebas Neue", [4]], ["Beiruti", ["2a9"]], ["Belanosima", [4, 6, 7]], ["Belgrano", [4]], ["Bellefair", [4]], ["Belleza", [4]], ["Bellota", [3, 4, 7, "3i", "4i", "7i"]], ["Bellota Text", [3, 4, 7, "3i", "4i", "7i"]], ["BenchNine", [3, 4, 7]], ["Benne", [4]], ["Bentham", [4]], ["Berkshire Swash", [4]], ["Besley", ["4a9", "4a9i"]], ["Beth Ellen", [4]], ["Bevan", [4, "4i"]], ["BhuTuka Expanded One", [4]], ["Big Shoulders", ["1a9"]], ["Big Shoulders Inline", ["1a9"]], ["Big Shoulders Stencil", ["1a9"]], ["Bigelow Rules", [4]], ["Bigshot One", [4]], ["Bilbo", [4]], ["Bilbo Swash Caps", [4]], ["BioRhyme", ["2a8"]], ["BioRhyme Expanded", [2, 3, 4, 7, 8]], ["Birthstone", [4]], ["Birthstone Bounce", [4, 5]], ["Biryani", [2, 3, 4, 6, 7, 8, 9]], ["Bitcount", ["1a9"]], ["Bitcount Grid Double", ["1a9"]], ["Bitcount Grid Double Ink", ["1a9"]], ["Bitcount Grid Single", ["1a9"]], ["Bitcount Grid Single Ink", ["1a9"]], ["Bitcount Ink", ["1a9"]], ["Bitcount Prop Double", ["1a9"]], ["Bitcount Prop Double Ink", ["1a9"]], ["Bitcount Prop Single", ["1a9"]], ["Bitcount Prop Single Ink", ["1a9"]], ["Bitcount Single", ["1a9"]], ["Bitcount Single Ink", ["1a9"]], ["Bitter", ["1a9", "1a9i"]], ["Black And White Picture", [4]], ["Black Han Sans", [4]], ["Black Ops One", [4]], ["Blaka", [4]], ["Blaka Hollow", [4]], ["Blaka Ink", [4]], ["Blinker", [1, 2, 3, 4, 6, 7, 8, 9]], ["Bodoni Moda", ["4a9", "4a9i"]], ["Bodoni Moda SC", ["4a9", "4a9i"]], ["Bokor", [4]], ["Boldonse", [4]], ["Bona Nova", [4, 7, "4i"]], ["Bona Nova SC", [4, 7, "4i"]], ["Bonbon", [4]], ["Bonheur Royale", [4]], ["Boogaloo", [4]], ["Borel", [4]], ["Bowlby One", [4]], ["Bowlby One SC", [4]], ["Braah One", [4]], ["Brawler", [4, 7]], ["Bree Serif", [4]], ["Bricolage Grotesque", ["2a8"]], ["Bruno Ace", [4]], ["Bruno Ace SC", [4]], ["Brygada 1918", ["4a7", "4a7i"]], ["Bubblegum Sans", [4]], ["Bubbler One", [4]], ["Buda", [3]], ["Buenard", ["4a7"]], ["Bungee", [4]], ["Bungee Hairline", [4]], ["Bungee Inline", [4]], ["Bungee Outline", [4]], ["Bungee Shade", [4]], ["Bungee Spice", [4]], ["Bungee Tint", [4]], ["Butcherman", [4]], ["Butterfly Kids", [4]], ["Bytesized", [4]], ["Cabin", ["4a7", "4a7i"]], ["Cabin Condensed", [4, 5, 6, 7]], ["Cabin Sketch", [4, 7]], ["Cactus Classical Serif", [4]], ["Caesar Dressing", [4]], ["Cagliostro", [4]], ["Cairo", ["2a10"]], ["Cairo Play", ["2a10"]], ["Cal Sans", [4]], ["Caladea", [4, 7, "4i", "7i"]], ["Calistoga", [4]], ["Calligraffitti", [4]], ["Cambay", [4, 7, "4i", "7i"]], ["Cambo", [4]], ["Candal", [4]], ["Cantarell", [4, 7, "4i", "7i"]], ["Cantata One", [4]], ["Cantora One", [4]], ["Caprasimo", [4]], ["Capriola", [4]], ["Caramel", [4]], ["Carattere", [4]], ["Cardo", [4, 7, "4i"]], ["Carlito", [4, 7, "4i", "7i"]], ["Carme", [4]], ["Carrois Gothic", [4]], ["Carrois Gothic SC", [4]], ["Carter One", [4]], ["Cascadia Code", ["2a7", "2a7i"]], ["Cascadia Mono", ["2a7", "2a7i"]], ["Castoro", [4, "4i"]], ["Castoro Titling", [4]], ["Catamaran", ["1a9"]], ["Caudex", [4, 7, "4i", "7i"]], ["Cause", ["1a9"]], ["Caveat", ["4a7"]], ["Caveat Brush", [4]], ["Cedarville Cursive", [4]], ["Ceviche One", [4]], ["Chakra Petch", [3, 4, 5, 6, 7, "3i", "4i", "5i", "6i", "7i"]], ["Changa", ["2a8"]], ["Changa One", [4, "4i"]], ["Chango", [4]], ["Charis SIL", [4, 7, "4i", "7i"]], ["Charm", [4, 7]], ["Charmonman", [4, 7]], ["Chathura", [1, 3, 4, 7, 8]], ["Chau Philomene One", [4, "4i"]], ["Chela One", [4]], ["Chelsea Market", [4]], ["Chenla", [4]], ["Cherish", [4]], ["Cherry Bomb One", [4]], ["Cherry Cream Soda", [4]], ["Cherry Swash", [4, 7]], ["Chewy", [4]], ["Chicle", [4]], ["Chilanka", [4]], ["Chiron GoRound TC", ["2a9"]], ["Chiron Hei HK", ["2a9", "2a9i"]], ["Chiron Sung HK", ["2a9", "2a9i"]], ["Chivo", ["1a9", "1a9i"]], ["Chivo Mono", ["1a9", "1a9i"]], ["Chocolate Classical Sans", [4]], ["Chokokutai", [4]], ["Chonburi", [4]], ["Cinzel", ["4a9"]], ["Cinzel Decorative", [4, 7, 9]], ["Clicker Script", [4]], ["Climate Crisis", [4]], ["Coda", [4, 8]], ["Codystar", [3, 4]], ["Coiny", [4]], ["Combo", [4]], ["Comfortaa", ["3a7"]], ["Comforter", [4]], ["Comforter Brush", [4]], ["Comic Neue", [3, 4, 7, "3i", "4i", "7i"]], ["Comic Relief", [4, 7]], ["Coming Soon", [4]], ["Comme", ["1a9"]], ["Commissioner", ["1a9"]], ["Concert One", [4]], ["Condiment", [4]], ["Content", [4, 7]], ["Contrail One", [4]], ["Convergence", [4]], ["Cookie", [4]], ["Copse", [4]], ["Coral Pixels", [4]], ["Corben", [4, 7]], ["Corinthia", [4, 7]], ["Cormorant", ["3a7", "3a7i"]], ["Cormorant Garamond", ["3a7", "3a7i"]], ["Cormorant Infant", ["3a7", "3a7i"]], ["Cormorant SC", [3, 4, 5, 6, 7]], ["Cormorant Unicase", [3, 4, 5, 6, 7]], ["Cormorant Upright", [3, 4, 5, 6, 7]], ["Cossette Texte", [4, 7]], ["Cossette Titre", [4, 7]], ["Courgette", [4]], ["Courier Prime", [4, 7, "4i", "7i"]], ["Cousine", [4, 7, "4i", "7i"]], ["Coustard", [4, 9]], ["Covered By Your Grace", [4]], ["Crafty Girls", [4]], ["Creepster", [4]], ["Crete Round", [4, "4i"]], ["Crimson Pro", ["2a9", "2a9i"]], ["Crimson Text", [4, 6, 7, "4i", "6i", "7i"]], ["Croissant One", [4]], ["Crushed", [4]], ["Cuprum", ["4a7", "4a7i"]], ["Cute Font", [4]], ["Cutive", [4]], ["Cutive Mono", [4]], ["DM Mono", [3, 4, 5, "3i", "4i", "5i"]], ["DM Sans", ["1a10", "1a10i"]], ["DM Serif Display", [4, "4i"]], ["DM Serif Text", [4, "4i"]], ["Dai Banna SIL", [3, 4, 5, 6, 7, "3i", "4i", "5i", "6i", "7i"]], ["Damion", [4]], ["Dancing Script", ["4a7"]], ["Danfo", [4]], ["Dangrek", [4]], ["Darker Grotesque", ["3a9"]], ["Darumadrop One", [4]], ["David Libre", [4, 5, 7]], ["Dawning of a New Day", [4]], ["Days One", [4]], ["Dekko", [4]], ["Dela Gothic One", [4]], ["Delicious Handrawn", [4]], ["Delius", [4]], ["Delius Swash Caps", [4]], ["Delius Unicase", [4, 7]], ["Della Respira", [4]], ["Denk One", [4]], ["Devonshire", [4]], ["Dhurjati", [4]], ["Didact Gothic", [4]], ["Diphylleia", [4]], ["Diplomata", [4]], ["Diplomata SC", [4]], ["Do Hyeon", [4]], ["Dokdo", [4]], ["Domine", ["4a7"]], ["Donegal One", [4]], ["Dongle", [3, 4, 7]], ["Doppio One", [4]], ["Dorsa", [4]], ["Dosis", ["2a8"]], ["DotGothic16", [4]], ["Doto", ["1a9"]], ["Dr Sugiyama", [4]], ["Duru Sans", [4]], ["DynaPuff", ["4a7"]], ["Dynalight", [4]], ["EB Garamond", ["4a8", "4a8i"]], ["Eagle Lake", [4]], ["East Sea Dokdo", [4]], ["Eater", [4]], ["Economica", [4, 7, "4i", "7i"]], ["Eczar", ["4a8"]], ["Edu AU VIC WA NT Arrows", ["4a7"]], ["Edu AU VIC WA NT Dots", ["4a7"]], ["Edu AU VIC WA NT Guides", ["4a7"]], ["Edu AU VIC WA NT Hand", ["4a7"]], ["Edu AU VIC WA NT Pre", ["4a7"]], ["Edu NSW ACT Cursive", ["4a7"]], ["Edu NSW ACT Foundation", ["4a7"]], ["Edu NSW ACT Hand Pre", ["4a7"]], ["Edu QLD Beginner", ["4a7"]], ["Edu QLD Hand", ["4a7"]], ["Edu SA Beginner", ["4a7"]], ["Edu SA Hand", ["4a7"]], ["Edu TAS Beginner", ["4a7"]], ["Edu VIC WA NT Beginner", ["4a7"]], ["Edu VIC WA NT Hand", ["4a7"]], ["Edu VIC WA NT Hand Pre", ["4a7"]], ["El Messiri", ["4a7"]], ["Electrolize", [4]], ["Elms Sans", ["1a9", "1a9i"]], ["Elsie", [4, 9]], ["Elsie Swash Caps", [4, 9]], ["Emblema One", [4]], ["Emilys Candy", [4]], ["Encode Sans", ["1a9"]], ["Encode Sans Condensed", [1, 2, 3, 4, 5, 6, 7, 8, 9]], ["Encode Sans Expanded", [1, 2, 3, 4, 5, 6, 7, 8, 9]], ["Encode Sans SC", ["1a9"]], ["Encode Sans Semi Condensed", [1, 2, 3, 4, 5, 6, 7, 8, 9]], ["Encode Sans Semi Expanded", [1, 2, 3, 4, 5, 6, 7, 8, 9]], ["Engagement", [4]], ["Englebert", [4]], ["Enriqueta", [4, 5, 6, 7]], ["Ephesis", [4]], ["Epilogue", ["1a9", "1a9i"]], ["Epunda Sans", ["3a9", "3a9i"]], ["Epunda Slab", ["3a9", "3a9i"]], ["Erica One", [4]], ["Esteban", [4]], ["Estonia", [4]], ["Euphoria Script", [4]], ["Ewert", [4]], ["Exile", [4]], ["Exo", ["1a9", "1a9i"]], ["Exo 2", ["1a9", "1a9i"]], ["Expletus Sans", ["4a7", "4a7i"]], ["Explora", [4]], ["Faculty Glyphic", [4]], ["Fahkwang", [2, 3, 4, 5, 6, 7, "2i", "3i", "4i", "5i", "6i", "7i"]], ["Familjen Grotesk", ["4a7", "4a7i"]], ["Fanwood Text", [4, "4i"]], ["Farro", [3, 4, 5, 7]], ["Farsan", [4]], ["Fascinate", [4]], ["Fascinate Inline", [4]], ["Faster One", [4]], ["Fasthand", [4]], ["Fauna One", [4]], ["Faustina", ["3a8", "3a8i"]], ["Federant", [4]], ["Federo", [4]], ["Felipa", [4]], ["Fenix", [4]], ["Festive", [4]], ["Figtree", ["3a9", "3a9i"]], ["Finger Paint", [4]], ["Finlandica", ["4a7", "4a7i"]], ["Fira Code", ["3a7"]], ["Fira Mono", [4, 5, 7]], ["Fira Sans", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Fira Sans Condensed", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Fira Sans Extra Condensed", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Fjalla One", [4]], ["Fjord One", [4]], ["Flamenco", [3, 4]], ["Flavors", [4]], ["Fleur De Leah", [4]], ["Flow Block", [4]], ["Flow Circular", [4]], ["Flow Rounded", [4]], ["Foldit", ["1a9"]], ["Fondamento", [4, "4i"]], ["Fontdiner Swanky", [4]], ["Forum", [4]], ["Fragment Mono", [4, "4i"]], ["Francois One", [4]], ["Frank Ruhl Libre", ["3a9"]], ["Fraunces", ["1a9", "1a9i"]], ["Freckle Face", [4]], ["Fredericka the Great", [4]], ["Fredoka", ["3a7"]], ["Freehand", [4]], ["Freeman", [4]], ["Fresca", [4]], ["Frijole", [4]], ["Fruktur", [4, "4i"]], ["Fugaz One", [4]], ["Fuggles", [4]], ["Funnel Display", ["3a8"]], ["Funnel Sans", ["3a8", "3a8i"]], ["Fustat", ["2a8"]], ["Fuzzy Bubbles", [4, 7]], ["GFS Didot", [4]], ["GFS Neohellenic", [4, 7, "4i", "7i"]], ["Ga Maamli", [4]], ["Gabarito", ["4a9"]], ["Gabriela", [4]], ["Gaegu", [3, 4, 7]], ["Gafata", [4]], ["Gajraj One", [4]], ["Galada", [4]], ["Galdeano", [4]], ["Galindo", [4]], ["Gamja Flower", [4]], ["Gantari", ["1a9", "1a9i"]], ["Gasoek One", [4]], ["Gayathri", [1, 4, 7]], ["Geist", ["1a9"]], ["Geist Mono", ["1a9"]], ["Gelasio", ["4a7", "4a7i"]], ["Gemunu Libre", ["2a8"]], ["Genos", ["1a9", "1a9i"]], ["Gentium Book Plus", [4, 7, "4i", "7i"]], ["Gentium Plus", [4, 7, "4i", "7i"]], ["Geo", [4, "4i"]], ["Geologica", ["1a9"]], ["Geom", ["3a9", "3a9i"]], ["Georama", ["1a9", "1a9i"]], ["Geostar", [4]], ["Geostar Fill", [4]], ["Germania One", [4]], ["Gideon Roman", [4]], ["Gidole", [4]], ["Gidugu", [4]], ["Gilda Display", [4]], ["Girassol", [4]], ["Give You Glory", [4]], ["Glass Antiqua", [4]], ["Glegoo", [4, 7]], ["Gloock", [4]], ["Gloria Hallelujah", [4]], ["Glory", ["1a8", "1a8i"]], ["Gluten", ["1a9"]], ["Goblin One", [4]], ["Gochi Hand", [4]], ["Goldman", [4, 7]], ["Golos Text", ["4a9"]], ["Google Sans", ["4a7", "4a7i"]], ["Google Sans Code", ["3a8", "3a8i"]], ["Google Sans Flex", ["1a10"]], ["Gorditas", [4, 7]], ["Gothic A1", [1, 2, 3, 4, 5, 6, 7, 8, 9]], ["Gotu", [4]], ["Goudy Bookletter 1911", [4]], ["Gowun Batang", [4, 7]], ["Gowun Dodum", [4]], ["Graduate", [4]], ["Grand Hotel", [4]], ["Grandiflora One", [4]], ["Grandstander", ["1a9", "1a9i"]], ["Grape Nuts", [4]], ["Gravitas One", [4]], ["Great Vibes", [4]], ["Grechen Fuemen", [4]], ["Grenze", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Grenze Gotisch", ["1a9"]], ["Grey Qo", [4]], ["Griffy", [4]], ["Gruppo", [4]], ["Gudea", [4, 7, "4i"]], ["Gugi", [4]], ["Gulzar", [4]], ["Gupter", [4, 5, 7]], ["Gurajada", [4]], ["Gwendolyn", [4, 7]], ["Habibi", [4]], ["Hachi Maru Pop", [4]], ["Hahmlet", ["1a9"]], ["Halant", [3, 4, 5, 6, 7]], ["Hammersmith One", [4]], ["Hanalei", [4]], ["Hanalei Fill", [4]], ["Handjet", ["1a9"]], ["Handlee", [4]], ["Hanken Grotesk", ["1a9", "1a9i"]], ["Hanuman", ["1a9"]], ["Happy Monkey", [4]], ["Harmattan", [4, 5, 6, 7]], ["Headland One", [4]], ["Hedvig Letters Sans", [4]], ["Hedvig Letters Serif", [4]], ["Heebo", ["1a9"]], ["Henny Penny", [4]], ["Hepta Slab", ["1a9"]], ["Herr Von Muellerhoff", [4]], ["Hi Melody", [4]], ["Hina Mincho", [4]], ["Hind", [3, 4, 5, 6, 7]], ["Hind Guntur", [3, 4, 5, 6, 7]], ["Hind Madurai", [3, 4, 5, 6, 7]], ["Hind Mysuru", [3, 4, 5, 6, 7]], ["Hind Siliguri", [3, 4, 5, 6, 7]], ["Hind Vadodara", [3, 4, 5, 6, 7]], ["Holtwood One SC", [4]], ["Homemade Apple", [4]], ["Homenaje", [4]], ["Honk", [4]], ["Host Grotesk", ["3a8", "3a8i"]], ["Hubballi", [4]], ["Hubot Sans", ["2a9", "2a9i"]], ["Huninn", [4]], ["Hurricane", [4]], ["IBM Plex Mono", [1, 2, 3, 4, 5, 6, 7, "1i", "2i", "3i", "4i", "5i", "6i", "7i"]], ["IBM Plex Sans", ["1a7", "1a7i"]], ["IBM Plex Sans Arabic", [1, 2, 3, 4, 5, 6, 7]], ["IBM Plex Sans Condensed", [1, 2, 3, 4, 5, 6, 7, "1i", "2i", "3i", "4i", "5i", "6i", "7i"]], ["IBM Plex Sans Devanagari", [1, 2, 3, 4, 5, 6, 7]], ["IBM Plex Sans Hebrew", [1, 2, 3, 4, 5, 6, 7]], ["IBM Plex Sans JP", [1, 2, 3, 4, 5, 6, 7]], ["IBM Plex Sans KR", [1, 2, 3, 4, 5, 6, 7]], ["IBM Plex Sans Thai", [1, 2, 3, 4, 5, 6, 7]], ["IBM Plex Sans Thai Looped", [1, 2, 3, 4, 5, 6, 7]], ["IBM Plex Serif", [1, 2, 3, 4, 5, 6, 7, "1i", "2i", "3i", "4i", "5i", "6i", "7i"]], ["IM Fell DW Pica", [4, "4i"]], ["IM Fell DW Pica SC", [4]], ["IM Fell Double Pica", [4, "4i"]], ["IM Fell Double Pica SC", [4]], ["IM Fell English", [4, "4i"]], ["IM Fell English SC", [4]], ["IM Fell French Canon", [4, "4i"]], ["IM Fell French Canon SC", [4]], ["IM Fell Great Primer", [4, "4i"]], ["IM Fell Great Primer SC", [4]], ["Iansui", [4]], ["Ibarra Real Nova", ["4a7", "4a7i"]], ["Iceberg", [4]], ["Iceland", [4]], ["Imbue", ["1a9"]], ["Imperial Script", [4]], ["Imprima", [4]], ["Inclusive Sans", ["3a7", "3a7i"]], ["Inconsolata", ["2a9"]], ["Inder", [4]], ["Indie Flower", [4]], ["Ingrid Darling", [4]], ["Inika", [4, 7]], ["Inknut Antiqua", [3, 4, 5, 6, 7, 8, 9]], ["Inria Sans", [3, 4, 7, "3i", "4i", "7i"]], ["Inria Serif", [3, 4, 7, "3i", "4i", "7i"]], ["Inspiration", [4]], ["Instrument Sans", ["4a7", "4a7i"]], ["Instrument Serif", [4, "4i"]], ["Intel One Mono", ["3a7", "3a7i"]], ["Inter", ["1a9", "1a9i"]], ["Inter Tight", ["1a9", "1a9i"]], ["Irish Grover", [4]], ["Island Moments", [4]], ["Istok Web", [4, 7, "4i", "7i"]], ["Italiana", [4]], ["Italianno", [4]], ["Itim", [4]], ["Jacquard 12", [4]], ["Jacquard 12 Charted", [4]], ["Jacquard 24", [4]], ["Jacquard 24 Charted", [4]], ["Jacquarda Bastarda 9", [4]], ["Jacquarda Bastarda 9 Charted", [4]], ["Jacques Francois", [4]], ["Jacques Francois Shadow", [4]], ["Jaini", [4]], ["Jaini Purva", [4]], ["Jaldi", [4, 7]], ["Jaro", [4]], ["Jersey 10", [4]], ["Jersey 10 Charted", [4]], ["Jersey 15", [4]], ["Jersey 15 Charted", [4]], ["Jersey 20", [4]], ["Jersey 20 Charted", [4]], ["Jersey 25", [4]], ["Jersey 25 Charted", [4]], ["JetBrains Mono", ["1a8", "1a8i"]], ["Jim Nightshade", [4]], ["Joan", [4]], ["Jockey One", [4]], ["Jolly Lodger", [4]], ["Jomhuria", [4]], ["Jomolhari", [4]], ["Josefin Sans", ["1a7", "1a7i"]], ["Josefin Slab", ["1a7", "1a7i"]], ["Jost", ["1a9", "1a9i"]], ["Joti One", [4]], ["Jua", [4]], ["Judson", [4, 7, "4i"]], ["Julee", [4]], ["Julius Sans One", [4]], ["Junge", [4]], ["Jura", ["3a7"]], ["Just Another Hand", [4]], ["Just Me Again Down Here", [4]], ["K2D", [1, 2, 3, 4, 5, 6, 7, 8, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i"]], ["Kablammo", [4]], ["Kadwa", [4, 7]], ["Kaisei Decol", [4, 5, 7]], ["Kaisei HarunoUmi", [4, 5, 7]], ["Kaisei Opti", [4, 5, 7]], ["Kaisei Tokumin", [4, 5, 7, 8]], ["Kalam", [3, 4, 7]], ["Kalnia", ["1a7"]], ["Kalnia Glaze", ["1a7"]], ["Kameron", ["4a7"]], ["Kanchenjunga", [4, 5, 6, 7]], ["Kanit", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Kantumruy Pro", ["1a7", "1a7i"]], ["Kapakana", ["3a4"]], ["Karantina", [3, 4, 7]], ["Karla", ["2a8", "2a8i"]], ["Karla Tamil Inclined", [4, 7]], ["Karla Tamil Upright", [4, 7]], ["Karma", [3, 4, 5, 6, 7]], ["Katibeh", [4]], ["Kaushan Script", [4]], ["Kavivanar", [4]], ["Kavoon", [4]], ["Kay Pho Du", [4, 5, 6, 7]], ["Kdam Thmor Pro", [4]], ["Keania One", [4]], ["Kedebideri", [4, 5, 6, 7, 8, 9]], ["Kelly Slab", [4]], ["Kenia", [4]], ["Khand", [3, 4, 5, 6, 7]], ["Khmer", [4]], ["Khula", [3, 4, 6, 7, 8]], ["Kings", [4]], ["Kirang Haerang", [4]], ["Kite One", [4]], ["Kiwi Maru", [3, 4, 5]], ["Klee One", [4, 6]], ["Knewave", [4]], ["KoHo", [2, 3, 4, 5, 6, 7, "2i", "3i", "4i", "5i", "6i", "7i"]], ["Kodchasan", [2, 3, 4, 5, 6, 7, "2i", "3i", "4i", "5i", "6i", "7i"]], ["Kode Mono", ["4a7"]], ["Koh Santepheap", [1, 3, 4, 7, 9]], ["Kolker Brush", [4]], ["Konkhmer Sleokchher", [4]], ["Kosugi", [4]], ["Kosugi Maru", [4]], ["Kotta One", [4]], ["Koulen", [4]], ["Kranky", [4]], ["Kreon", ["3a7"]], ["Kristi", [4]], ["Krona One", [4]], ["Krub", [2, 3, 4, 5, 6, 7, "2i", "3i", "4i", "5i", "6i", "7i"]], ["Kufam", ["4a9", "4a9i"]], ["Kulim Park", [2, 3, 4, 6, 7, "2i", "3i", "4i", "6i", "7i"]], ["Kumar One", [4]], ["Kumar One Outline", [4]], ["Kumbh Sans", ["1a9"]], ["Kurale", [4]], ["LINE Seed JP", [1, 4, 7, 8]], ["LXGW Marker Gothic", [4]], ["LXGW WenKai Mono TC", [3, 4, 7]], ["LXGW WenKai TC", [3, 4, 7]], ["La Belle Aurore", [4]], ["Labrada", ["1a9", "1a9i"]], ["Lacquer", [4]], ["Laila", [3, 4, 5, 6, 7]], ["Lakki Reddy", [4]], ["Lalezar", [4]], ["Lancelot", [4]], ["Langar", [4]], ["Lateef", [2, 3, 4, 5, 6, 7, 8]], ["Lato", [1, 3, 4, 7, 9, "1i", "3i", "4i", "7i", "9i"]], ["Lavishly Yours", [4]], ["League Gothic", [4]], ["League Script", [4]], ["League Spartan", ["1a9"]], ["Leckerli One", [4]], ["Ledger", [4]], ["Lekton", [4, 7, "4i"]], ["Lemon", [4]], ["Lemonada", ["3a7"]], ["Lexend", ["1a9"]], ["Lexend Deca", ["1a9"]], ["Lexend Exa", ["1a9"]], ["Lexend Giga", ["1a9"]], ["Lexend Mega", ["1a9"]], ["Lexend Peta", ["1a9"]], ["Lexend Tera", ["1a9"]], ["Lexend Zetta", ["1a9"]], ["Libertinus Keyboard", [4]], ["Libertinus Math", [4]], ["Libertinus Mono", [4]], ["Libertinus Sans", [4, 7, "4i"]], ["Libertinus Serif", [4, 6, 7, "4i", "6i", "7i"]], ["Libertinus Serif Display", [4]], ["Libre Barcode 128", [4]], ["Libre Barcode 128 Text", [4]], ["Libre Barcode 39", [4]], ["Libre Barcode 39 Extended", [4]], ["Libre Barcode 39 Extended Text", [4]], ["Libre Barcode 39 Text", [4]], ["Libre Barcode EAN13 Text", [4]], ["Libre Baskerville", ["4a7", "4a7i"]], ["Libre Bodoni", ["4a7", "4a7i"]], ["Libre Caslon Display", [4]], ["Libre Caslon Text", [4, 7, "4i"]], ["Libre Franklin", ["1a9", "1a9i"]], ["Licorice", [4]], ["Life Savers", [4, 7, 8]], ["Lilex", ["1a7", "1a7i"]], ["Lilita One", [4]], ["Lily Script One", [4]], ["Limelight", [4]], ["Linden Hill", [4, "4i"]], ["Linefont", ["1a10"]], ["Lisu Bosa", [2, 3, 4, 5, 6, 7, 8, 9, "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Liter", [4]], ["Literata", ["2a9", "2a9i"]], ["Liu Jian Mao Cao", [4]], ["Livvic", [1, 2, 3, 4, 5, 6, 7, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "9i"]], ["Lobster", [4]], ["Lobster Two", [4, 7, "4i", "7i"]], ["Londrina Outline", [4]], ["Londrina Shadow", [4]], ["Londrina Sketch", [4]], ["Londrina Solid", [1, 3, 4, 9]], ["Long Cang", [4]], ["Lora", ["4a7", "4a7i"]], ["Love Light", [4]], ["Love Ya Like A Sister", [4]], ["Loved by the King", [4]], ["Lovers Quarrel", [4]], ["Luckiest Guy", [4]], ["Lugrasimo", [4]], ["Lumanosimo", [4]], ["Lunasima", [4, 7]], ["Lusitana", [4, 7]], ["Lustria", [4]], ["Luxurious Roman", [4]], ["Luxurious Script", [4]], ["M PLUS 1", ["1a9"]], ["M PLUS 1 Code", ["1a7"]], ["M PLUS 1p", [1, 3, 4, 5, 7, 8, 9]], ["M PLUS 2", ["1a9"]], ["M PLUS Code Latin", ["1a7"]], ["M PLUS Rounded 1c", [1, 3, 4, 5, 7, 8, 9]], ["Ma Shan Zheng", [4]], ["Macondo", [4]], ["Macondo Swash Caps", [4]], ["Mada", ["2a9"]], ["Madimi One", [4]], ["Magra", [4, 7]], ["Maiden Orange", [4]], ["Maitree", [2, 3, 4, 5, 6, 7]], ["Major Mono Display", [4]], ["Mako", [4]], ["Mali", [2, 3, 4, 5, 6, 7, "2i", "3i", "4i", "5i", "6i", "7i"]], ["Mallanna", [4]], ["Maname", [4]], ["Mandali", [4]], ["Manjari", [1, 4, 7]], ["Manrope", ["2a8"]], ["Mansalva", [4]], ["Manuale", ["3a8", "3a8i"]], ["Manufacturing Consent", [4]], ["Marcellus", [4]], ["Marcellus SC", [4]], ["Marck Script", [4]], ["Margarine", [4]], ["Marhey", ["3a7"]], ["Markazi Text", ["4a7"]], ["Marko One", [4]], ["Marmelad", [4]], ["Martel", [2, 3, 4, 6, 7, 8, 9]], ["Martel Sans", [2, 3, 4, 6, 7, 8, 9]], ["Martian Mono", ["1a8"]], ["Marvel", [4, 7, "4i", "7i"]], ["Matangi", ["3a9"]], ["Mate", [4, "4i"]], ["Mate SC", [4]], ["Matemasie", [4]], ["Maven Pro", ["4a9"]], ["McLaren", [4]], ["Mea Culpa", [4]], ["Meddon", [4]], ["MedievalSharp", [4]], ["Medula One", [4]], ["Meera Inimai", [4]], ["Megrim", [4]], ["Meie Script", [4]], ["Menbere", ["1a7"]], ["Meow Script", [4]], ["Merienda", ["3a9"]], ["Merriweather", ["3a9", "3a9i"]], ["Merriweather Sans", ["3a8", "3a8i"]], ["Metal", [4]], ["Metal Mania", [4]], ["Metamorphous", [4]], ["Metrophobic", [4]], ["Michroma", [4]], ["Micro 5", [4]], ["Micro 5 Charted", [4]], ["Milonga", [4]], ["Miltonian", [4]], ["Miltonian Tattoo", [4]], ["Mina", [4, 7]], ["Mingzat", [4]], ["Miniver", [4]], ["Miriam Libre", ["4a7"]], ["Mirza", [4, 5, 6, 7]], ["Miss Fajardose", [4]], ["Mitr", [2, 3, 4, 5, 6, 7]], ["Mochiy Pop One", [4]], ["Mochiy Pop P One", [4]], ["Modak", [4]], ["Modern Antiqua", [4]], ["Moderustic", ["3a8"]], ["Mogra", [4]], ["Mohave", ["3a7", "3a7i"]], ["Moirai One", [4]], ["Molengo", [4]], ["Molle", ["4i"]], ["Momo Signature", [4]], ["Momo Trust Display", [4]], ["Momo Trust Sans", ["2a8"]], ["Mona Sans", ["2a9", "2a9i"]], ["Monda", ["4a7"]], ["Monofett", [4]], ["Monomakh", [4]], ["Monomaniac One", [4]], ["Monoton", [4]], ["Monsieur La Doulaise", [4]], ["Montaga", [4]], ["Montagu Slab", ["1a7"]], ["MonteCarlo", [4]], ["Montez", [4]], ["Montserrat", ["1a9", "1a9i"]], ["Montserrat Alternates", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Montserrat Underline", ["1a9", "1a9i"]], ["Moo Lah Lah", [4]], ["Mooli", [4]], ["Moon Dance", [4]], ["Moul", [4]], ["Moulpali", [4]], ["Mountains of Christmas", [4, 7]], ["Mouse Memoirs", [4]], ["Mozilla Headline", ["2a7"]], ["Mozilla Text", ["2a7"]], ["Mr Bedfort", [4]], ["Mr Dafoe", [4]], ["Mr De Haviland", [4]], ["Mrs Saint Delafield", [4]], ["Mrs Sheppards", [4]], ["Ms Madi", [4]], ["Mukta", [2, 3, 4, 5, 6, 7, 8]], ["Mukta Mahee", [2, 3, 4, 5, 6, 7, 8]], ["Mukta Malar", [2, 3, 4, 5, 6, 7, 8]], ["Mukta Vaani", [2, 3, 4, 5, 6, 7, 8]], ["Mulish", ["2a10", "2a10i"]], ["Murecho", ["1a9"]], ["MuseoModerno", ["1a9", "1a9i"]], ["My Soul", [4]], ["Mynerve", [4]], ["Mystery Quest", [4]], ["NTR", [4]], ["Nabla", [4]], ["Namdhinggo", [4, 5, 6, 7, 8]], ["Nanum Brush Script", [4]], ["Nanum Gothic", [4, 7, 8]], ["Nanum Gothic Coding", [4, 7]], ["Nanum Myeongjo", [4, 7, 8]], ["Nanum Pen Script", [4]], ["Narnoor", [4, 5, 6, 7, 8]], ["Nata Sans", ["1a9"]], ["National Park", ["2a8"]], ["Neonderthaw", [4]], ["Nerko One", [4]], ["Neucha", [4]], ["Neuton", [2, 3, 4, 7, 8, "4i"]], ["New Amsterdam", [4]], ["New Rocker", [4]], ["New Tegomin", [4]], ["News Cycle", [4, 7]], ["Newsreader", ["2a8", "2a8i"]], ["Niconne", [4]], ["Niramit", [2, 3, 4, 5, 6, 7, "2i", "3i", "4i", "5i", "6i", "7i"]], ["Nixie One", [4]], ["Nobile", [4, 5, 7, "4i", "5i", "7i"]], ["Nokora", ["1a9"]], ["Norican", [4]], ["Nosifer", [4]], ["Notable", [4]], ["Nothing You Could Do", [4]], ["Noticia Text", [4, 7, "4i", "7i"]], ["Noto Color Emoji", [4]], ["Noto Emoji", ["3a7"]], ["Noto Kufi Arabic", ["1a9"]], ["Noto Music", [4]], ["Noto Naskh Arabic", ["4a7"]], ["Noto Nastaliq Urdu", ["4a7"]], ["Noto Rashi Hebrew", ["1a9"]], ["Noto Sans", ["1a9", "1a9i"]], ["Noto Sans Adlam", ["4a7"]], ["Noto Sans Adlam Unjoined", ["4a7"]], ["Noto Sans Anatolian Hieroglyphs", [4]], ["Noto Sans Arabic", ["1a9"]], ["Noto Sans Armenian", ["1a9"]], ["Noto Sans Avestan", [4]], ["Noto Sans Balinese", ["4a7"]], ["Noto Sans Bamum", ["4a7"]], ["Noto Sans Bassa Vah", ["4a7"]], ["Noto Sans Batak", [4]], ["Noto Sans Bengali", ["1a9"]], ["Noto Sans Bhaiksuki", [4]], ["Noto Sans Brahmi", [4]], ["Noto Sans Buginese", [4]], ["Noto Sans Buhid", [4]], ["Noto Sans Canadian Aboriginal", ["1a9"]], ["Noto Sans Carian", [4]], ["Noto Sans Caucasian Albanian", [4]], ["Noto Sans Chakma", [4]], ["Noto Sans Cham", ["1a9"]], ["Noto Sans Cherokee", ["1a9"]], ["Noto Sans Chorasmian", [4]], ["Noto Sans Coptic", [4]], ["Noto Sans Cuneiform", [4]], ["Noto Sans Cypriot", [4]], ["Noto Sans Cypro Minoan", [4]], ["Noto Sans Deseret", [4]], ["Noto Sans Devanagari", ["1a9"]], ["Noto Sans Display", ["1a9", "1a9i"]], ["Noto Sans Duployan", [4, 7]], ["Noto Sans Egyptian Hieroglyphs", [4]], ["Noto Sans Elbasan", [4]], ["Noto Sans Elymaic", [4]], ["Noto Sans Ethiopic", ["1a9"]], ["Noto Sans Georgian", ["1a9"]], ["Noto Sans Glagolitic", [4]], ["Noto Sans Gothic", [4]], ["Noto Sans Grantha", [4]], ["Noto Sans Gujarati", ["1a9"]], ["Noto Sans Gunjala Gondi", ["4a7"]], ["Noto Sans Gurmukhi", ["1a9"]], ["Noto Sans HK", ["1a9"]], ["Noto Sans Hanifi Rohingya", ["4a7"]], ["Noto Sans Hanunoo", [4]], ["Noto Sans Hatran", [4]], ["Noto Sans Hebrew", ["1a9"]], ["Noto Sans Imperial Aramaic", [4]], ["Noto Sans Indic Siyaq Numbers", [4]], ["Noto Sans Inscriptional Pahlavi", [4]], ["Noto Sans Inscriptional Parthian", [4]], ["Noto Sans JP", ["1a9"]], ["Noto Sans Javanese", ["4a7"]], ["Noto Sans KR", ["1a9"]], ["Noto Sans Kaithi", [4]], ["Noto Sans Kannada", ["1a9"]], ["Noto Sans Kawi", ["4a7"]], ["Noto Sans Kayah Li", ["4a7"]], ["Noto Sans Kharoshthi", [4]], ["Noto Sans Khmer", ["1a9"]], ["Noto Sans Khojki", [4]], ["Noto Sans Khudawadi", [4]], ["Noto Sans Lao", ["1a9"]], ["Noto Sans Lao Looped", ["1a9"]], ["Noto Sans Lepcha", [4]], ["Noto Sans Limbu", [4]], ["Noto Sans Linear A", [4]], ["Noto Sans Linear B", [4]], ["Noto Sans Lisu", ["4a7"]], ["Noto Sans Lycian", [4]], ["Noto Sans Lydian", [4]], ["Noto Sans Mahajani", [4]], ["Noto Sans Malayalam", ["1a9"]], ["Noto Sans Mandaic", [4]], ["Noto Sans Manichaean", [4]], ["Noto Sans Marchen", [4]], ["Noto Sans Masaram Gondi", [4]], ["Noto Sans Math", [4]], ["Noto Sans Mayan Numerals", [4]], ["Noto Sans Medefaidrin", ["4a7"]], ["Noto Sans Meetei Mayek", ["1a9"]], ["Noto Sans Mende Kikakui", [4]], ["Noto Sans Meroitic", [4]], ["Noto Sans Miao", [4]], ["Noto Sans Modi", [4]], ["Noto Sans Mongolian", [4]], ["Noto Sans Mono", ["1a9"]], ["Noto Sans Mro", [4]], ["Noto Sans Multani", [4]], ["Noto Sans Myanmar", ["1a9"]], ["Noto Sans NKo", [4]], ["Noto Sans NKo Unjoined", ["4a7"]], ["Noto Sans Nabataean", [4]], ["Noto Sans Nag Mundari", ["4a7"]], ["Noto Sans Nandinagari", [4]], ["Noto Sans New Tai Lue", ["4a7"]], ["Noto Sans Newa", [4]], ["Noto Sans Nushu", [4]], ["Noto Sans Ogham", [4]], ["Noto Sans Ol Chiki", ["4a7"]], ["Noto Sans Old Hungarian", [4]], ["Noto Sans Old Italic", [4]], ["Noto Sans Old North Arabian", [4]], ["Noto Sans Old Permic", [4]], ["Noto Sans Old Persian", [4]], ["Noto Sans Old Sogdian", [4]], ["Noto Sans Old South Arabian", [4]], ["Noto Sans Old Turkic", [4]], ["Noto Sans Oriya", ["1a9"]], ["Noto Sans Osage", [4]], ["Noto Sans Osmanya", [4]], ["Noto Sans Pahawh Hmong", [4]], ["Noto Sans Palmyrene", [4]], ["Noto Sans Pau Cin Hau", [4]], ["Noto Sans PhagsPa", [4]], ["Noto Sans Phoenician", [4]], ["Noto Sans Psalter Pahlavi", [4]], ["Noto Sans Rejang", [4]], ["Noto Sans Runic", [4]], ["Noto Sans SC", ["1a9"]], ["Noto Sans Samaritan", [4]], ["Noto Sans Saurashtra", [4]], ["Noto Sans Sharada", [4]], ["Noto Sans Shavian", [4]], ["Noto Sans Siddham", [4]], ["Noto Sans SignWriting", [4]], ["Noto Sans Sinhala", ["1a9"]], ["Noto Sans Sogdian", [4]], ["Noto Sans Sora Sompeng", ["4a7"]], ["Noto Sans Soyombo", [4]], ["Noto Sans Sundanese", ["4a7"]], ["Noto Sans Sunuwar", [4]], ["Noto Sans Syloti Nagri", [4]], ["Noto Sans Symbols", ["1a9"]], ["Noto Sans Symbols 2", [4]], ["Noto Sans Syriac", ["1a9"]], ["Noto Sans Syriac Eastern", ["1a9"]], ["Noto Sans Syriac Western", ["1a9"]], ["Noto Sans TC", ["1a9"]], ["Noto Sans Tagalog", [4]], ["Noto Sans Tagbanwa", [4]], ["Noto Sans Tai Le", [4]], ["Noto Sans Tai Tham", ["4a7"]], ["Noto Sans Tai Viet", [4]], ["Noto Sans Takri", [4]], ["Noto Sans Tamil", ["1a9"]], ["Noto Sans Tamil Supplement", [4]], ["Noto Sans Tangsa", ["4a7"]], ["Noto Sans Telugu", ["1a9"]], ["Noto Sans Thaana", ["1a9"]], ["Noto Sans Thai", ["1a9"]], ["Noto Sans Thai Looped", ["1a9"]], ["Noto Sans Tifinagh", [4]], ["Noto Sans Tirhuta", [4]], ["Noto Sans Ugaritic", [4]], ["Noto Sans Vai", [4]], ["Noto Sans Vithkuqi", ["4a7"]], ["Noto Sans Wancho", [4]], ["Noto Sans Warang Citi", [4]], ["Noto Sans Yi", [4]], ["Noto Sans Zanabazar Square", [4]], ["Noto Serif", ["1a9", "1a9i"]], ["Noto Serif Ahom", [4]], ["Noto Serif Armenian", ["1a9"]], ["Noto Serif Balinese", [4]], ["Noto Serif Bengali", ["1a9"]], ["Noto Serif Devanagari", ["1a9"]], ["Noto Serif Display", ["1a9", "1a9i"]], ["Noto Serif Dives Akuru", [4]], ["Noto Serif Dogra", [4]], ["Noto Serif Ethiopic", ["1a9"]], ["Noto Serif Georgian", ["1a9"]], ["Noto Serif Grantha", [4]], ["Noto Serif Gujarati", ["1a9"]], ["Noto Serif Gurmukhi", ["1a9"]], ["Noto Serif HK", ["2a9"]], ["Noto Serif Hebrew", ["1a9"]], ["Noto Serif Hentaigana", ["2a9"]], ["Noto Serif JP", ["2a9"]], ["Noto Serif KR", ["2a9"]], ["Noto Serif Kannada", ["1a9"]], ["Noto Serif Khitan Small Script", [4]], ["Noto Serif Khmer", ["1a9"]], ["Noto Serif Khojki", ["4a7"]], ["Noto Serif Lao", ["1a9"]], ["Noto Serif Makasar", [4]], ["Noto Serif Malayalam", ["1a9"]], ["Noto Serif Myanmar", [1, 2, 3, 4, 5, 6, 7, 8, 9]], ["Noto Serif NP Hmong", ["4a7"]], ["Noto Serif Old Uyghur", [4]], ["Noto Serif Oriya", ["4a7"]], ["Noto Serif Ottoman Siyaq", [4]], ["Noto Serif SC", ["2a9"]], ["Noto Serif Sinhala", ["1a9"]], ["Noto Serif TC", ["2a9"]], ["Noto Serif Tamil", ["1a9", "1a9i"]], ["Noto Serif Tangut", [4]], ["Noto Serif Telugu", ["1a9"]], ["Noto Serif Thai", ["1a9"]], ["Noto Serif Tibetan", ["1a9"]], ["Noto Serif Todhri", [4]], ["Noto Serif Toto", ["4a7"]], ["Noto Serif Vithkuqi", ["4a7"]], ["Noto Serif Yezidi", ["4a7"]], ["Noto Traditional Nushu", ["3a7"]], ["Noto Znamenny Musical Notation", [4]], ["Nova Cut", [4]], ["Nova Flat", [4]], ["Nova Mono", [4]], ["Nova Oval", [4]], ["Nova Round", [4]], ["Nova Script", [4]], ["Nova Slim", [4]], ["Nova Square", [4]], ["Numans", [4]], ["Nunito", ["2a10", "2a10i"]], ["Nunito Sans", ["2a10", "2a10i"]], ["Nuosu SIL", [4]], ["Odibee Sans", [4]], ["Odor Mean Chey", [4]], ["Offside", [4]], ["Oi", [4]], ["Ojuju", ["2a8"]], ["Old Standard TT", [4, 7, "4i"]], ["Oldenburg", [4]], ["Ole", [4]], ["Oleo Script", [4, 7]], ["Oleo Script Swash Caps", [4, 7]], ["Onest", ["1a9"]], ["Oooh Baby", [4]], ["Open Sans", ["3a8", "3a8i"]], ["Oranienbaum", [4]], ["Orbit", [4]], ["Orbitron", ["4a9"]], ["Oregano", [4, "4i"]], ["Orelega One", [4]], ["Orienta", [4]], ["Original Surfer", [4]], ["Oswald", ["2a7"]], ["Outfit", ["1a9"]], ["Over the Rainbow", [4]], ["Overlock", [4, 7, 9, "4i", "7i", "9i"]], ["Overlock SC", [4]], ["Overpass", ["1a9", "1a9i"]], ["Overpass Mono", ["3a7"]], ["Ovo", [4]], ["Oxanium", ["2a8"]], ["Oxygen", [3, 4, 7]], ["Oxygen Mono", [4]], ["PT Mono", [4]], ["PT Sans", [4, 7, "4i", "7i"]], ["PT Sans Caption", [4, 7]], ["PT Sans Narrow", [4, 7]], ["PT Serif", [4, 7, "4i", "7i"]], ["PT Serif Caption", [4, "4i"]], ["Pacifico", [4]], ["Padauk", [4, 7]], ["Padyakke Expanded One", [4]], ["Palanquin", [1, 2, 3, 4, 5, 6, 7]], ["Palanquin Dark", [4, 5, 6, 7]], ["Palette Mosaic", [4]], ["Pangolin", [4]], ["Paprika", [4]], ["Parastoo", ["4a7"]], ["Parisienne", [4]], ["Parkinsans", ["3a8"]], ["Passero One", [4]], ["Passion One", [4, 7, 9]], ["Passions Conflict", [4]], ["Pathway Extreme", ["1a9", "1a9i"]], ["Pathway Gothic One", [4]], ["Patrick Hand", [4]], ["Patrick Hand SC", [4]], ["Pattaya", [4]], ["Patua One", [4]], ["Pavanam", [4]], ["Paytone One", [4]], ["Peddana", [4]], ["Peralta", [4]], ["Permanent Marker", [4]], ["Petemoss", [4]], ["Petit Formal Script", [4]], ["Petrona", ["1a9", "1a9i"]], ["Phetsarath", [4, 7]], ["Philosopher", [4, 7, "4i", "7i"]], ["Phudu", ["3a9"]], ["Piazzolla", ["1a9", "1a9i"]], ["Piedra", [4]], ["Pinyon Script", [4]], ["Pirata One", [4]], ["Pixelify Sans", ["4a7"]], ["Plaster", [4]], ["Platypi", ["3a8", "3a8i"]], ["Play", [4, 7]], ["Playball", [4]], ["Playfair", ["3a9", "3a9i"]], ["Playfair Display", ["4a9", "4a9i"]], ["Playfair Display SC", [4, 7, 9, "4i", "7i", "9i"]], ["Playpen Sans", ["1a8"]], ["Playpen Sans Arabic", ["1a8"]], ["Playpen Sans Deva", ["1a8"]], ["Playpen Sans Hebrew", ["1a8"]], ["Playpen Sans Thai", ["1a8"]], ["Playwrite AR", ["1a4"]], ["Playwrite AR Guides", [4]], ["Playwrite AT", ["1a4", "1a4i"]], ["Playwrite AT Guides", [4, "4i"]], ["Playwrite AU NSW", ["1a4"]], ["Playwrite AU NSW Guides", [4]], ["Playwrite AU QLD", ["1a4"]], ["Playwrite AU QLD Guides", [4]], ["Playwrite AU SA", ["1a4"]], ["Playwrite AU SA Guides", [4]], ["Playwrite AU TAS", ["1a4"]], ["Playwrite AU TAS Guides", [4]], ["Playwrite AU VIC", ["1a4"]], ["Playwrite AU VIC Guides", [4]], ["Playwrite BE VLG", ["1a4"]], ["Playwrite BE VLG Guides", [4]], ["Playwrite BE WAL", ["1a4"]], ["Playwrite BE WAL Guides", [4]], ["Playwrite BR", ["1a4"]], ["Playwrite BR Guides", [4]], ["Playwrite CA", ["1a4"]], ["Playwrite CA Guides", [4]], ["Playwrite CL", ["1a4"]], ["Playwrite CL Guides", [4]], ["Playwrite CO", ["1a4"]], ["Playwrite CO Guides", [4]], ["Playwrite CU", ["1a4"]], ["Playwrite CU Guides", [4]], ["Playwrite CZ", ["1a4"]], ["Playwrite CZ Guides", [4]], ["Playwrite DE Grund", ["1a4"]], ["Playwrite DE Grund Guides", [4]], ["Playwrite DE LA", ["1a4"]], ["Playwrite DE LA Guides", [4]], ["Playwrite DE SAS", ["1a4"]], ["Playwrite DE SAS Guides", [4]], ["Playwrite DE VA", ["1a4"]], ["Playwrite DE VA Guides", [4]], ["Playwrite DK Loopet", ["1a4"]], ["Playwrite DK Loopet Guides", [4]], ["Playwrite DK Uloopet", ["1a4"]], ["Playwrite DK Uloopet Guides", [4]], ["Playwrite ES", ["1a4"]], ["Playwrite ES Deco", ["1a4"]], ["Playwrite ES Deco Guides", [4]], ["Playwrite ES Guides", [4]], ["Playwrite FR Moderne", ["1a4"]], ["Playwrite FR Moderne Guides", [4]], ["Playwrite FR Trad", ["1a4"]], ["Playwrite FR Trad Guides", [4]], ["Playwrite GB J", ["1a4", "1a4i"]], ["Playwrite GB J Guides", [4, "4i"]], ["Playwrite GB S", ["1a4", "1a4i"]], ["Playwrite GB S Guides", [4, "4i"]], ["Playwrite HR", ["1a4"]], ["Playwrite HR Guides", [4]], ["Playwrite HR Lijeva", ["1a4"]], ["Playwrite HR Lijeva Guides", [4]], ["Playwrite HU", ["1a4"]], ["Playwrite HU Guides", [4]], ["Playwrite ID", ["1a4"]], ["Playwrite ID Guides", [4]], ["Playwrite IE", ["1a4"]], ["Playwrite IE Guides", [4]], ["Playwrite IN", ["1a4"]], ["Playwrite IN Guides", [4]], ["Playwrite IS", ["1a4"]], ["Playwrite IS Guides", [4]], ["Playwrite IT Moderna", ["1a4"]], ["Playwrite IT Moderna Guides", [4]], ["Playwrite IT Trad", ["1a4"]], ["Playwrite IT Trad Guides", [4]], ["Playwrite MX", ["1a4"]], ["Playwrite MX Guides", [4]], ["Playwrite NG Modern", ["1a4"]], ["Playwrite NG Modern Guides", [4]], ["Playwrite NL", ["1a4"]], ["Playwrite NL Guides", [4]], ["Playwrite NO", ["1a4"]], ["Playwrite NO Guides", [4]], ["Playwrite NZ", ["1a4"]], ["Playwrite NZ Guides", [4]], ["Playwrite PE", ["1a4"]], ["Playwrite PE Guides", [4]], ["Playwrite PL", ["1a4"]], ["Playwrite PL Guides", [4]], ["Playwrite PT", ["1a4"]], ["Playwrite PT Guides", [4]], ["Playwrite RO", ["1a4"]], ["Playwrite RO Guides", [4]], ["Playwrite SK", ["1a4"]], ["Playwrite SK Guides", [4]], ["Playwrite TZ", ["1a4"]], ["Playwrite TZ Guides", [4]], ["Playwrite US Modern", ["1a4"]], ["Playwrite US Modern Guides", [4]], ["Playwrite US Trad", ["1a4"]], ["Playwrite US Trad Guides", [4]], ["Playwrite VN", ["1a4"]], ["Playwrite VN Guides", [4]], ["Playwrite ZA", ["1a4"]], ["Playwrite ZA Guides", [4]], ["Plus Jakarta Sans", ["2a8", "2a8i"]], ["Pochaevsk", [4]], ["Podkova", ["4a8"]], ["Poetsen One", [4]], ["Poiret One", [4]], ["Poller One", [4]], ["Poltawski Nowy", ["4a7", "4a7i"]], ["Poly", [4, "4i"]], ["Pompiere", [4]], ["Ponnala", [4]], ["Ponomar", [4]], ["Pontano Sans", ["3a7"]], ["Poor Story", [4]], ["Poppins", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Port Lligat Sans", [4]], ["Port Lligat Slab", [4]], ["Potta One", [4]], ["Pragati Narrow", [4, 7]], ["Praise", [4]], ["Prata", [4]], ["Preahvihear", [4]], ["Press Start 2P", [4]], ["Pridi", [2, 3, 4, 5, 6, 7]], ["Princess Sofia", [4]], ["Prociono", [4]], ["Prompt", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Prosto One", [4]], ["Protest Guerrilla", [4]], ["Protest Revolution", [4]], ["Protest Riot", [4]], ["Protest Strike", [4]], ["Proza Libre", [4, 5, 6, 7, 8, "4i", "5i", "6i", "7i", "8i"]], ["Public Sans", ["1a9", "1a9i"]], ["Puppies Play", [4]], ["Puritan", [4, 7, "4i", "7i"]], ["Purple Purse", [4]], ["Qahiri", [4]], ["Quando", [4]], ["Quantico", [4, 7, "4i", "7i"]], ["Quattrocento", [4, 7]], ["Quattrocento Sans", [4, 7, "4i", "7i"]], ["Questrial", [4]], ["Quicksand", ["3a7"]], ["Quintessential", [4]], ["Qwigley", [4]], ["Qwitcher Grypen", [4, 7]], ["REM", ["1a9", "1a9i"]], ["Racing Sans One", [4]], ["Radio Canada", ["3a7", "3a7i"]], ["Radio Canada Big", ["4a7", "4a7i"]], ["Radley", [4, "4i"]], ["Rajdhani", [3, 4, 5, 6, 7]], ["Rakkas", [4]], ["Raleway", ["1a9", "1a9i"]], ["Raleway Dots", [4]], ["Ramabhadra", [4]], ["Ramaraja", [4]], ["Rambla", [4, 7, "4i", "7i"]], ["Rammetto One", [4]], ["Rampart One", [4]], ["Ranchers", [4]], ["Rancho", [4]], ["Ranga", [4, 7]], ["Rasa", ["3a7", "3a7i"]], ["Rationale", [4]], ["Ravi Prakash", [4]], ["Readex Pro", ["2a7"]], ["Recursive", ["3a10"]], ["Red Hat Display", ["3a9", "3a9i"]], ["Red Hat Mono", ["3a7", "3a7i"]], ["Red Hat Text", ["3a7", "3a7i"]], ["Red Rose", ["3a7"]], ["Redacted", [4]], ["Redacted Script", [3, 4, 7]], ["Reddit Mono", ["2a9"]], ["Reddit Sans", ["2a9", "2a9i"]], ["Reddit Sans Condensed", ["2a9"]], ["Redressed", [4]], ["Reem Kufi", ["4a7"]], ["Reem Kufi Fun", ["4a7"]], ["Reem Kufi Ink", [4]], ["Reenie Beanie", [4]], ["Reggae One", [4]], ["Rethink Sans", ["4a8", "4a8i"]], ["Revalia", [4]], ["Rhodium Libre", [4]], ["Ribeye", [4]], ["Ribeye Marrow", [4]], ["Righteous", [4]], ["Risque", [4]], ["Road Rage", [4]], ["Roboto", ["1a9", "1a9i"]], ["Roboto Condensed", ["1a9", "1a9i"]], ["Roboto Flex", ["1a10"]], ["Roboto Mono", ["1a7", "1a7i"]], ["Roboto Serif", ["1a9", "1a9i"]], ["Roboto Slab", ["1a9"]], ["Rochester", [4]], ["Rock 3D", [4]], ["Rock Salt", [4]], ["RocknRoll One", [4]], ["Rokkitt", ["1a9", "1a9i"]], ["Romanesco", [4]], ["Ropa Sans", [4, "4i"]], ["Rosario", ["3a7", "3a7i"]], ["Rosarivo", [4, "4i"]], ["Rouge Script", [4]], ["Rowdies", [3, 4, 7]], ["Rozha One", [4]], ["Rubik", ["3a9", "3a9i"]], ["Rubik 80s Fade", [4]], ["Rubik Beastly", [4]], ["Rubik Broken Fax", [4]], ["Rubik Bubbles", [4]], ["Rubik Burned", [4]], ["Rubik Dirt", [4]], ["Rubik Distressed", [4]], ["Rubik Doodle Shadow", [4]], ["Rubik Doodle Triangles", [4]], ["Rubik Gemstones", [4]], ["Rubik Glitch", [4]], ["Rubik Glitch Pop", [4]], ["Rubik Iso", [4]], ["Rubik Lines", [4]], ["Rubik Maps", [4]], ["Rubik Marker Hatch", [4]], ["Rubik Maze", [4]], ["Rubik Microbe", [4]], ["Rubik Mono One", [4]], ["Rubik Moonrocks", [4]], ["Rubik Pixels", [4]], ["Rubik Puddles", [4]], ["Rubik Scribble", [4]], ["Rubik Spray Paint", [4]], ["Rubik Storm", [4]], ["Rubik Vinyl", [4]], ["Rubik Wet Paint", [4]], ["Ruda", ["4a9"]], ["Rufina", [4, 7]], ["Ruge Boogie", [4]], ["Ruluko", [4]], ["Rum Raisin", [4]], ["Ruslan Display", [4]], ["Russo One", [4]], ["Ruthie", [4]], ["Ruwudu", [4, 5, 6, 7]], ["Rye", [4]], ["STIX Two Text", ["4a7", "4a7i"]], ["SUSE", ["1a9", "1a9i"]], ["SUSE Mono", ["1a8", "1a8i"]], ["Sacramento", [4]], ["Sahitya", [4, 7]], ["Sail", [4]], ["Saira", ["1a9", "1a9i"]], ["Saira Condensed", [1, 2, 3, 4, 5, 6, 7, 8, 9]], ["Saira Extra Condensed", [1, 2, 3, 4, 5, 6, 7, 8, 9]], ["Saira Semi Condensed", [1, 2, 3, 4, 5, 6, 7, 8, 9]], ["Saira Stencil One", [4]], ["Salsa", [4]], ["Sanchez", [4, "4i"]], ["Sancreek", [4]], ["Sankofa Display", [4]], ["Sansation", [3, 4, 7, "3i", "4i", "7i"]], ["Sansita", [4, 7, 8, 9, "4i", "7i", "8i", "9i"]], ["Sansita Swashed", ["3a9"]], ["Sarabun", [1, 2, 3, 4, 5, 6, 7, 8, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i"]], ["Sarala", [4, 7]], ["Sarina", [4]], ["Sarpanch", [4, 5, 6, 7, 8, 9]], ["Sassy Frass", [4]], ["Satisfy", [4]], ["Savate", ["2a9", "2a9i"]], ["Sawarabi Gothic", [4]], ["Sawarabi Mincho", [4]], ["Scada", [4, 7, "4i", "7i"]], ["Scheherazade New", [4, 5, 6, 7]], ["Schibsted Grotesk", ["4a9", "4a9i"]], ["Schoolbell", [4]], ["Science Gothic", ["1a9"]], ["Scope One", [4]], ["Seaweed Script", [4]], ["Secular One", [4]], ["Sedan", [4, "4i"]], ["Sedan SC", [4]], ["Sedgwick Ave", [4]], ["Sedgwick Ave Display", [4]], ["Sekuya", [4]], ["Sen", ["4a8"]], ["Send Flowers", [4]], ["Sevillana", [4]], ["Seymour One", [4]], ["Shadows Into Light", [4]], ["Shadows Into Light Two", [4]], ["Shafarik", [4]], ["Shalimar", [4]], ["Shantell Sans", ["3a8", "3a8i"]], ["Shanti", [4]], ["Share", [4, 7, "4i", "7i"]], ["Share Tech", [4]], ["Share Tech Mono", [4]], ["Shippori Antique", [4]], ["Shippori Antique B1", [4]], ["Shippori Mincho", [4, 5, 6, 7, 8]], ["Shippori Mincho B1", [4, 5, 6, 7, 8]], ["Shizuru", [4]], ["Shojumaru", [4]], ["Short Stack", [4]], ["Shrikhand", [4]], ["Siemreap", [4]], ["Sigmar", [4]], ["Sigmar One", [4]], ["Signika", ["3a7"]], ["Signika Negative", ["3a7"]], ["Silkscreen", [4, 7]], ["Simonetta", [4, 9, "4i", "9i"]], ["Single Day", [4]], ["Sintony", [4, 7]], ["Sirin Stencil", [4]], ["Sirivennela", [4]], ["Six Caps", [4]], ["Sixtyfour", [4]], ["Sixtyfour Convergence", [4]], ["Skranji", [4, 7]], ["Slabo 13px", [4]], ["Slabo 27px", [4]], ["Slackey", [4]], ["Slackside One", [4]], ["Smokum", [4]], ["Smooch", [4]], ["Smooch Sans", ["1a9"]], ["Smythe", [4]], ["Sniglet", [4, 8]], ["Snippet", [4]], ["Snowburst One", [4]], ["Sofadi One", [4]], ["Sofia", [4]], ["Sofia Sans", ["1a10", "1a10i"]], ["Sofia Sans Condensed", ["1a10", "1a10i"]], ["Sofia Sans Extra Condensed", ["1a10", "1a10i"]], ["Sofia Sans Semi Condensed", ["1a10", "1a10i"]], ["Solitreo", [4]], ["Solway", [3, 4, 5, 7, 8]], ["Sometype Mono", ["4a7", "4a7i"]], ["Song Myung", [4]], ["Sono", ["2a8"]], ["Sonsie One", [4]], ["Sora", ["1a8"]], ["Sorts Mill Goudy", [4, "4i"]], ["Sour Gummy", ["1a9", "1a9i"]], ["Source Code Pro", ["2a9", "2a9i"]], ["Source Sans 3", ["2a9", "2a9i"]], ["Source Serif 4", ["2a9", "2a9i"]], ["Space Grotesk", ["3a7"]], ["Space Mono", [4, 7, "4i", "7i"]], ["Special Elite", [4]], ["Special Gothic", ["4a7"]], ["Special Gothic Condensed One", [4]], ["Special Gothic Expanded One", [4]], ["Spectral", [2, 3, 4, 5, 6, 7, 8, "2i", "3i", "4i", "5i", "6i", "7i", "8i"]], ["Spectral SC", [2, 3, 4, 5, 6, 7, 8, "2i", "3i", "4i", "5i", "6i", "7i", "8i"]], ["Spicy Rice", [4]], ["Spinnaker", [4]], ["Spirax", [4]], ["Splash", [4]], ["Spline Sans", ["3a7"]], ["Spline Sans Mono", ["3a7", "3a7i"]], ["Squada One", [4]], ["Square Peg", [4]], ["Sree Krushnadevaraya", [4]], ["Sriracha", [4]], ["Srisakdi", [4, 7]], ["Staatliches", [4]], ["Stack Sans Headline", ["2a7"]], ["Stack Sans Notch", ["2a7"]], ["Stack Sans Text", ["2a7"]], ["Stalemate", [4]], ["Stalinist One", [4]], ["Stardos Stencil", [4, 7]], ["Stick", [4]], ["Stick No Bills", ["2a8"]], ["Stint Ultra Condensed", [4]], ["Stint Ultra Expanded", [4]], ["Stoke", [3, 4]], ["Story Script", [4]], ["Strait", [4]], ["Style Script", [4]], ["Stylish", [4]], ["Sue Ellen Francisco", [4]], ["Suez One", [4]], ["Sulphur Point", [3, 4, 7]], ["Sumana", [4, 7]], ["Sunflower", [3, 5, 7]], ["Sunshiney", [4]], ["Supermercado One", [4]], ["Sura", [4, 7]], ["Suranna", [4]], ["Suravaram", [4]], ["Suwannaphum", [1, 3, 4, 7, 9]], ["Swanky and Moo Moo", [4]], ["Syncopate", [4, 7]], ["Syne", ["4a8"]], ["Syne Mono", [4]], ["Syne Tactile", [4]], ["TASA Explorer", ["4a8"]], ["TASA Orbiter", ["4a8"]], ["Tac One", [4]], ["Tagesschrift", [4]], ["Tai Heritage Pro", [4, 7]], ["Tajawal", [2, 3, 4, 5, 7, 8, 9]], ["Tangerine", [4, 7]], ["Tapestry", [4]], ["Taprom", [4]], ["Tauri", [4]], ["Taviraj", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Teachers", ["4a8", "4a8i"]], ["Teko", ["3a7"]], ["Tektur", ["4a9"]], ["Telex", [4]], ["Tenali Ramakrishna", [4]], ["Tenor Sans", [4]], ["Text Me One", [4]], ["Texturina", ["1a9", "1a9i"]], ["Thasadith", [4, 7, "4i", "7i"]], ["The Girl Next Door", [4]], ["The Nautigal", [4, 7]], ["Tienne", [4, 7, 9]], ["TikTok Sans", ["3a9"]], ["Tillana", [4, 5, 6, 7, 8]], ["Tilt Neon", [4]], ["Tilt Prism", [4]], ["Tilt Warp", [4]], ["Timmana", [4]], ["Tinos", [4, 7, "4i", "7i"]], ["Tiny5", [4]], ["Tiro Bangla", [4, "4i"]], ["Tiro Devanagari Hindi", [4, "4i"]], ["Tiro Devanagari Marathi", [4, "4i"]], ["Tiro Devanagari Sanskrit", [4, "4i"]], ["Tiro Gurmukhi", [4, "4i"]], ["Tiro Kannada", [4, "4i"]], ["Tiro Tamil", [4, "4i"]], ["Tiro Telugu", [4, "4i"]], ["Tirra", [4, 5, 6, 7, 8, 9]], ["Titan One", [4]], ["Titillium Web", [2, 3, 4, 6, 7, 9, "2i", "3i", "4i", "6i", "7i"]], ["Tomorrow", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Tourney", ["1a9", "1a9i"]], ["Trade Winds", [4]], ["Train One", [4]], ["Triodion", [4]], ["Trirong", [1, 2, 3, 4, 5, 6, 7, 8, 9, "1i", "2i", "3i", "4i", "5i", "6i", "7i", "8i", "9i"]], ["Trispace", ["1a8"]], ["Trocchi", [4]], ["Trochut", [4, 7, "4i"]], ["Truculenta", ["1a9"]], ["Trykker", [4]], ["Tsukimi Rounded", [3, 4, 5, 6, 7]], ["Tuffy", [4, 7, "4i", "7i"]], ["Tulpen One", [4]], ["Turret Road", [2, 3, 4, 5, 7, 8]], ["Twinkle Star", [4]], ["Ubuntu", [3, 4, 5, 7, "3i", "4i", "5i", "7i"]], ["Ubuntu Condensed", [4]], ["Ubuntu Mono", [4, 7, "4i", "7i"]], ["Ubuntu Sans", ["1a8", "1a8i"]], ["Ubuntu Sans Mono", ["4a7", "4a7i"]], ["Uchen", [4]], ["Ultra", [4]], ["Unbounded", ["2a9"]], ["Uncial Antiqua", [4]], ["Underdog", [4]], ["Unica One", [4]], ["UnifrakturCook", [7]], ["UnifrakturMaguntia", [4]], ["Unkempt", [4, 7]], ["Unlock", [4]], ["Unna", [4, 7, "4i", "7i"]], ["UoqMunThenKhung", [4]], ["Updock", [4]], ["Urbanist", ["1a9", "1a9i"]], ["VT323", [4]], ["Vampiro One", [4]], ["Varela", [4]], ["Varela Round", [4]], ["Varta", ["3a7"]], ["Vast Shadow", [4]], ["Vazirmatn", ["1a9"]], ["Vend Sans", ["3a7", "3a7i"]], ["Vesper Libre", [4, 5, 7, 9]], ["Viaoda Libre", [4]], ["Vibes", [4]], ["Vibur", [4]], ["Victor Mono", ["1a7", "1a7i"]], ["Vidaloka", [4]], ["Viga", [4]], ["Vina Sans", [4]], ["Voces", [4]], ["Volkhov", [4, 7, "4i", "7i"]], ["Vollkorn", ["4a9", "4a9i"]], ["Vollkorn SC", [4, 6, 7, 9]], ["Voltaire", [4]], ["Vujahday Script", [4]], ["WDXL Lubrifont JP N", [4]], ["WDXL Lubrifont SC", [4]], ["WDXL Lubrifont TC", [4]], ["Waiting for the Sunrise", [4]], ["Wallpoet", [4]], ["Walter Turncoat", [4]], ["Warnes", [4]], ["Water Brush", [4]], ["Waterfall", [4]], ["Wavefont", ["1a10"]], ["Wellfleet", [4]], ["Wendy One", [4]], ["Whisper", [4]], ["WindSong", [4, 5]], ["Winky Rough", ["3a9", "3a9i"]], ["Winky Sans", ["3a9", "3a9i"]], ["Wire One", [4]], ["Wittgenstein", ["4a9", "4a9i"]], ["Wix Madefor Display", ["4a8"]], ["Wix Madefor Text", ["4a8", "4a8i"]], ["Work Sans", ["1a9", "1a9i"]], ["Workbench", [4]], ["Xanh Mono", [4, "4i"]], ["Yaldevi", ["2a7"]], ["Yanone Kaffeesatz", ["2a7"]], ["Yantramanav", [1, 3, 4, 5, 7, 9]], ["Yarndings 12", [4]], ["Yarndings 12 Charted", [4]], ["Yarndings 20", [4]], ["Yarndings 20 Charted", [4]], ["Yatra One", [4]], ["Yellowtail", [4]], ["Yeon Sung", [4]], ["Yeseva One", [4]], ["Yesteryear", [4]], ["Yomogi", [4]], ["Young Serif", [4]], ["Yrsa", ["3a7", "3a7i"]], ["Ysabeau", ["1a10", "1a10i"]], ["Ysabeau Infant", ["1a10", "1a10i"]], ["Ysabeau Office", ["1a10", "1a10i"]], ["Ysabeau SC", ["1a10"]], ["Yuji Boku", [4]], ["Yuji Hentaigana Akari", [4]], ["Yuji Hentaigana Akebono", [4]], ["Yuji Mai", [4]], ["Yuji Syuku", [4]], ["Yusei Magic", [4]], ["ZCOOL KuaiLe", [4]], ["ZCOOL QingKe HuangYou", [4]], ["ZCOOL XiaoWei", [4]], ["Zain", [2, 3, 4, 7, 8, 9, "3i", "4i"]], ["Zalando Sans", ["2a9", "2a9i"]], ["Zalando Sans Expanded", ["2a9", "2a9i"]], ["Zalando Sans SemiExpanded", ["2a9", "2a9i"]], ["Zen Antique", [4]], ["Zen Antique Soft", [4]], ["Zen Dots", [4]], ["Zen Kaku Gothic Antique", [3, 4, 5, 7, 9]], ["Zen Kaku Gothic New", [3, 4, 5, 7, 9]], ["Zen Kurenaido", [4]], ["Zen Loop", [4, "4i"]], ["Zen Maru Gothic", [3, 4, 5, 7, 9]], ["Zen Old Mincho", [4, 5, 6, 7, 9]], ["Zen Tokyo Zoo", [4]], ["Zeyada", [4]], ["Zhi Mang Xing", [4]], ["Zilla Slab", [3, 4, 5, 6, 7, "3i", "4i", "5i", "6i", "7i"]], ["Zilla Slab Highlight", [4, 7]]];
    }
  });

  // node_modules/abslink/src/types.js
  var WireValueType;
  (function(WireValueType2) {
    WireValueType2["RAW"] = "RAW";
    WireValueType2["PROXY"] = "PROXY";
    WireValueType2["THROW"] = "THROW";
    WireValueType2["HANDLER"] = "HANDLER";
  })(WireValueType || (WireValueType = {}));
  var MessageType;
  (function(MessageType2) {
    MessageType2["GET"] = "GET";
    MessageType2["SET"] = "SET";
    MessageType2["APPLY"] = "APPLY";
    MessageType2["CONSTRUCT"] = "CONSTRUCT";
    MessageType2["RELEASE"] = "RELEASE";
  })(MessageType || (MessageType = {}));

  // node_modules/abslink/src/abslink.js
  var proxyMarker = /* @__PURE__ */ Symbol("Abslink.proxy");
  var releaseProxy = /* @__PURE__ */ Symbol("Abslink.releaseProxy");
  var finalizer = /* @__PURE__ */ Symbol("Abslink.finalizer");
  var throwMarker = /* @__PURE__ */ Symbol("Abslink.thrown");
  var isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
  var proxyTransferHandler = {
    canHandle: (val) => isObject(val) && proxyMarker in val,
    serialize(obj, ep) {
      const markerID = obj[proxyMarker];
      expose(obj, ep, markerID);
      return markerID;
    },
    deserialize(markerID, ep) {
      return wrap(ep, void 0, markerID);
    }
  };
  function closeEndPoint(endpoint) {
    if ("close" in endpoint && typeof endpoint.close === "function")
      endpoint.close();
  }
  var throwTransferHandler = {
    canHandle: (value) => isObject(value) && throwMarker in value,
    serialize({ value }) {
      let serialized;
      if (value instanceof Error) {
        serialized = {
          isError: true,
          value: {
            message: value.message,
            name: value.name,
            stack: value.stack
          }
        };
      } else {
        serialized = { isError: false, value };
      }
      return serialized;
    },
    deserialize(serialized) {
      if (serialized.isError) {
        throw Object.assign(new Error(serialized.value.message), serialized.value);
      }
      throw serialized.value;
    }
  };
  var transferHandlers = /* @__PURE__ */ new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler]
  ]);
  function filterPath(path, obj) {
    let parent = obj;
    const parentPath = path.slice(0, -1);
    for (const segment of parentPath) {
      if (Object.prototype.hasOwnProperty.call(parent, segment)) {
        parent = parent[segment];
      }
    }
    const lastSegment = path[path.length - 1];
    const RawValue = lastSegment ? parent[lastSegment] : parent;
    return { parent, RawValue, lastSegment };
  }
  function expose(obj, ep, rootMarkerID) {
    ep.on("message", function callback(data) {
      if (!data)
        return;
      const { id, type, path, markerID } = {
        path: [],
        ...data
      };
      if (markerID !== rootMarkerID)
        return;
      const argumentList = (data.argumentList ?? []).map((v) => fromWireValue(v, ep));
      let returnValue;
      try {
        const { parent, RawValue, lastSegment } = filterPath(path, obj);
        switch (type) {
          case MessageType.GET:
            returnValue = RawValue;
            break;
          case MessageType.SET:
            parent[lastSegment] = fromWireValue(data.value, ep);
            returnValue = true;
            break;
          case MessageType.APPLY:
            returnValue = RawValue.apply(parent, argumentList);
            break;
          case MessageType.CONSTRUCT:
            {
              const value = new RawValue(...argumentList);
              returnValue = proxy(value);
            }
            break;
          case MessageType.RELEASE:
            returnValue = void 0;
            break;
          default:
            return;
        }
      } catch (value) {
        returnValue = { value, [throwMarker]: 0 };
      }
      Promise.resolve(returnValue).catch((value) => {
        return { value, [throwMarker]: 0 };
      }).then((returnValue2) => {
        const wireValue = toWireValue(returnValue2, ep);
        ep.postMessage({ ...wireValue, id, markerID: rootMarkerID });
        if (type === MessageType.RELEASE) {
          ep.off("message", callback);
          if (finalizer in obj && typeof obj[finalizer] === "function") {
            obj[finalizer]();
          }
        }
      }).catch((_) => {
        const wireValue = toWireValue({
          value: new TypeError("Unserializable return value"),
          [throwMarker]: 0
        }, ep);
        ep.postMessage({ ...wireValue, id, markerID: rootMarkerID });
      });
    });
    return obj;
  }
  function wrap(ep, target, rootMarkerID) {
    const pendingListeners = /* @__PURE__ */ new Map();
    ep.on("message", (data) => {
      if (!data?.id) {
        return;
      }
      const resolver = pendingListeners.get(data.id);
      if (!resolver) {
        return;
      }
      try {
        resolver(data);
      } finally {
        pendingListeners.delete(data.id);
      }
    });
    return createProxy({ endpoint: ep, pendingListeners, nextRequestId: 1 }, [], target, rootMarkerID);
  }
  function throwIfProxyReleased(isReleased) {
    if (isReleased) {
      throw new Error("Proxy has been released and is not useable");
    }
  }
  async function releaseEndpoint(epWithPendingListeners) {
    await requestResponseMessage(epWithPendingListeners, { type: MessageType.RELEASE });
    closeEndPoint(epWithPendingListeners.endpoint);
  }
  var proxyCounter = /* @__PURE__ */ new WeakMap();
  var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((epWithPendingListeners) => {
    const newCount = (proxyCounter.get(epWithPendingListeners) ?? 0) - 1;
    proxyCounter.set(epWithPendingListeners, newCount);
    if (newCount === 0) {
      releaseEndpoint(epWithPendingListeners).finally(() => {
        epWithPendingListeners.pendingListeners.clear();
      });
    }
  });
  function registerProxy(proxy2, epWithPendingListeners) {
    const newCount = (proxyCounter.get(epWithPendingListeners) ?? 0) + 1;
    proxyCounter.set(epWithPendingListeners, newCount);
    if (proxyFinalizers) {
      proxyFinalizers.register(proxy2, epWithPendingListeners, proxy2);
    }
  }
  function unregisterProxy(proxy2) {
    if (proxyFinalizers) {
      proxyFinalizers.unregister(proxy2);
    }
  }
  function createProxy(epWithPendingListeners, path = [], target = function() {
  }, rootMarkerID) {
    let isProxyReleased = false;
    const propProxyCache = /* @__PURE__ */ new Map();
    const proxy2 = new Proxy(target, {
      get(_target, prop) {
        throwIfProxyReleased(isProxyReleased);
        if (prop === releaseProxy) {
          return async () => {
            for (const subProxy of propProxyCache.values()) {
              subProxy[releaseProxy]();
            }
            propProxyCache.clear();
            unregisterProxy(proxy2);
            releaseEndpoint(epWithPendingListeners).finally(() => {
              epWithPendingListeners.pendingListeners.clear();
            });
            isProxyReleased = true;
          };
        }
        if (prop === "then") {
          if (path.length === 0) {
            return { then: () => proxy2 };
          }
          const r = requestResponseMessage(epWithPendingListeners, {
            type: MessageType.GET,
            markerID: rootMarkerID,
            path: path.map((p) => p.toString())
          }).then((v) => fromWireValue(v, epWithPendingListeners.endpoint));
          return r.then.bind(r);
        }
        const cachedProxy = propProxyCache.get(prop);
        if (cachedProxy) {
          return cachedProxy;
        }
        const propProxy = createProxy(epWithPendingListeners, [...path, prop], void 0, rootMarkerID);
        propProxyCache.set(prop, propProxy);
        return propProxy;
      },
      set(_target, prop, rawValue) {
        throwIfProxyReleased(isProxyReleased);
        const value = toWireValue(rawValue, epWithPendingListeners.endpoint);
        return requestResponseMessage(epWithPendingListeners, {
          type: MessageType.SET,
          markerID: rootMarkerID,
          path: [...path, prop].map((p) => p.toString()),
          value
        }).then((v) => fromWireValue(v, epWithPendingListeners.endpoint));
      },
      apply(_target, _thisArg, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const last = path[path.length - 1];
        if (last === "bind") {
          return createProxy(epWithPendingListeners, path.slice(0, -1), void 0, rootMarkerID);
        }
        const argumentList = processArguments(rawArgumentList, epWithPendingListeners);
        return requestResponseMessage(epWithPendingListeners, {
          type: MessageType.APPLY,
          markerID: rootMarkerID,
          path: path.map((p) => p.toString()),
          argumentList
        }).then((v) => fromWireValue(v, epWithPendingListeners.endpoint));
      },
      construct(_target, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const argumentList = processArguments(rawArgumentList, epWithPendingListeners);
        return requestResponseMessage(epWithPendingListeners, {
          type: MessageType.CONSTRUCT,
          markerID: rootMarkerID,
          path: path.map((p) => p.toString()),
          argumentList
        }).then((v) => fromWireValue(v, epWithPendingListeners.endpoint));
      }
    });
    registerProxy(proxy2, epWithPendingListeners);
    return proxy2;
  }
  function processArguments(argumentList, epWithPendingListeners) {
    return argumentList.map((v) => toWireValue(v, epWithPendingListeners.endpoint));
  }
  function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: randomId() });
  }
  function toWireValue(value, ep) {
    for (const [name, handler] of transferHandlers) {
      if (handler.canHandle(value)) {
        const serializedValue = handler.serialize(value, ep);
        return {
          type: WireValueType.HANDLER,
          name,
          value: serializedValue
        };
      }
    }
    return {
      type: WireValueType.RAW,
      value
    };
  }
  function fromWireValue(value, ep) {
    switch (value.type) {
      case WireValueType.HANDLER:
        return transferHandlers.get(value.name).deserialize(value.value, ep);
      case WireValueType.RAW:
        return value.value;
    }
  }
  function requestResponseMessage(ep, msg) {
    return new Promise((resolve) => {
      const id = randomId();
      ep.pendingListeners.set(id, resolve);
      ep.endpoint.postMessage({ id, ...msg });
    });
  }
  function randomId() {
    return Math.trunc(Math.random() * Number.MAX_SAFE_INTEGER).toString();
  }

  // node_modules/abslink/adapters/w3c.js
  function createWrapper(channel, messageable) {
    const listeners = /* @__PURE__ */ new WeakMap();
    return {
      on(event, listener) {
        const unwrapped = (event2) => listener(event2.data);
        if ("addEventListener" in channel) {
          channel.addEventListener(event, unwrapped);
        } else if ("addListener" in channel) {
          channel.addListener(event, unwrapped);
        } else {
          channel.on(event, unwrapped);
        }
        listeners.set(listener, unwrapped);
      },
      off(event, listener) {
        const unwrapped = listeners.get(listener);
        if ("removeEventListener" in channel) {
          channel.removeEventListener(event, unwrapped);
        } else if ("removeListener" in channel) {
          channel.removeListener(event, unwrapped);
        } else {
          channel.off(event, unwrapped);
        }
        listeners.delete(listener);
      },
      postMessage(message) {
        messageable.postMessage(message);
      },
      [finalizer]: () => {
        channel.terminate?.();
        messageable.terminate?.();
      }
    };
  }
  function expose2(obj, channel = self, messageable = channel) {
    return expose(obj, createWrapper(channel, messageable));
  }

  // node_modules/lfa-ponyfill/index.js
  var SUPPORTS = "queryLocalFonts" in globalThis && globalThis.queryLocalFonts;
  var WEIGHT_MAP = {
    100: "Thin",
    200: "ExtraLight",
    300: "Light",
    400: "Regular",
    // Normal isn't used
    500: "Medium",
    600: "SemiBold",
    700: "Bold",
    800: "ExtraBold",
    900: "Black",
    1e3: "UltraBlack"
  };
  var FontData = class {
    family;
    fullName;
    postscriptName;
    style;
    #weight;
    #isItalic;
    /** @param {{family: string, weight: string, isItalic: boolean, weightName: string}} param0 */
    constructor({ family, weight, isItalic, weightName }) {
      this.family = family;
      this.#weight = weight;
      this.#isItalic = isItalic;
      const isRegular = weightName === "Regular";
      if (isRegular) {
        if (isItalic) {
          this.style = "Italic";
        } else {
          this.style = "Regular";
        }
      } else {
        this.style = weightName + (isItalic ? " Italic" : "");
      }
      if (this.style === "Regular") {
        this.fullName = family;
      } else {
        this.fullName = `${family} ${this.style}`;
      }
      this.postscriptName = this.fullName.replace(/ /g, "-");
    }
    async blob() {
      const response = await fetch(`https://fonts.googleapis.com/css2?family=${this.family}:${this.#isItalic ? "ital," : ""}wght@${this.#isItalic ? "1," : ""}${this.#weight}`);
      const css = await response.text();
      const matches = [
        /\/\* latin-ext \*\/[\s\S]+url\(([^)]+)\)/,
        // get first latin woff2 url from css
        /\/\* latin \*\/[\s\S]+url\(([^)]+)\)/,
        // TODO: what if some1 wants a japanse font but it includes latin? "Noto Sans JP"
        /url\(([^)]+)\)/
      ];
      for (const match of matches) {
        const url = css.match(match)?.[1];
        if (url) {
          const response2 = await fetch(url);
          if (response2.ok) return response2.blob();
        }
      }
      throw new Error("Failed to load font blob");
    }
  };
  function fromMetadata([family, sizes]) {
    const fontData = [];
    for (const _type of sizes) {
      const type = "" + _type;
      const isItalic = type.endsWith("i");
      const weight = type.replace("i", "");
      if (weight.includes("a")) {
        const [min, max] = weight.split("a").map((a2) => parseInt(a2) * 100);
        for (let i = min; i <= max; i += 100) {
          fontData.push(new FontData({ family, weight: `${min}..${max}`, isItalic, weightName: WEIGHT_MAP[i] }));
        }
      } else {
        fontData.push(new FontData({ family, weight: `${weight}00`, isItalic, weightName: WEIGHT_MAP[parseInt(weight) * 100] }));
      }
    }
    return fontData;
  }
  var fontCache = /* @__PURE__ */ new Map();
  async function getFontCache() {
    if (fontCache.size === 0) {
      const fonts = await Promise.resolve().then(() => (init_fonts(), fonts_exports));
      for (const font of fonts.default.flatMap((familyMetadata) => fromMetadata(familyMetadata))) {
        fontCache.set(font.postscriptName.toLowerCase().replace(/-/g, ""), font);
      }
    }
    return fontCache;
  }
  async function queryRemoteFonts({ postscriptNames } = {}) {
    const fontCache2 = await getFontCache();
    if (!postscriptNames) return [...fontCache2.values()];
    if (postscriptNames.length === 0) return [];
    return postscriptNames.reduce(
      (acc, postscriptName) => {
        const font = fontCache2.get(postscriptName.toLowerCase().replace(/regular$/, "").replace(/-reg$/, "").replace(/[- ]/g, ""));
        if (font) acc.push(font);
        return acc;
      },
      /** @type {FontData[]} */
      []
    );
  }

  // node_modules/jassub/dist/wasm/jassub-worker.js
  async function Module(moduleArg = {}) {
    var moduleRtn;
    var Module2 = moduleArg;
    var ENVIRONMENT_IS_WEB = true;
    var out = (...args) => console.log(...args);
    var err = (...args) => console.error(...args);
    function ready() {
      readyPromiseResolve?.(Module2);
      if (ENVIRONMENT_IS_PTHREAD) {
        startWorker();
      }
    }
    var ENVIRONMENT_IS_WORKER = !!globalThis.WorkerGlobalScope;
    var ENVIRONMENT_IS_PTHREAD = ENVIRONMENT_IS_WORKER && self.name?.startsWith("em-pthread");
    if (ENVIRONMENT_IS_WORKER) {
      _scriptName = self.location.href;
    }
    var _scriptName;
    const supportsGrowth = !!WebAssembly.Memory.prototype.toResizableBuffer;
    updateMemoryViews = () => {
      if (supportsGrowth && self.HEAPU8RAW)
        return;
      var b2 = supportsGrowth ? wasmMemory.toResizableBuffer() : wasmMemory.buffer;
      HEAP8 = new Int8Array(b2);
      HEAP16 = new Int16Array(b2);
      HEAPU8 = new Uint8Array(b2);
      HEAPU16 = new Uint16Array(b2);
      HEAP32 = new Int32Array(b2);
      HEAPU32 = new Uint32Array(b2);
      HEAPF32 = new Float32Array(b2);
      HEAPF64 = new Float64Array(b2);
      HEAP64 = new BigInt64Array(b2);
      HEAPU64 = new BigUint64Array(b2);
      self.HEAPU8RAW = new Uint8Array(b2);
      self.WASMMEMORY = wasmMemory;
    };
    if (self.name.startsWith("em-pthread")) {
      const url = self.name.split("-").slice(2).join("-");
      const _fetch2 = globalThis.fetch;
      globalThis.fetch = (_) => _fetch2(url);
    } else {
      if (moduleArg.__out)
        out = moduleArg.__out;
      if (moduleArg.__err)
        err = moduleArg.__err;
      const OriginalWorker = globalThis.Worker;
      globalThis.Worker = class extends OriginalWorker {
        constructor(scriptURL, options = {}) {
          super(scriptURL, { ...options, name: "em-pthread-" + moduleArg.__url });
        }
      };
    }
    if (!ENVIRONMENT_IS_PTHREAD) {
    }
    function abort(what) {
      throw what;
    }
    function growMemViews() {
      if (wasmMemory.buffer != HEAP8.buffer) {
        updateMemoryViews();
      }
    }
    var readyPromiseResolve, readyPromiseReject;
    var startWorker;
    if (ENVIRONMENT_IS_PTHREAD) {
      let handleMessage = function(e) {
        try {
          var msgData = e["data"];
          var cmd = msgData.cmd;
          if (cmd === "load") {
            let messageQueue = [];
            self.onmessage = (e2) => messageQueue.push(e2);
            startWorker = () => {
              postMessage({ cmd: "loaded" });
              for (let msg of messageQueue) {
                handleMessage(msg);
              }
              self.onmessage = handleMessage;
            };
            for (const handler of msgData.handlers) {
              if (!Module2[handler] || Module2[handler].proxy) {
                Module2[handler] = (...args) => {
                  postMessage({ cmd: "callHandler", handler, args });
                };
                if (handler == "print")
                  out = Module2[handler];
                if (handler == "printErr")
                  err = Module2[handler];
              }
            }
            wasmMemory = msgData.wasmMemory;
            updateMemoryViews();
            Module2["wasm"] = msgData.wasmModule;
            loadModule();
          } else if (cmd === "run") {
            establishStackSpace(msgData.pthread_ptr);
            __emscripten_thread_init(msgData.pthread_ptr, 0, 0, 1, 0, 0);
            PThread.threadInitTLS();
            __emscripten_thread_mailbox_await(msgData.pthread_ptr);
            if (!initializedJS) {
              __embind_initialize_bindings();
              initializedJS = true;
            }
            try {
              invokeEntryPoint(msgData.start_routine, msgData.arg);
            } catch (ex) {
              if (ex != "unwind") {
                throw ex;
              }
            }
          } else if (msgData.target === "setimmediate") {
          } else if (cmd === "checkMailbox") {
            if (initializedJS) {
              checkMailbox();
            }
          } else if (cmd) {
            err(`worker: received unknown command ${cmd}`);
            err(msgData);
          }
        } catch (ex) {
          __emscripten_thread_crashed();
          throw ex;
        }
      };
      var initializedJS = false;
      self.onunhandledrejection = (e) => {
        throw e.reason || e;
      };
      self.onmessage = handleMessage;
    }
    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
    var HEAP64, HEAPU64;
    var runtimeInitialized = false;
    function updateMemoryViews() {
      var b2 = wasmMemory.buffer;
      HEAP8 = new Int8Array(b2);
      HEAP16 = new Int16Array(b2);
      HEAPU8 = new Uint8Array(b2);
      HEAPU16 = new Uint16Array(b2);
      HEAP32 = new Int32Array(b2);
      HEAPU32 = new Uint32Array(b2);
      HEAPF32 = new Float32Array(b2);
      HEAPF64 = new Float64Array(b2);
      HEAP64 = new BigInt64Array(b2);
      HEAPU64 = new BigUint64Array(b2);
    }
    function initMemory() {
      if (ENVIRONMENT_IS_PTHREAD) {
        return;
      }
      {
        var INITIAL_MEMORY = 62914560;
        wasmMemory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / 65536, maximum: 32768, shared: true });
      }
      updateMemoryViews();
    }
    initMemory();
    var terminateWorker = (worker) => {
      worker.terminate();
      worker.onmessage = (e) => {
      };
    };
    var cleanupThread = (pthread_ptr) => {
      var worker = PThread.pthreads[pthread_ptr];
      PThread.returnWorkerToPool(worker);
    };
    var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        callbacks.shift()(Module2);
      }
    };
    var onPreRuns = [];
    var spawnThread = (threadParams) => {
      var worker = PThread.getNewWorker();
      if (!worker) {
        return 6;
      }
      PThread.runningWorkers.push(worker);
      PThread.pthreads[threadParams.pthread_ptr] = worker;
      worker.pthread_ptr = threadParams.pthread_ptr;
      var msg = { cmd: "run", start_routine: threadParams.startRoutine, arg: threadParams.arg, pthread_ptr: threadParams.pthread_ptr };
      worker.postMessage(msg, threadParams.transferList);
      return 0;
    };
    var stackSave = () => _emscripten_stack_get_current();
    var stackRestore = (val) => __emscripten_stack_restore(val);
    var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
    var proxyToMainThread = (funcIndex, emAsmAddr, sync, ...callArgs) => {
      var serializedNumCallArgs = callArgs.length * 2;
      var sp = stackSave();
      var args = stackAlloc(serializedNumCallArgs * 8);
      var b2 = args >> 3;
      for (var i = 0; i < callArgs.length; i++) {
        var arg = callArgs[i];
        if (typeof arg == "bigint") {
          (growMemViews(), HEAP64)[b2 + 2 * i] = 1n;
          (growMemViews(), HEAP64)[b2 + 2 * i + 1] = arg;
        } else {
          (growMemViews(), HEAP64)[b2 + 2 * i] = 0n;
          (growMemViews(), HEAPF64)[b2 + 2 * i + 1] = arg;
        }
      }
      var rtn = __emscripten_run_js_on_main_thread(funcIndex, emAsmAddr, serializedNumCallArgs, args, sync);
      stackRestore(sp);
      return rtn;
    };
    function _proc_exit(code) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(0, 0, 1, code);
      throw `exit(${code})`;
    }
    var _exit = _proc_exit;
    var PThread = { unusedWorkers: [], runningWorkers: [], tlsInitFunctions: [], pthreads: {}, init() {
      if (!ENVIRONMENT_IS_PTHREAD) {
        PThread.initMainThread();
      }
    }, initMainThread() {
      var pthreadPoolSize = !navigator.userAgent.toLowerCase().includes("firefox") && self.crossOriginIsolated ? Math.min(Math.max(0, navigator.hardwareConcurrency - 2), 8) : 0;
      while (pthreadPoolSize--) {
        PThread.allocateUnusedWorker();
      }
    }, terminateAllThreads: () => {
      for (var worker of PThread.runningWorkers) {
        terminateWorker(worker);
      }
      for (var worker of PThread.unusedWorkers) {
        terminateWorker(worker);
      }
      PThread.unusedWorkers = [];
      PThread.runningWorkers = [];
      PThread.pthreads = {};
    }, returnWorkerToPool: (worker) => {
      var pthread_ptr = worker.pthread_ptr;
      delete PThread.pthreads[pthread_ptr];
      PThread.unusedWorkers.push(worker);
      PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);
      worker.pthread_ptr = 0;
      __emscripten_thread_free_data(pthread_ptr);
    }, threadInitTLS() {
      PThread.tlsInitFunctions.forEach((f) => f());
    }, loadWasmModuleToWorker: (worker) => new Promise((onFinishedLoading) => {
      worker.onmessage = (e) => {
        var d2 = e["data"];
        var cmd = d2.cmd;
        if (d2.targetThread && d2.targetThread != _pthread_self()) {
          var targetWorker = PThread.pthreads[d2.targetThread];
          if (targetWorker) {
            targetWorker.postMessage(d2, d2.transferList);
          } else {
            err(`Internal error! Worker sent a message "${cmd}" to target pthread ${d2.targetThread}, but that thread no longer exists!`);
          }
          return;
        }
        if (cmd === "checkMailbox") {
          checkMailbox();
        } else if (cmd === "spawnThread") {
          spawnThread(d2);
        } else if (cmd === "cleanupThread") {
          callUserCallback(() => cleanupThread(d2.thread));
        } else if (cmd === "loaded") {
          worker.loaded = true;
          onFinishedLoading(worker);
        } else if (d2.target === "setimmediate") {
          worker.postMessage(d2);
        } else if (cmd === "callHandler") {
          Module2[d2.handler](...d2.args);
        } else if (cmd) {
          err(`worker sent an unknown command ${cmd}`);
        }
      };
      worker.onerror = (e) => {
        var message = "worker sent an error!";
        err(`${message} ${e.filename}:${e.lineno}: ${e.message}`);
        throw e;
      };
      var handlers = [];
      var knownHandlers = [];
      for (var handler of knownHandlers) {
        if (Module2.propertyIsEnumerable(handler)) {
          handlers.push(handler);
        }
      }
      worker.postMessage({ cmd: "load", handlers, wasmMemory, wasmModule });
    }), async loadWasmModuleToAllWorkers() {
      if (ENVIRONMENT_IS_PTHREAD) {
        return;
      }
      let pthreadPoolReady = Promise.all(PThread.unusedWorkers.map(PThread.loadWasmModuleToWorker));
      return pthreadPoolReady;
    }, allocateUnusedWorker() {
      var worker;
      worker = new Worker(new URL("jassub-worker.js", self.location.href), { type: "module", name: "em-pthread" });
      PThread.unusedWorkers.push(worker);
    }, getNewWorker() {
      if (PThread.unusedWorkers.length == 0) {
        PThread.allocateUnusedWorker();
        PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);
      }
      return PThread.unusedWorkers.pop();
    } };
    function establishStackSpace(pthread_ptr) {
      var stackHigh = (growMemViews(), HEAPU32)[pthread_ptr + 52 >> 2];
      var stackSize = (growMemViews(), HEAPU32)[pthread_ptr + 56 >> 2];
      var stackLow = stackHigh - stackSize;
      _emscripten_stack_set_limits(stackHigh, stackLow);
      stackRestore(stackHigh);
    }
    var wasmTableMirror = [];
    var getWasmTableEntry = (funcPtr) => {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      return func;
    };
    var invokeEntryPoint = (ptr, arg) => {
      var result = getWasmTableEntry(ptr)(arg);
      function finish(result2) {
        __emscripten_thread_exit(result2);
      }
      finish(result);
    };
    var wasmMemory;
    var UTF8Decoder = new TextDecoder();
    var findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => {
      var maxIdx = idx + maxBytesToRead;
      if (ignoreNul)
        return maxIdx;
      while (heapOrArray[idx] && !(idx >= maxIdx))
        ++idx;
      return idx;
    };
    var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => {
      if (!ptr)
        return "";
      var end = findStringEnd((growMemViews(), HEAPU8), ptr, maxBytesToRead, ignoreNul);
      return UTF8Decoder.decode((growMemViews(), HEAPU8).slice(ptr, end));
    };
    var ___assert_fail = (condition, filename, line, func) => abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
    function pthreadCreateProxied(pthread_ptr, attr, startRoutine, arg) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(1, 0, 1, pthread_ptr, attr, startRoutine, arg);
      return ___pthread_create_js(pthread_ptr, attr, startRoutine, arg);
    }
    var _emscripten_has_threading_support = () => !!globalThis.SharedArrayBuffer;
    var ___pthread_create_js = (pthread_ptr, attr, startRoutine, arg) => {
      if (!_emscripten_has_threading_support()) {
        return 6;
      }
      var transferList = [];
      var error = 0;
      if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) {
        return pthreadCreateProxied(pthread_ptr, attr, startRoutine, arg);
      }
      if (error)
        return error;
      var threadParams = { startRoutine, pthread_ptr, arg, transferList };
      if (ENVIRONMENT_IS_PTHREAD) {
        threadParams.cmd = "spawnThread";
        postMessage(threadParams, transferList);
        return 0;
      }
      return spawnThread(threadParams);
    };
    var SYSCALLS = { varargs: void 0, getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    } };
    function ___syscall_fcntl64(fd, cmd, varargs) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(2, 0, 1, fd, cmd, varargs);
      SYSCALLS.varargs = varargs;
      return 0;
    }
    function ___syscall_getdents64(fd, dirp, count) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(3, 0, 1, fd, dirp, count);
    }
    function ___syscall_ioctl(fd, op, varargs) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(4, 0, 1, fd, op, varargs);
      SYSCALLS.varargs = varargs;
      return 0;
    }
    function ___syscall_openat(dirfd, path, flags, varargs) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(5, 0, 1, dirfd, path, flags, varargs);
      SYSCALLS.varargs = varargs;
    }
    var __abort_js = () => abort("");
    var AsciiToString = (ptr) => {
      var str = "";
      while (1) {
        var ch = (growMemViews(), HEAPU8)[ptr++];
        if (!ch)
          return str;
        str += String.fromCharCode(ch);
      }
    };
    var awaitingDependencies = {};
    var registeredTypes = {};
    var typeDependencies = {};
    var BindingError = class BindingError extends Error {
      constructor(message) {
        super(message);
        this.name = "BindingError";
      }
    };
    var throwBindingError = (message) => {
      throw new BindingError(message);
    };
    function sharedRegisterType(rawType, registeredInstance, options = {}) {
      var name = registeredInstance.name;
      if (!rawType) {
        throwBindingError(`type "${name}" must have a positive integer typeid pointer`);
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
        if (options.ignoreDuplicateRegistrations) {
          return;
        } else {
          throwBindingError(`Cannot register type '${name}' twice`);
        }
      }
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
      if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach((cb) => cb());
      }
    }
    function registerType(rawType, registeredInstance, options = {}) {
      return sharedRegisterType(rawType, registeredInstance, options);
    }
    var integerReadValueFromPointer = (name, width, signed) => {
      switch (width) {
        case 1:
          return signed ? (pointer) => (growMemViews(), HEAP8)[pointer] : (pointer) => (growMemViews(), HEAPU8)[pointer];
        case 2:
          return signed ? (pointer) => (growMemViews(), HEAP16)[pointer >> 1] : (pointer) => (growMemViews(), HEAPU16)[pointer >> 1];
        case 4:
          return signed ? (pointer) => (growMemViews(), HEAP32)[pointer >> 2] : (pointer) => (growMemViews(), HEAPU32)[pointer >> 2];
        case 8:
          return signed ? (pointer) => (growMemViews(), HEAP64)[pointer >> 3] : (pointer) => (growMemViews(), HEAPU64)[pointer >> 3];
        default:
          throw new TypeError(`invalid integer width (${width}): ${name}`);
      }
    };
    var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {
      name = AsciiToString(name);
      const isUnsignedType = minRange === 0n;
      let fromWireType = (value) => value;
      if (isUnsignedType) {
        const bitSize = size * 8;
        fromWireType = (value) => BigInt.asUintN(bitSize, value);
        maxRange = fromWireType(maxRange);
      }
      registerType(primitiveType, { name, fromWireType, toWireType: (destructors, value) => {
        if (typeof value == "number") {
          value = BigInt(value);
        }
        return value;
      }, readValueFromPointer: integerReadValueFromPointer(name, size, !isUnsignedType), destructorFunction: null });
    };
    var __embind_register_bool = (rawType, name, trueValue, falseValue) => {
      name = AsciiToString(name);
      registerType(rawType, { name, fromWireType: function(wt) {
        return !!wt;
      }, toWireType: function(destructors, o) {
        return o ? trueValue : falseValue;
      }, readValueFromPointer: function(pointer) {
        return this.fromWireType((growMemViews(), HEAPU8)[pointer]);
      }, destructorFunction: null });
    };
    var shallowCopyInternalPointer = (o) => ({ count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType });
    var throwInstanceAlreadyDeleted = (obj) => {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name;
      }
      throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
    };
    var finalizationRegistry = false;
    var detachFinalizer = (handle) => {
    };
    var runDestructor = ($$) => {
      if ($$.smartPtr) {
        $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
        $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    };
    var releaseClassHandle = ($$) => {
      $$.count.value -= 1;
      var toDelete = 0 === $$.count.value;
      if (toDelete) {
        runDestructor($$);
      }
    };
    var attachFinalizer = (handle) => {
      if (!globalThis.FinalizationRegistry) {
        attachFinalizer = (handle2) => handle2;
        return handle;
      }
      finalizationRegistry = new FinalizationRegistry((info) => {
        releaseClassHandle(info.$$);
      });
      attachFinalizer = (handle2) => {
        var $$ = handle2.$$;
        var hasSmartPtr = !!$$.smartPtr;
        if (hasSmartPtr) {
          var info = { $$ };
          finalizationRegistry.register(handle2, info, handle2);
        }
        return handle2;
      };
      detachFinalizer = (handle2) => finalizationRegistry.unregister(handle2);
      return attachFinalizer(handle);
    };
    var deletionQueue = [];
    var flushPendingDeletes = () => {
      while (deletionQueue.length) {
        var obj = deletionQueue.pop();
        obj.$$.deleteScheduled = false;
        obj["delete"]();
      }
    };
    var delayFunction;
    var init_ClassHandle = () => {
      let proto = ClassHandle.prototype;
      Object.assign(proto, { isAliasOf(other) {
        if (!(this instanceof ClassHandle)) {
          return false;
        }
        if (!(other instanceof ClassHandle)) {
          return false;
        }
        var leftClass = this.$$.ptrType.registeredClass;
        var left = this.$$.ptr;
        other.$$ = other.$$;
        var rightClass = other.$$.ptrType.registeredClass;
        var right = other.$$.ptr;
        while (leftClass.baseClass) {
          left = leftClass.upcast(left);
          leftClass = leftClass.baseClass;
        }
        while (rightClass.baseClass) {
          right = rightClass.upcast(right);
          rightClass = rightClass.baseClass;
        }
        return leftClass === rightClass && left === right;
      }, clone() {
        if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
        }
        if (this.$$.preservePointerOnDelete) {
          this.$$.count.value += 1;
          return this;
        } else {
          var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
          clone.$$.count.value += 1;
          clone.$$.deleteScheduled = false;
          return clone;
        }
      }, delete() {
        if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
        }
        if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError("Object already scheduled for deletion");
        }
        detachFinalizer(this);
        releaseClassHandle(this.$$);
        if (!this.$$.preservePointerOnDelete) {
          this.$$.smartPtr = void 0;
          this.$$.ptr = void 0;
        }
      }, isDeleted() {
        return !this.$$.ptr;
      }, deleteLater() {
        if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
        }
        if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError("Object already scheduled for deletion");
        }
        deletionQueue.push(this);
        if (deletionQueue.length === 1 && delayFunction) {
          delayFunction(flushPendingDeletes);
        }
        this.$$.deleteScheduled = true;
        return this;
      } });
      const symbolDispose = Symbol.dispose;
      if (symbolDispose) {
        proto[symbolDispose] = proto["delete"];
      }
    };
    function ClassHandle() {
    }
    var createNamedFunction = (name, func) => Object.defineProperty(func, "name", { value: name });
    var registeredPointers = {};
    var ensureOverloadTable = (proto, methodName, humanName) => {
      if (void 0 === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        proto[methodName] = function(...args) {
          if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {
            throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);
          }
          return proto[methodName].overloadTable[args.length].apply(this, args);
        };
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    };
    var exposePublicSymbol = (name, value, numArguments) => {
      if (Module2.hasOwnProperty(name)) {
        if (void 0 === numArguments || void 0 !== Module2[name].overloadTable && void 0 !== Module2[name].overloadTable[numArguments]) {
          throwBindingError(`Cannot register public name '${name}' twice`);
        }
        ensureOverloadTable(Module2, name, name);
        if (Module2[name].overloadTable.hasOwnProperty(numArguments)) {
          throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
        }
        Module2[name].overloadTable[numArguments] = value;
      } else {
        Module2[name] = value;
        Module2[name].argCount = numArguments;
      }
    };
    var char_0 = 48;
    var char_9 = 57;
    var makeLegalFunctionName = (name) => {
      name = name.replace(/[^a-zA-Z0-9_]/g, "$");
      var f = name.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
        return `_${name}`;
      }
      return name;
    };
    function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
      this.name = name;
      this.constructor = constructor;
      this.instancePrototype = instancePrototype;
      this.rawDestructor = rawDestructor;
      this.baseClass = baseClass;
      this.getActualType = getActualType;
      this.upcast = upcast;
      this.downcast = downcast;
      this.pureVirtualFunctions = [];
    }
    var upcastPointer = (ptr, ptrClass, desiredClass) => {
      while (ptrClass !== desiredClass) {
        if (!ptrClass.upcast) {
          throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
        }
        ptr = ptrClass.upcast(ptr);
        ptrClass = ptrClass.baseClass;
      }
      return ptr;
    };
    var embindRepr = (v) => {
      if (v === null) {
        return "null";
      }
      var t = typeof v;
      if (t === "object" || t === "array" || t === "function") {
        return v.toString();
      } else {
        return "" + v;
      }
    };
    function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        return 0;
      }
      if (!handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
    function genericPointerToWireType(destructors, handle) {
      var ptr;
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        if (this.isSmartPointer) {
          ptr = this.rawConstructor();
          if (destructors !== null) {
            destructors.push(this.rawDestructor, ptr);
          }
          return ptr;
        } else {
          return 0;
        }
      }
      if (!handle || !handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      if (!this.isConst && handle.$$.ptrType.isConst) {
        throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      if (this.isSmartPointer) {
        if (void 0 === handle.$$.smartPtr) {
          throwBindingError("Passing raw pointer to smart pointer is illegal");
        }
        switch (this.sharingPolicy) {
          case 0:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
            }
            break;
          case 1:
            ptr = handle.$$.smartPtr;
            break;
          case 2:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              var clonedHandle = handle["clone"]();
              ptr = this.rawShare(ptr, Emval.toHandle(() => clonedHandle["delete"]()));
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
            }
            break;
          default:
            throwBindingError("Unsupporting sharing policy");
        }
      }
      return ptr;
    }
    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        return 0;
      }
      if (!handle.$$) {
        throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
      }
      if (!handle.$$.ptr) {
        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
      }
      if (handle.$$.ptrType.isConst) {
        throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
    function readPointer(pointer) {
      return this.fromWireType((growMemViews(), HEAPU32)[pointer >> 2]);
    }
    var downcastPointer = (ptr, ptrClass, desiredClass) => {
      if (ptrClass === desiredClass) {
        return ptr;
      }
      if (void 0 === desiredClass.baseClass) {
        return null;
      }
      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
      if (rv === null) {
        return null;
      }
      return desiredClass.downcast(rv);
    };
    var registeredInstances = {};
    var getBasestPointer = (class_, ptr) => {
      if (ptr === void 0) {
        throwBindingError("ptr should not be undefined");
      }
      while (class_.baseClass) {
        ptr = class_.upcast(ptr);
        class_ = class_.baseClass;
      }
      return ptr;
    };
    var getInheritedInstance = (class_, ptr) => {
      ptr = getBasestPointer(class_, ptr);
      return registeredInstances[ptr];
    };
    var InternalError = class InternalError extends Error {
      constructor(message) {
        super(message);
        this.name = "InternalError";
      }
    };
    var throwInternalError = (message) => {
      throw new InternalError(message);
    };
    var makeClassHandle = (prototype, record) => {
      if (!record.ptrType || !record.ptr) {
        throwInternalError("makeClassHandle requires ptr and ptrType");
      }
      var hasSmartPtrType = !!record.smartPtrType;
      var hasSmartPtr = !!record.smartPtr;
      if (hasSmartPtrType !== hasSmartPtr) {
        throwInternalError("Both smartPtrType and smartPtr must be specified");
      }
      record.count = { value: 1 };
      return attachFinalizer(Object.create(prototype, { $$: { value: record, writable: true } }));
    };
    function RegisteredPointer_fromWireType(ptr) {
      var rawPointer = this.getPointee(ptr);
      if (!rawPointer) {
        this.destructor(ptr);
        return null;
      }
      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
      if (void 0 !== registeredInstance) {
        if (0 === registeredInstance.$$.count.value) {
          registeredInstance.$$.ptr = rawPointer;
          registeredInstance.$$.smartPtr = ptr;
          return registeredInstance["clone"]();
        } else {
          var rv = registeredInstance["clone"]();
          this.destructor(ptr);
          return rv;
        }
      }
      function makeDefaultHandle() {
        if (this.isSmartPointer) {
          return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
        } else {
          return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
        }
      }
      var actualType = this.registeredClass.getActualType(rawPointer);
      var registeredPointerRecord = registeredPointers[actualType];
      if (!registeredPointerRecord) {
        return makeDefaultHandle.call(this);
      }
      var toType;
      if (this.isConst) {
        toType = registeredPointerRecord.constPointerType;
      } else {
        toType = registeredPointerRecord.pointerType;
      }
      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
      if (dp === null) {
        return makeDefaultHandle.call(this);
      }
      if (this.isSmartPointer) {
        return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
      } else {
        return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
      }
    }
    var init_RegisteredPointer = () => {
      Object.assign(RegisteredPointer.prototype, { getPointee(ptr) {
        if (this.rawGetPointee) {
          ptr = this.rawGetPointee(ptr);
        }
        return ptr;
      }, destructor(ptr) {
        this.rawDestructor?.(ptr);
      }, readValueFromPointer: readPointer, fromWireType: RegisteredPointer_fromWireType });
    };
    function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
      this.name = name;
      this.registeredClass = registeredClass;
      this.isReference = isReference;
      this.isConst = isConst;
      this.isSmartPointer = isSmartPointer;
      this.pointeeType = pointeeType;
      this.sharingPolicy = sharingPolicy;
      this.rawGetPointee = rawGetPointee;
      this.rawConstructor = rawConstructor;
      this.rawShare = rawShare;
      this.rawDestructor = rawDestructor;
      if (!isSmartPointer && registeredClass.baseClass === void 0) {
        if (isConst) {
          this.toWireType = constNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        } else {
          this.toWireType = nonConstNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        }
      } else {
        this.toWireType = genericPointerToWireType;
      }
    }
    var replacePublicSymbol = (name, value, numArguments) => {
      if (!Module2.hasOwnProperty(name)) {
        throwInternalError("Replacing nonexistent public symbol");
      }
      if (void 0 !== Module2[name].overloadTable && void 0 !== numArguments) {
        Module2[name].overloadTable[numArguments] = value;
      } else {
        Module2[name] = value;
        Module2[name].argCount = numArguments;
      }
    };
    var embind__requireFunction = (signature, rawFunction, isAsync = false) => {
      signature = AsciiToString(signature);
      function makeDynCaller() {
        var rtn = getWasmTableEntry(rawFunction);
        return rtn;
      }
      var fp = makeDynCaller();
      if (typeof fp != "function") {
        throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
      }
      return fp;
    };
    class UnboundTypeError extends Error {
    }
    var getTypeName = (type) => {
      var ptr = ___getTypeName(type);
      var rv = AsciiToString(ptr);
      _free(ptr);
      return rv;
    };
    var throwUnboundTypeError = (message, types) => {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
        if (seen[type]) {
          return;
        }
        if (registeredTypes[type]) {
          return;
        }
        if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);
          return;
        }
        unboundTypes.push(type);
        seen[type] = true;
      }
      types.forEach(visit);
      throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([", "]));
    };
    var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
      myTypes.forEach((type) => typeDependencies[type] = dependentTypes);
      function onComplete(typeConverters2) {
        var myTypeConverters = getTypeConverters(typeConverters2);
        if (myTypeConverters.length !== myTypes.length) {
          throwInternalError("Mismatched type converter count");
        }
        for (var i = 0; i < myTypes.length; ++i) {
          registerType(myTypes[i], myTypeConverters[i]);
        }
      }
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      for (let [i, dt] of dependentTypes.entries()) {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);
          if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }
          awaitingDependencies[dt].push(() => {
            typeConverters[i] = registeredTypes[dt];
            ++registered;
            if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      }
      if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    };
    var __embind_register_class = (rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) => {
      name = AsciiToString(name);
      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
      upcast &&= embind__requireFunction(upcastSignature, upcast);
      downcast &&= embind__requireFunction(downcastSignature, downcast);
      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
      var legalFunctionName = makeLegalFunctionName(name);
      exposePublicSymbol(legalFunctionName, function() {
        throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [baseClassRawType]);
      });
      whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], (base) => {
        base = base[0];
        var baseClass;
        var basePrototype;
        if (baseClassRawType) {
          baseClass = base.registeredClass;
          basePrototype = baseClass.instancePrototype;
        } else {
          basePrototype = ClassHandle.prototype;
        }
        var constructor = createNamedFunction(name, function(...args) {
          if (Object.getPrototypeOf(this) !== instancePrototype) {
            throw new BindingError(`Use 'new' to construct ${name}`);
          }
          if (void 0 === registeredClass.constructor_body) {
            throw new BindingError(`${name} has no accessible constructor`);
          }
          var body = registeredClass.constructor_body[args.length];
          if (void 0 === body) {
            throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
          }
          return body.apply(this, args);
        });
        var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
        constructor.prototype = instancePrototype;
        var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
        if (registeredClass.baseClass) {
          registeredClass.baseClass.__derivedClasses ??= [];
          registeredClass.baseClass.__derivedClasses.push(registeredClass);
        }
        var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
        var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false);
        var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false);
        registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
        replacePublicSymbol(legalFunctionName, constructor);
        return [referenceConverter, pointerConverter, constPointerConverter];
      });
    };
    var heap32VectorToArray = (count, firstElement) => {
      var array = [];
      for (var i = 0; i < count; i++) {
        array.push((growMemViews(), HEAPU32)[firstElement + i * 4 >> 2]);
      }
      return array;
    };
    var runDestructors = (destructors) => {
      while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
      }
    };
    function usesDestructorStack(argTypes) {
      for (var i = 1; i < argTypes.length; ++i) {
        if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
          return true;
        }
      }
      return false;
    }
    function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {
      var needsDestructorStack = usesDestructorStack(argTypes);
      var argCount = argTypes.length - 2;
      var argsList = [];
      var argsListWired = ["fn"];
      if (isClassMethodFunc) {
        argsListWired.push("thisWired");
      }
      for (var i = 0; i < argCount; ++i) {
        argsList.push(`arg${i}`);
        argsListWired.push(`arg${i}Wired`);
      }
      argsList = argsList.join(",");
      argsListWired = argsListWired.join(",");
      var invokerFnBody = `return function (${argsList}) {
`;
      if (needsDestructorStack) {
        invokerFnBody += "var destructors = [];\n";
      }
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["humanName", "throwBindingError", "invoker", "fn", "runDestructors", "fromRetWire", "toClassParamWire"];
      if (isClassMethodFunc) {
        invokerFnBody += `var thisWired = toClassParamWire(${dtorStack}, this);
`;
      }
      for (var i = 0; i < argCount; ++i) {
        var argName = `toArg${i}Wire`;
        invokerFnBody += `var arg${i}Wired = ${argName}(${dtorStack}, arg${i});
`;
        args1.push(argName);
      }
      invokerFnBody += (returns || isAsync ? "var rv = " : "") + `invoker(${argsListWired});
`;
      if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
      } else {
        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
          var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
          if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += `${paramName}_dtor(${paramName});
`;
            args1.push(`${paramName}_dtor`);
          }
        }
      }
      if (returns) {
        invokerFnBody += "var ret = fromRetWire(rv);\nreturn ret;\n";
      } else {
      }
      invokerFnBody += "}\n";
      return new Function(args1, invokerFnBody);
    }
    function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
      var argCount = argTypes.length;
      if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
      var isClassMethodFunc = argTypes[1] !== null && classType !== null;
      var needsDestructorStack = usesDestructorStack(argTypes);
      var returns = !argTypes[0].isVoid;
      var retType = argTypes[0];
      var instType = argTypes[1];
      var closureArgs = [humanName, throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, retType.fromWireType.bind(retType), instType?.toWireType.bind(instType)];
      for (var i = 2; i < argCount; ++i) {
        var argType = argTypes[i];
        closureArgs.push(argType.toWireType.bind(argType));
      }
      if (!needsDestructorStack) {
        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
          if (argTypes[i].destructorFunction !== null) {
            closureArgs.push(argTypes[i].destructorFunction);
          }
        }
      }
      let invokerFactory = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);
      var invokerFn = invokerFactory(...closureArgs);
      return createNamedFunction(humanName, invokerFn);
    }
    var __embind_register_class_constructor = (rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) => {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      invoker = embind__requireFunction(invokerSignature, invoker);
      whenDependentTypesAreResolved([], [rawClassType], (classType) => {
        classType = classType[0];
        var humanName = `constructor ${classType.name}`;
        if (void 0 === classType.registeredClass.constructor_body) {
          classType.registeredClass.constructor_body = [];
        }
        if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
          throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
        }
        classType.registeredClass.constructor_body[argCount - 1] = () => {
          throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
        };
        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
          argTypes.splice(1, 0, null);
          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
          return [];
        });
        return [];
      });
    };
    var getFunctionName = (signature) => {
      signature = signature.trim();
      const argsIndex = signature.indexOf("(");
      if (argsIndex === -1)
        return signature;
      return signature.slice(0, argsIndex);
    };
    var __embind_register_class_function = (rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync, isNonnullReturn) => {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = AsciiToString(methodName);
      methodName = getFunctionName(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker, isAsync);
      whenDependentTypesAreResolved([], [rawClassType], (classType) => {
        classType = classType[0];
        var humanName = `${classType.name}.${methodName}`;
        if (methodName.startsWith("@@")) {
          methodName = Symbol[methodName.substring(2)];
        }
        if (isPureVirtual) {
          classType.registeredClass.pureVirtualFunctions.push(methodName);
        }
        function unboundTypesHandler() {
          throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
        }
        var proto = classType.registeredClass.instancePrototype;
        var method = proto[methodName];
        if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
          unboundTypesHandler.argCount = argCount - 2;
          unboundTypesHandler.className = classType.name;
          proto[methodName] = unboundTypesHandler;
        } else {
          ensureOverloadTable(proto, methodName, humanName);
          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
        }
        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
          if (void 0 === proto[methodName].overloadTable) {
            memberFunction.argCount = argCount - 2;
            proto[methodName] = memberFunction;
          } else {
            proto[methodName].overloadTable[argCount - 2] = memberFunction;
          }
          return [];
        });
        return [];
      });
    };
    var validateThis = (this_, classType, humanName) => {
      if (!(this_ instanceof Object)) {
        throwBindingError(`${humanName} with invalid "this": ${this_}`);
      }
      if (!(this_ instanceof classType.registeredClass.constructor)) {
        throwBindingError(`${humanName} incompatible with "this" of type ${this_.constructor.name}`);
      }
      if (!this_.$$.ptr) {
        throwBindingError(`cannot call emscripten binding method ${humanName} on deleted object`);
      }
      return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
    };
    var __embind_register_class_property = (classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) => {
      fieldName = AsciiToString(fieldName);
      getter = embind__requireFunction(getterSignature, getter);
      whenDependentTypesAreResolved([], [classType], (classType2) => {
        classType2 = classType2[0];
        var humanName = `${classType2.name}.${fieldName}`;
        var desc = { get() {
          throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
        }, enumerable: true, configurable: true };
        if (setter) {
          desc.set = () => throwUnboundTypeError(`Cannot access ${humanName} due to unbound types`, [getterReturnType, setterArgumentType]);
        } else {
          desc.set = (v) => throwBindingError(humanName + " is a read-only property");
        }
        Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc);
        whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], (types) => {
          var getterReturnType2 = types[0];
          var desc2 = { get() {
            var ptr = validateThis(this, classType2, humanName + " getter");
            return getterReturnType2.fromWireType(getter(getterContext, ptr));
          }, enumerable: true };
          if (setter) {
            setter = embind__requireFunction(setterSignature, setter);
            var setterArgumentType2 = types[1];
            desc2.set = function(v) {
              var ptr = validateThis(this, classType2, humanName + " setter");
              var destructors = [];
              setter(setterContext, ptr, setterArgumentType2.toWireType(destructors, v));
              runDestructors(destructors);
            };
          }
          Object.defineProperty(classType2.registeredClass.instancePrototype, fieldName, desc2);
          return [];
        });
        return [];
      });
    };
    var emval_freelist = [];
    var emval_handles = [0, 1, , 1, null, 1, true, 1, false, 1];
    var __emval_decref = (handle) => {
      if (handle > 9 && 0 === --emval_handles[handle + 1]) {
        emval_handles[handle] = void 0;
        emval_freelist.push(handle);
      }
    };
    var Emval = { toValue: (handle) => {
      if (!handle) {
        throwBindingError(`Cannot use deleted val. handle = ${handle}`);
      }
      return emval_handles[handle];
    }, toHandle: (value) => {
      switch (value) {
        case void 0:
          return 2;
        case null:
          return 4;
        case true:
          return 6;
        case false:
          return 8;
        default: {
          const handle = emval_freelist.pop() || emval_handles.length;
          emval_handles[handle] = value;
          emval_handles[handle + 1] = 1;
          return handle;
        }
      }
    } };
    var EmValType = { name: "emscripten::val", fromWireType: (handle) => {
      var rv = Emval.toValue(handle);
      __emval_decref(handle);
      return rv;
    }, toWireType: (destructors, value) => Emval.toHandle(value), readValueFromPointer: readPointer, destructorFunction: null };
    var __embind_register_emval = (rawType) => registerType(rawType, EmValType);
    var floatReadValueFromPointer = (name, width) => {
      switch (width) {
        case 4:
          return function(pointer) {
            return this.fromWireType((growMemViews(), HEAPF32)[pointer >> 2]);
          };
        case 8:
          return function(pointer) {
            return this.fromWireType((growMemViews(), HEAPF64)[pointer >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${width}): ${name}`);
      }
    };
    var __embind_register_float = (rawType, name, size) => {
      name = AsciiToString(name);
      registerType(rawType, { name, fromWireType: (value) => value, toWireType: (destructors, value) => value, readValueFromPointer: floatReadValueFromPointer(name, size), destructorFunction: null });
    };
    var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {
      name = AsciiToString(name);
      const isUnsignedType = minRange === 0;
      let fromWireType = (value) => value;
      if (isUnsignedType) {
        var bitshift = 32 - 8 * size;
        fromWireType = (value) => value << bitshift >>> bitshift;
        maxRange = fromWireType(maxRange);
      }
      registerType(primitiveType, { name, fromWireType, toWireType: (destructors, value) => value, readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0), destructorFunction: null });
    };
    var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {
      var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, BigInt64Array, BigUint64Array];
      var TA = typeMapping[dataTypeIndex];
      function decodeMemoryView(handle) {
        var size = (growMemViews(), HEAPU32)[handle >> 2];
        var data = (growMemViews(), HEAPU32)[handle + 4 >> 2];
        return new TA((growMemViews(), HEAP8).buffer, data, size);
      }
      name = AsciiToString(name);
      registerType(rawType, { name, fromWireType: decodeMemoryView, readValueFromPointer: decodeMemoryView }, { ignoreDuplicateRegistrations: true });
    };
    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      if (!(maxBytesToWrite > 0))
        return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.codePointAt(i);
        if (u <= 127) {
          if (outIdx >= endIdx)
            break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx)
            break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx)
            break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx)
            break;
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
          i++;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, (growMemViews(), HEAPU8), outPtr, maxBytesToWrite);
    var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var c2 = str.charCodeAt(i);
        if (c2 <= 127) {
          len++;
        } else if (c2 <= 2047) {
          len += 2;
        } else if (c2 >= 55296 && c2 <= 57343) {
          len += 4;
          ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };
    var __embind_register_std_string = (rawType, name) => {
      name = AsciiToString(name);
      var stdStringIsUTF8 = true;
      registerType(rawType, { name, fromWireType(value) {
        var length = (growMemViews(), HEAPU32)[value >> 2];
        var payload = value + 4;
        var str;
        if (stdStringIsUTF8) {
          str = UTF8ToString(payload, length, true);
        } else {
          str = "";
          for (var i = 0; i < length; ++i) {
            str += String.fromCharCode((growMemViews(), HEAPU8)[payload + i]);
          }
        }
        _free(value);
        return str;
      }, toWireType(destructors, value) {
        if (value instanceof ArrayBuffer) {
          value = new Uint8Array(value);
        }
        var length;
        var valueIsOfTypeString = typeof value == "string";
        if (!(valueIsOfTypeString || ArrayBuffer.isView(value) && value.BYTES_PER_ELEMENT == 1)) {
          throwBindingError("Cannot pass non-string to std::string");
        }
        if (stdStringIsUTF8 && valueIsOfTypeString) {
          length = lengthBytesUTF8(value);
        } else {
          length = value.length;
        }
        var base = _malloc(4 + length + 1);
        var ptr = base + 4;
        (growMemViews(), HEAPU32)[base >> 2] = length;
        if (valueIsOfTypeString) {
          if (stdStringIsUTF8) {
            stringToUTF8(value, ptr, length + 1);
          } else {
            for (var i = 0; i < length; ++i) {
              var charCode = value.charCodeAt(i);
              if (charCode > 255) {
                _free(base);
                throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
              }
              (growMemViews(), HEAPU8)[ptr + i] = charCode;
            }
          }
        } else {
          (growMemViews(), HEAPU8).set(value, ptr);
        }
        if (destructors !== null) {
          destructors.push(_free, base);
        }
        return base;
      }, readValueFromPointer: readPointer, destructorFunction(ptr) {
        _free(ptr);
      } });
    };
    var UTF16Decoder = new TextDecoder("utf-16le");
    var UTF16ToString = (ptr, maxBytesToRead, ignoreNul) => {
      var idx = ptr >> 1;
      var endIdx = findStringEnd((growMemViews(), HEAPU16), idx, maxBytesToRead / 2, ignoreNul);
      return UTF16Decoder.decode((growMemViews(), HEAPU16).slice(idx, endIdx));
    };
    var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
      maxBytesToWrite ??= 2147483647;
      if (maxBytesToWrite < 2)
        return 0;
      maxBytesToWrite -= 2;
      var startPtr = outPtr;
      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
      for (var i = 0; i < numCharsToWrite; ++i) {
        var codeUnit = str.charCodeAt(i);
        (growMemViews(), HEAP16)[outPtr >> 1] = codeUnit;
        outPtr += 2;
      }
      (growMemViews(), HEAP16)[outPtr >> 1] = 0;
      return outPtr - startPtr;
    };
    var lengthBytesUTF16 = (str) => str.length * 2;
    var UTF32ToString = (ptr, maxBytesToRead, ignoreNul) => {
      var str = "";
      var startIdx = ptr >> 2;
      for (var i = 0; !(i >= maxBytesToRead / 4); i++) {
        var utf32 = (growMemViews(), HEAPU32)[startIdx + i];
        if (!utf32 && !ignoreNul)
          break;
        str += String.fromCodePoint(utf32);
      }
      return str;
    };
    var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
      maxBytesToWrite ??= 2147483647;
      if (maxBytesToWrite < 4)
        return 0;
      var startPtr = outPtr;
      var endPtr = startPtr + maxBytesToWrite - 4;
      for (var i = 0; i < str.length; ++i) {
        var codePoint = str.codePointAt(i);
        if (codePoint > 65535) {
          i++;
        }
        (growMemViews(), HEAP32)[outPtr >> 2] = codePoint;
        outPtr += 4;
        if (outPtr + 4 > endPtr)
          break;
      }
      (growMemViews(), HEAP32)[outPtr >> 2] = 0;
      return outPtr - startPtr;
    };
    var lengthBytesUTF32 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var codePoint = str.codePointAt(i);
        if (codePoint > 65535) {
          i++;
        }
        len += 4;
      }
      return len;
    };
    var __embind_register_std_wstring = (rawType, charSize, name) => {
      name = AsciiToString(name);
      var decodeString, encodeString, lengthBytesUTF;
      if (charSize === 2) {
        decodeString = UTF16ToString;
        encodeString = stringToUTF16;
        lengthBytesUTF = lengthBytesUTF16;
      } else {
        decodeString = UTF32ToString;
        encodeString = stringToUTF32;
        lengthBytesUTF = lengthBytesUTF32;
      }
      registerType(rawType, { name, fromWireType: (value) => {
        var length = (growMemViews(), HEAPU32)[value >> 2];
        var str = decodeString(value + 4, length * charSize, true);
        _free(value);
        return str;
      }, toWireType: (destructors, value) => {
        if (!(typeof value == "string")) {
          throwBindingError(`Cannot pass non-string to C++ string type ${name}`);
        }
        var length = lengthBytesUTF(value);
        var ptr = _malloc(4 + length + charSize);
        (growMemViews(), HEAPU32)[ptr >> 2] = length / charSize;
        encodeString(value, ptr + 4, length + charSize);
        if (destructors !== null) {
          destructors.push(_free, ptr);
        }
        return ptr;
      }, readValueFromPointer: readPointer, destructorFunction(ptr) {
        _free(ptr);
      } });
    };
    var __embind_register_void = (rawType, name) => {
      name = AsciiToString(name);
      registerType(rawType, { isVoid: true, name, fromWireType: () => void 0, toWireType: (destructors, o) => void 0 });
    };
    var __emscripten_init_main_thread_js = (tb) => {
      __emscripten_thread_init(tb, !ENVIRONMENT_IS_WORKER, 1, !ENVIRONMENT_IS_WEB, 65536, false);
      PThread.threadInitTLS();
    };
    var callUserCallback = (func) => {
      func();
    };
    var waitAsyncPolyfilled = !Atomics.waitAsync || globalThis.navigator?.userAgent && Number((navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./) || [])[2]) < 91;
    var __emscripten_thread_mailbox_await = (pthread_ptr) => {
      if (!waitAsyncPolyfilled) {
        var wait = Atomics.waitAsync((growMemViews(), HEAP32), pthread_ptr >> 2, pthread_ptr);
        wait.value.then(checkMailbox);
        var waitingAsync = pthread_ptr + 128;
        Atomics.store((growMemViews(), HEAP32), waitingAsync >> 2, 1);
      }
    };
    var checkMailbox = () => callUserCallback(() => {
      var pthread_ptr = _pthread_self();
      if (pthread_ptr) {
        __emscripten_thread_mailbox_await(pthread_ptr);
        __emscripten_check_mailbox();
      }
    });
    var __emscripten_notify_mailbox_postmessage = (targetThread, currThreadId) => {
      if (targetThread == currThreadId) {
        setTimeout(checkMailbox);
      } else if (ENVIRONMENT_IS_PTHREAD) {
        postMessage({ targetThread, cmd: "checkMailbox" });
      } else {
        var worker = PThread.pthreads[targetThread];
        if (!worker) {
          return;
        }
        worker.postMessage({ cmd: "checkMailbox" });
      }
    };
    var proxiedJSCallArgs = [];
    var __emscripten_receive_on_main_thread_js = (funcIndex, emAsmAddr, callingThread, numCallArgs, args) => {
      numCallArgs /= 2;
      proxiedJSCallArgs.length = numCallArgs;
      var b2 = args >> 3;
      for (var i = 0; i < numCallArgs; i++) {
        if ((growMemViews(), HEAP64)[b2 + 2 * i]) {
          proxiedJSCallArgs[i] = (growMemViews(), HEAP64)[b2 + 2 * i + 1];
        } else {
          proxiedJSCallArgs[i] = (growMemViews(), HEAPF64)[b2 + 2 * i + 1];
        }
      }
      var func = proxiedFunctionTable[funcIndex];
      PThread.currentProxiedOperationCallerThread = callingThread;
      var rtn = func(...proxiedJSCallArgs);
      PThread.currentProxiedOperationCallerThread = 0;
      return rtn;
    };
    var __emscripten_runtime_keepalive_clear = () => {
    };
    var __emscripten_thread_cleanup = (thread) => {
      if (!ENVIRONMENT_IS_PTHREAD)
        cleanupThread(thread);
      else
        postMessage({ cmd: "cleanupThread", thread });
    };
    var __emscripten_thread_set_strongref = (thread) => {
    };
    var __emscripten_throw_longjmp = () => {
      throw Infinity;
    };
    var timers = {};
    var _emscripten_get_now = () => performance.timeOrigin + performance.now();
    function __setitimer_js(which, timeout_ms) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(6, 0, 1, which, timeout_ms);
      if (timers[which]) {
        clearTimeout(timers[which].id);
        delete timers[which];
      }
      if (!timeout_ms)
        return 0;
      var id = setTimeout(() => {
        delete timers[which];
        callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
      }, timeout_ms);
      timers[which] = { id, timeout_ms };
      return 0;
    }
    var _emscripten_date_now = () => Date.now();
    var INT53_MAX = 9007199254740992;
    var INT53_MIN = -9007199254740992;
    var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
    var _emscripten_check_blocking_allowed = () => {
    };
    var _emscripten_err = (str) => err(UTF8ToString(str));
    var _emscripten_exit_with_live_runtime = () => {
      throw "unwind";
    };
    var getHeapMax = () => 2147483648;
    var _emscripten_get_heap_max = () => getHeapMax();
    var _emscripten_num_logical_cores = () => navigator["hardwareConcurrency"];
    var alignMemory = (size, alignment) => Math.ceil(size / alignment) * alignment;
    var growMemory = (size) => {
      var oldHeapSize = wasmMemory.buffer.byteLength;
      var pages = (size - oldHeapSize + 65535) / 65536 | 0;
      try {
        wasmMemory.grow(pages);
        updateMemoryViews();
        return 1;
      } catch (e) {
      }
    };
    var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = (growMemViews(), HEAPU8).length;
      requestedSize >>>= 0;
      if (requestedSize <= oldSize) {
        return false;
      }
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
        var replacement = growMemory(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    };
    var ENV = {};
    var getExecutableName = () => "./this.program";
    var getEnvStrings = () => {
      if (!getEnvStrings.strings) {
        var lang = (globalThis.navigator?.language ?? "C").replace("-", "_") + ".UTF-8";
        var env = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: lang, _: getExecutableName() };
        for (var x in ENV) {
          if (ENV[x] === void 0)
            delete env[x];
          else
            env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(`${x}=${env[x]}`);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    };
    function _environ_get(__environ, environ_buf) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(7, 0, 1, __environ, environ_buf);
      var bufSize = 0;
      var envp = 0;
      for (var string of getEnvStrings()) {
        var ptr = environ_buf + bufSize;
        (growMemViews(), HEAPU32)[__environ + envp >> 2] = ptr;
        bufSize += stringToUTF8(string, ptr, Infinity) + 1;
        envp += 4;
      }
      return 0;
    }
    function _environ_sizes_get(penviron_count, penviron_buf_size) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(8, 0, 1, penviron_count, penviron_buf_size);
      var strings = getEnvStrings();
      (growMemViews(), HEAPU32)[penviron_count >> 2] = strings.length;
      var bufSize = 0;
      for (var string of strings) {
        bufSize += lengthBytesUTF8(string) + 1;
      }
      (growMemViews(), HEAPU32)[penviron_buf_size >> 2] = bufSize;
      return 0;
    }
    function _fd_close(fd) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(9, 0, 1, fd);
      return 52;
    }
    function _fd_read(fd, iov, iovcnt, pnum) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(10, 0, 1, fd, iov, iovcnt, pnum);
      return 52;
    }
    function _fd_seek(fd, offset, whence, newOffset) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(11, 0, 1, fd, offset, whence, newOffset);
      offset = bigintToI53Checked(offset);
      return 70;
    }
    var printCharBuffers = [null, [], []];
    var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => {
      var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul);
      return UTF8Decoder.decode(heapOrArray.buffer ? heapOrArray.buffer instanceof ArrayBuffer ? heapOrArray.subarray(idx, endPtr) : heapOrArray.slice(idx, endPtr) : new Uint8Array(heapOrArray.slice(idx, endPtr)));
    };
    var printChar = (stream, curr) => {
      var buffer = printCharBuffers[stream];
      if (curr === 0 || curr === 10) {
        (stream === 1 ? out : err)(UTF8ArrayToString(buffer));
        buffer.length = 0;
      } else {
        buffer.push(curr);
      }
    };
    function _fd_write(fd, iov, iovcnt, pnum) {
      if (ENVIRONMENT_IS_PTHREAD)
        return proxyToMainThread(12, 0, 1, fd, iov, iovcnt, pnum);
      var num = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = (growMemViews(), HEAPU32)[iov >> 2];
        var len = (growMemViews(), HEAPU32)[iov + 4 >> 2];
        iov += 8;
        for (var j = 0; j < len; j++) {
          printChar(fd, (growMemViews(), HEAPU8)[ptr + j]);
        }
        num += len;
      }
      (growMemViews(), HEAPU32)[pnum >> 2] = num;
      return 0;
    }
    var initRandomFill = () => (view) => view.set(crypto.getRandomValues(new Uint8Array(view.byteLength)));
    var randomFill = (view) => {
      (randomFill = initRandomFill())(view);
    };
    var _random_get = (buffer, size) => {
      randomFill((growMemViews(), HEAPU8).subarray(buffer, buffer + size));
      return 0;
    };
    PThread.init();
    init_ClassHandle();
    init_RegisteredPointer();
    var proxiedFunctionTable = [_proc_exit, pthreadCreateProxied, ___syscall_fcntl64, ___syscall_getdents64, ___syscall_ioctl, ___syscall_openat, __setitimer_js, _environ_get, _environ_sizes_get, _fd_close, _fd_read, _fd_seek, _fd_write];
    var __ZdlPvm, _malloc, _free, _calloc, ___getTypeName, __embind_initialize_bindings, _pthread_self, _emscripten_builtin_free, __emscripten_tls_init, __emscripten_thread_init, __emscripten_thread_crashed, ___libc_free, _emscripten_builtin_malloc, ___libc_malloc, __emscripten_run_js_on_main_thread, __emscripten_thread_free_data, __emscripten_thread_exit, __emscripten_timeout, __emscripten_check_mailbox, __ZdaPv, __ZdaPvm, __ZdlPv, __Znaj, __ZnajSt11align_val_t, __Znwj, __ZnwjSt11align_val_t, ___libc_calloc, ___libc_realloc, _emscripten_builtin_calloc, _emscripten_builtin_realloc, _malloc_size, _malloc_usable_size, _reallocf, _setThrew, _emscripten_stack_set_limits, __emscripten_stack_restore, __emscripten_stack_alloc, _emscripten_stack_get_current, __indirect_function_table, wasmTable;
    function assignWasmExports(wasmExports) {
      __ZdlPvm = Module2["__ZdlPvm"] = wasmExports["Z"];
      _malloc = Module2["_malloc"] = wasmExports["_"];
      _free = wasmExports["$"];
      _calloc = Module2["_calloc"] = wasmExports["aa"];
      ___getTypeName = wasmExports["ba"];
      __embind_initialize_bindings = wasmExports["ca"];
      _pthread_self = wasmExports["da"];
      _emscripten_builtin_free = Module2["_emscripten_builtin_free"] = wasmExports["ea"];
      __emscripten_tls_init = wasmExports["fa"];
      __emscripten_thread_init = wasmExports["ha"];
      __emscripten_thread_crashed = wasmExports["ia"];
      ___libc_free = Module2["___libc_free"] = wasmExports["ja"];
      _emscripten_builtin_malloc = Module2["_emscripten_builtin_malloc"] = wasmExports["ka"];
      ___libc_malloc = Module2["___libc_malloc"] = wasmExports["la"];
      __emscripten_run_js_on_main_thread = wasmExports["ma"];
      __emscripten_thread_free_data = wasmExports["na"];
      __emscripten_thread_exit = wasmExports["oa"];
      __emscripten_timeout = wasmExports["pa"];
      __emscripten_check_mailbox = wasmExports["qa"];
      __ZdaPv = Module2["__ZdaPv"] = wasmExports["ra"];
      __ZdaPvm = Module2["__ZdaPvm"] = wasmExports["sa"];
      __ZdlPv = Module2["__ZdlPv"] = wasmExports["ta"];
      __Znaj = Module2["__Znaj"] = wasmExports["ua"];
      __ZnajSt11align_val_t = Module2["__ZnajSt11align_val_t"] = wasmExports["va"];
      __Znwj = Module2["__Znwj"] = wasmExports["wa"];
      __ZnwjSt11align_val_t = Module2["__ZnwjSt11align_val_t"] = wasmExports["xa"];
      ___libc_calloc = Module2["___libc_calloc"] = wasmExports["ya"];
      ___libc_realloc = Module2["___libc_realloc"] = wasmExports["za"];
      _emscripten_builtin_calloc = Module2["_emscripten_builtin_calloc"] = wasmExports["Aa"];
      _emscripten_builtin_realloc = Module2["_emscripten_builtin_realloc"] = wasmExports["Ba"];
      _malloc_size = Module2["_malloc_size"] = wasmExports["Ca"];
      _malloc_usable_size = Module2["_malloc_usable_size"] = wasmExports["Da"];
      _reallocf = Module2["_reallocf"] = wasmExports["Ea"];
      _setThrew = wasmExports["Fa"];
      _emscripten_stack_set_limits = wasmExports["Ga"];
      __emscripten_stack_restore = wasmExports["Ha"];
      __emscripten_stack_alloc = wasmExports["Ia"];
      _emscripten_stack_get_current = wasmExports["Ja"];
      __indirect_function_table = wasmTable = wasmExports["ga"];
    }
    var wasmImports;
    function assignWasmImports() {
      wasmImports = { b: ___assert_fail, K: ___pthread_create_js, p: ___syscall_fcntl64, J: ___syscall_getdents64, T: ___syscall_ioctl, q: ___syscall_openat, F: __abort_js, s: __embind_register_bigint, u: __embind_register_bool, k: __embind_register_class, U: __embind_register_class_constructor, d: __embind_register_class_function, c: __embind_register_class_property, X: __embind_register_emval, r: __embind_register_float, g: __embind_register_integer, e: __embind_register_memory_view, t: __embind_register_std_string, l: __embind_register_std_wstring, v: __embind_register_void, O: __emscripten_init_main_thread_js, G: __emscripten_notify_mailbox_postmessage, L: __emscripten_receive_on_main_thread_js, B: __emscripten_runtime_keepalive_clear, n: __emscripten_thread_cleanup, N: __emscripten_thread_mailbox_await, W: __emscripten_thread_set_strongref, z: __emscripten_throw_longjmp, C: __setitimer_js, o: _emscripten_check_blocking_allowed, f: _emscripten_date_now, m: _emscripten_err, V: _emscripten_exit_with_live_runtime, H: _emscripten_get_heap_max, h: _emscripten_get_now, I: _emscripten_num_logical_cores, D: _emscripten_resize_heap, P: _environ_get, Q: _environ_sizes_get, i: _exit, j: _fd_close, S: _fd_read, M: _fd_seek, R: _fd_write, y: invoke_iii, w: invoke_iiii, x: invoke_iiiii, a: wasmMemory, A: _proc_exit, E: _random_get };
    }
    function invoke_iii(index, a1, a2) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiii(index, a1, a2, a3, a4) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiii(index, a1, a2, a3) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function initRuntime(wasmExports) {
      runtimeInitialized = true;
      PThread.tlsInitFunctions.push(wasmExports["fa"]);
      if (ENVIRONMENT_IS_PTHREAD)
        return;
      wasmExports["Y"]();
    }
    var wasmModule;
    function loadModule() {
      assignWasmImports();
      var imports = { a: wasmImports };
      WebAssembly.instantiateStreaming(fetch("jassub-worker.wasm"), imports).then((output) => {
        var wasmExports = (output.instance || output).exports;
        wasmModule = output.module || Module2["wasm"];
        assignWasmExports(wasmExports);
        callRuntimeCallbacks(onPreRuns);
        initRuntime(wasmExports);
        PThread.loadWasmModuleToAllWorkers().then(ready);
      });
    }
    if (!ENVIRONMENT_IS_PTHREAD) {
      loadModule();
    }
    if (runtimeInitialized) {
      moduleRtn = Module2;
    } else {
      moduleRtn = new Promise((resolve, reject) => {
        readyPromiseResolve = resolve;
        readyPromiseReject = reject;
      });
    }
    ;
    return moduleRtn;
  }
  var jassub_worker_default = Module;
  var isPthread = globalThis.self?.name?.startsWith("em-pthread");
  isPthread && Module();

  // node_modules/jassub/dist/worker/renderers/2d-renderer.js
  var Canvas2DRenderer = class {
    canvas = null;
    ctx = null;
    bufferCanvas = new OffscreenCanvas(1, 1);
    bufferCtx = this.bufferCanvas.getContext("2d", {
      alpha: true,
      desynchronized: true,
      willReadFrequently: false
    });
    _scheduledResize;
    resizeCanvas(width, height) {
      if (width <= 0 || height <= 0)
        return;
      this._scheduledResize = { width, height };
    }
    setCanvas(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext("2d", {
        alpha: true,
        desynchronized: true,
        willReadFrequently: false
      });
      if (!this.ctx)
        throw new Error("Could not get 2D context");
    }
    setColorMatrix(subtitleColorSpace, videoColorSpace) {
    }
    // this is horribly inefficient, but it's a fallback for systems without a GPU, this is the least of their problems
    render(images, heap) {
      if (!this.ctx || !this.canvas)
        return;
      if (this._scheduledResize) {
        const { width, height } = this._scheduledResize;
        this._scheduledResize = void 0;
        this.canvas.width = width;
        this.canvas.height = height;
      } else {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
      for (const img of images) {
        if (img.w <= 0 || img.h <= 0)
          continue;
        const imageData = new ImageData(img.w, img.h);
        const pixels = new Uint32Array(imageData.data.buffer);
        const color = img.color << 8 & 16711680 | img.color >> 8 & 65280 | img.color >> 24 & 255;
        const alpha = (255 - (img.color & 255)) / 255;
        const stride = img.stride;
        const h = img.h;
        const w = img.w;
        for (let y = h + 1, pos = img.bitmap, res = 0; --y; pos += stride) {
          for (let z = 0; z < w; ++z, ++res) {
            const k = heap[pos + z];
            if (k !== 0)
              pixels[res] = alpha * k << 24 | color;
          }
        }
        this.bufferCanvas.width = w;
        this.bufferCanvas.height = h;
        this.bufferCtx.putImageData(imageData, 0, 0);
        this.ctx.drawImage(this.bufferCanvas, img.dst_x, img.dst_y);
      }
    }
    destroy() {
      this.ctx = null;
      this.canvas = null;
      this.bufferCtx = null;
      this.bufferCanvas = null;
    }
  };

  // node_modules/jassub/dist/worker/util.js
  var WEIGHT_MAP2 = [
    "thin",
    "extralight",
    "light",
    "regular",
    // Normal isn't used
    "medium",
    "semibold",
    "bold",
    "extrabold",
    "black",
    "ultrablack"
  ];
  var IS_FIREFOX = navigator.userAgent.toLowerCase().includes("firefox");
  var a = "BT601";
  var b = "BT709";
  var c = "SMPTE240M";
  var d = "FCC";
  var LIBASS_YCBCR_MAP = [null, a, null, a, a, b, b, c, c, d, d];
  function _applyKeys(input, output) {
    for (const v of Object.keys(input)) {
      output[v] = input[v];
    }
  }
  var _fetch = globalThis.fetch;
  async function fetchtext(url) {
    const res = await _fetch(url);
    return await res.text();
  }
  var THREAD_COUNT = !IS_FIREFOX && self.crossOriginIsolated ? Math.min(Math.max(1, navigator.hardwareConcurrency - 2), 8) : 1;
  var SUPPORTS_GROWTH = !!WebAssembly.Memory.prototype.toResizableBuffer;
  var SHOULD_REFERENCE_MEMORY = !IS_FIREFOX && (SUPPORTS_GROWTH || THREAD_COUNT > 1);
  var IDENTITY_MATRIX = new Float32Array([
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ]);
  var colorMatrixConversionMap = {
    BT601: {
      BT709: new Float32Array([
        1.0863,
        0.0965,
        -0.01411,
        -0.0723,
        0.8451,
        -0.0277,
        -0.0141,
        0.0584,
        1.0418
      ]),
      BT601: IDENTITY_MATRIX
    },
    BT709: {
      BT601: new Float32Array([
        0.9137,
        0.0784,
        79e-4,
        -0.1049,
        1.1722,
        -0.0671,
        96e-4,
        0.0322,
        0.9582
      ]),
      BT709: IDENTITY_MATRIX
    },
    FCC: {
      BT709: new Float32Array([
        1.0873,
        -0.0736,
        -0.0137,
        0.0974,
        0.8494,
        0.0531,
        -0.0127,
        -0.0251,
        1.0378
      ]),
      BT601: new Float32Array([
        1.001,
        -8e-4,
        -2e-4,
        9e-4,
        1.005,
        -6e-3,
        13e-4,
        27e-4,
        0.996
      ])
    },
    SMPTE240M: {
      BT709: new Float32Array([
        0.9993,
        6e-4,
        1e-4,
        -4e-4,
        0.9812,
        0.0192,
        -34e-4,
        -0.0114,
        1.0148
      ]),
      BT601: new Float32Array([
        0.913,
        0.0774,
        96e-4,
        -0.1051,
        1.1508,
        -0.0456,
        63e-4,
        0.0207,
        0.973
      ])
    }
  };

  // node_modules/jassub/dist/worker/renderers/webgl1-renderer.js
  var VERTEX_SHADER = (
    /* glsl */
    `
precision mediump float;

// Quad position attribute (0,0), (1,0), (0,1), (1,0), (1,1), (0,1)
attribute vec2 a_quadPos;

uniform vec2 u_resolution;

// Instance attributes
attribute vec4 a_destRect;  // x, y, w, h
attribute vec4 a_color;     // r, g, b, a
attribute float a_texLayer;

varying vec2 v_destXY;
varying vec4 v_color;
varying vec2 v_texSize;
varying float v_texLayer;
varying vec2 v_texCoord;

void main() {
  vec2 pixelPos = a_destRect.xy + a_quadPos * a_destRect.zw;
  vec2 clipPos = (pixelPos / u_resolution) * 2.0 - 1.0;
  clipPos.y = -clipPos.y;

  gl_Position = vec4(clipPos, 0.0, 1.0);
  v_destXY = a_destRect.xy;
  v_color = a_color;
  v_texSize = a_destRect.zw;
  v_texLayer = a_texLayer;
  v_texCoord = a_quadPos;
}
`
  );
  var FRAGMENT_SHADER = (
    /* glsl */
    `
precision mediump float;

uniform sampler2D u_tex;
uniform mat3 u_colorMatrix;
uniform vec2 u_resolution;
uniform vec2 u_texDimensions; // Actual texture dimensions

varying vec2 v_destXY;
varying vec4 v_color;
varying vec2 v_texSize;
varying float v_texLayer;
varying vec2 v_texCoord;

void main() {
  // v_texCoord is in 0-1 range for the quad
  // We need to map it to the actual image size within the texture
  // The image occupies only (v_texSize.x / u_texDimensions.x, v_texSize.y / u_texDimensions.y) of the texture
  vec2 normalizedImageSize = v_texSize / u_texDimensions;
  vec2 texCoord = v_texCoord * normalizedImageSize;

  // Sample texture (r channel contains mask)
  float mask = texture2D(u_tex, texCoord).r;

  // Apply color matrix conversion (identity if no conversion needed)
  vec3 correctedColor = u_colorMatrix * v_color.rgb;

  // libass color alpha: 0 = opaque, 255 = transparent (inverted)
  float colorAlpha = 1.0 - v_color.a;

  // Final alpha = colorAlpha * mask
  float a = colorAlpha * mask;

  // Premultiplied alpha output
  gl_FragColor = vec4(correctedColor * a, a);
}
`
  );
  var MAX_INSTANCES = 256;
  var WebGL1Renderer = class {
    canvas = null;
    gl = null;
    program = null;
    // Extensions
    instancedArraysExt = null;
    // Uniform locations
    u_resolution = null;
    u_tex = null;
    u_colorMatrix = null;
    u_texDimensions = null;
    // Attribute locations
    a_quadPos = -1;
    a_destRect = -1;
    a_color = -1;
    a_texLayer = -1;
    // Quad vertex buffer (shared for all instances)
    quadPosBuffer = null;
    // Instance attribute buffers
    instanceDestRectBuffer = null;
    instanceColorBuffer = null;
    instanceTexLayerBuffer = null;
    // Instance data arrays
    instanceDestRectData;
    instanceColorData;
    instanceTexLayerData;
    // Texture cache (since WebGL1 doesn't support texture arrays)
    textureCache = /* @__PURE__ */ new Map();
    textureWidth = 0;
    textureHeight = 0;
    colorMatrix = IDENTITY_MATRIX;
    constructor() {
      this.instanceDestRectData = new Float32Array(MAX_INSTANCES * 4);
      this.instanceColorData = new Float32Array(MAX_INSTANCES * 4);
      this.instanceTexLayerData = new Float32Array(MAX_INSTANCES);
    }
    _scheduledResize;
    resizeCanvas(width, height) {
      if (width <= 0 || height <= 0)
        return;
      this._scheduledResize = { width, height };
    }
    setCanvas(canvas) {
      this.canvas = canvas;
      this.gl = canvas.getContext("webgl", {
        alpha: true,
        premultipliedAlpha: true,
        antialias: false,
        depth: false,
        preserveDrawingBuffer: false,
        stencil: false,
        desynchronized: true,
        powerPreference: "high-performance"
      });
      if (!this.gl) {
        throw new Error("Could not get WebGL context");
      }
      this.instancedArraysExt = this.gl.getExtension("ANGLE_instanced_arrays");
      if (!this.instancedArraysExt) {
        throw new Error("ANGLE_instanced_arrays extension not supported");
      }
      const vertexShader = this.createShader(this.gl.VERTEX_SHADER, VERTEX_SHADER);
      const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, FRAGMENT_SHADER);
      if (!vertexShader || !fragmentShader) {
        throw new Error("Failed to create shaders");
      }
      this.program = this.gl.createProgram();
      this.gl.attachShader(this.program, vertexShader);
      this.gl.attachShader(this.program, fragmentShader);
      this.gl.linkProgram(this.program);
      if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
        const info = this.gl.getProgramInfoLog(this.program);
        throw new Error("Failed to link program: " + info);
      }
      this.u_resolution = this.gl.getUniformLocation(this.program, "u_resolution");
      this.u_tex = this.gl.getUniformLocation(this.program, "u_tex");
      this.u_colorMatrix = this.gl.getUniformLocation(this.program, "u_colorMatrix");
      this.u_texDimensions = this.gl.getUniformLocation(this.program, "u_texDimensions");
      this.a_quadPos = this.gl.getAttribLocation(this.program, "a_quadPos");
      this.a_destRect = this.gl.getAttribLocation(this.program, "a_destRect");
      this.a_color = this.gl.getAttribLocation(this.program, "a_color");
      this.a_texLayer = this.gl.getAttribLocation(this.program, "a_texLayer");
      this.quadPosBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadPosBuffer);
      const quadPositions = new Float32Array([
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        1,
        0,
        1
      ]);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, quadPositions, this.gl.STATIC_DRAW);
      this.instanceDestRectBuffer = this.gl.createBuffer();
      this.instanceColorBuffer = this.gl.createBuffer();
      this.instanceTexLayerBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadPosBuffer);
      this.gl.enableVertexAttribArray(this.a_quadPos);
      this.gl.vertexAttribPointer(this.a_quadPos, 2, this.gl.FLOAT, false, 0, 0);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceDestRectBuffer);
      this.gl.enableVertexAttribArray(this.a_destRect);
      this.gl.vertexAttribPointer(this.a_destRect, 4, this.gl.FLOAT, false, 0, 0);
      this.instancedArraysExt.vertexAttribDivisorANGLE(this.a_destRect, 1);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceColorBuffer);
      this.gl.enableVertexAttribArray(this.a_color);
      this.gl.vertexAttribPointer(this.a_color, 4, this.gl.FLOAT, false, 0, 0);
      this.instancedArraysExt.vertexAttribDivisorANGLE(this.a_color, 1);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceTexLayerBuffer);
      this.gl.enableVertexAttribArray(this.a_texLayer);
      this.gl.vertexAttribPointer(this.a_texLayer, 1, this.gl.FLOAT, false, 0, 0);
      this.instancedArraysExt.vertexAttribDivisorANGLE(this.a_texLayer, 1);
      this.gl.enable(this.gl.BLEND);
      this.gl.blendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
      this.gl.useProgram(this.program);
      this.gl.uniform1i(this.u_tex, 0);
      this.gl.uniformMatrix3fv(this.u_colorMatrix, false, this.colorMatrix);
      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
      this.gl.clearColor(0, 0, 0, 0);
      this.gl.activeTexture(this.gl.TEXTURE0);
    }
    createShader(type, source) {
      const shader = this.gl.createShader(type);
      this.gl.shaderSource(shader, source);
      this.gl.compileShader(shader);
      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        const info = this.gl.getShaderInfoLog(shader);
        console.log(info);
        this.gl.deleteShader(shader);
        return null;
      }
      return shader;
    }
    // Set the color matrix for color space conversion.
    // Pass null or undefined to use identity (no conversion).
    setColorMatrix(subtitleColorSpace, videoColorSpace) {
      this.colorMatrix = (subtitleColorSpace && videoColorSpace && colorMatrixConversionMap[subtitleColorSpace]?.[videoColorSpace]) ?? IDENTITY_MATRIX;
      if (this.gl && this.u_colorMatrix && this.program) {
        this.gl.useProgram(this.program);
        this.gl.uniformMatrix3fv(this.u_colorMatrix, false, this.colorMatrix);
      }
    }
    createTexture(width, height) {
      const texture = this.gl.createTexture();
      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, width, height, 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, null);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
      return texture;
    }
    render(images, heap) {
      if (!this.gl || !this.program || !this.instancedArraysExt)
        return;
      if (this._scheduledResize) {
        const { width, height } = this._scheduledResize;
        this._scheduledResize = void 0;
        this.canvas.width = width;
        this.canvas.height = height;
        this.gl.viewport(0, 0, width, height);
        this.gl.uniform2f(this.u_resolution, width, height);
      } else {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      }
      let maxW = this.textureWidth;
      let maxH = this.textureHeight;
      const validImages = [];
      for (const img of images) {
        if (img.w <= 0 || img.h <= 0)
          continue;
        validImages.push(img);
        if (img.w > maxW)
          maxW = img.w;
        if (img.h > maxH)
          maxH = img.h;
      }
      if (validImages.length === 0)
        return;
      if (maxW > this.textureWidth || maxH > this.textureHeight) {
        this.textureWidth = maxW;
        this.textureHeight = maxH;
        for (const texture of this.textureCache.values()) {
          this.gl.deleteTexture(texture);
        }
        this.textureCache.clear();
      }
      for (let i = 0; i < validImages.length; i++) {
        const img = validImages[i];
        let texture = this.textureCache.get(i);
        if (!texture) {
          texture = this.createTexture(this.textureWidth, this.textureHeight);
          this.textureCache.set(i, texture);
        }
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        const sourceView = new Uint8Array(heap.buffer, img.bitmap, img.stride * img.h);
        const tightData = new Uint8Array(img.w * img.h);
        for (let y = 0; y < img.h; y++) {
          const srcOffset = y * img.stride;
          const dstOffset = y * img.w;
          tightData.set(sourceView.subarray(srcOffset, srcOffset + img.w), dstOffset);
        }
        this.gl.texSubImage2D(
          this.gl.TEXTURE_2D,
          0,
          0,
          0,
          // x, y offset
          img.w,
          img.h,
          this.gl.LUMINANCE,
          this.gl.UNSIGNED_BYTE,
          tightData
        );
        this.instanceDestRectData[0] = img.dst_x;
        this.instanceDestRectData[1] = img.dst_y;
        this.instanceDestRectData[2] = img.w;
        this.instanceDestRectData[3] = img.h;
        this.instanceColorData[0] = (img.color >>> 24 & 255) / 255;
        this.instanceColorData[1] = (img.color >>> 16 & 255) / 255;
        this.instanceColorData[2] = (img.color >>> 8 & 255) / 255;
        this.instanceColorData[3] = (img.color & 255) / 255;
        this.instanceTexLayerData[0] = 0;
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceDestRectBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.instanceDestRectData.subarray(0, 4), this.gl.DYNAMIC_DRAW);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceColorBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.instanceColorData.subarray(0, 4), this.gl.DYNAMIC_DRAW);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceTexLayerBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.instanceTexLayerData.subarray(0, 1), this.gl.DYNAMIC_DRAW);
        this.gl.uniform2f(this.u_texDimensions, this.textureWidth, this.textureHeight);
        this.instancedArraysExt.drawArraysInstancedANGLE(this.gl.TRIANGLES, 0, 6, 1);
      }
    }
    destroy() {
      if (this.gl) {
        for (const texture of this.textureCache.values()) {
          this.gl.deleteTexture(texture);
        }
        this.textureCache.clear();
        if (this.quadPosBuffer) {
          this.gl.deleteBuffer(this.quadPosBuffer);
          this.quadPosBuffer = null;
        }
        if (this.instanceDestRectBuffer) {
          this.gl.deleteBuffer(this.instanceDestRectBuffer);
          this.instanceDestRectBuffer = null;
        }
        if (this.instanceColorBuffer) {
          this.gl.deleteBuffer(this.instanceColorBuffer);
          this.instanceColorBuffer = null;
        }
        if (this.instanceTexLayerBuffer) {
          this.gl.deleteBuffer(this.instanceTexLayerBuffer);
          this.instanceTexLayerBuffer = null;
        }
        if (this.program) {
          this.gl.deleteProgram(this.program);
          this.program = null;
        }
        this.gl = null;
      }
    }
  };

  // node_modules/jassub/dist/worker/renderers/webgl2-renderer.js
  var VERTEX_SHADER2 = (
    /* glsl */
    `#version 300 es
precision mediump float;

const vec2 QUAD_POSITIONS[6] = vec2[6](
  vec2(0.0, 0.0),
  vec2(1.0, 0.0),
  vec2(0.0, 1.0),
  vec2(1.0, 0.0),
  vec2(1.0, 1.0),
  vec2(0.0, 1.0)
);

uniform vec2 u_resolution;

// Instance attributes
in vec4 a_destRect;  // x, y, w, h
in vec4 a_color;     // r, g, b, a
in float a_texLayer;

flat out vec2 v_destXY;
flat out vec4 v_color;
flat out vec2 v_texSize;
flat out float v_texLayer;

void main() {
  vec2 quadPos = QUAD_POSITIONS[gl_VertexID];
  vec2 pixelPos = a_destRect.xy + quadPos * a_destRect.zw;
  vec2 clipPos = (pixelPos / u_resolution) * 2.0 - 1.0;
  clipPos.y = -clipPos.y;

  gl_Position = vec4(clipPos, 0.0, 1.0);
  v_destXY = a_destRect.xy;
  v_color = a_color;
  v_texSize = a_destRect.zw;
  v_texLayer = a_texLayer;
}
`
  );
  var FRAGMENT_SHADER2 = (
    /* glsl */
    `#version 300 es
precision mediump float;
precision mediump sampler2DArray;

uniform sampler2DArray u_texArray;
uniform mat3 u_colorMatrix;
uniform vec2 u_resolution;

flat in vec2 v_destXY;
flat in vec4 v_color;
flat in vec2 v_texSize;
flat in float v_texLayer;

out vec4 fragColor;

void main() {
  // Flip Y: WebGL's gl_FragCoord.y is 0 at bottom, but destXY.y is from top
  vec2 fragPos = vec2(gl_FragCoord.x, u_resolution.y - gl_FragCoord.y);

  // Calculate local position within the quad (screen coords)
  vec2 localPos = fragPos - v_destXY;

  // Convert to integer texel coordinates for texelFetch
  ivec2 texCoord = ivec2(floor(localPos));

  // Bounds check (prevents out-of-bounds access)
  ivec2 texSizeI = ivec2(v_texSize);
  if (texCoord.x < 0 || texCoord.y < 0 || texCoord.x >= texSizeI.x || texCoord.y >= texSizeI.y) {
    discard;
  }

  // texelFetch: integer coords, no interpolation, no precision issues
  float mask = texelFetch(u_texArray, ivec3(texCoord, int(v_texLayer)), 0).r;

  // Apply color matrix conversion (identity if no conversion needed)
  vec3 correctedColor = u_colorMatrix * v_color.rgb;

  // libass color alpha: 0 = opaque, 255 = transparent (inverted)
  float colorAlpha = 1.0 - v_color.a;

  // Final alpha = colorAlpha * mask
  float a = colorAlpha * mask;

  // Premultiplied alpha output
  fragColor = vec4(correctedColor * a, a);
}
`
  );
  var TEX_ARRAY_SIZE = 64;
  var TEX_INITIAL_SIZE = 256;
  var MAX_INSTANCES2 = 256;
  var WebGL2Renderer = class {
    canvas = null;
    gl = null;
    program = null;
    vao = null;
    // Uniform locations
    u_resolution = null;
    u_texArray = null;
    u_colorMatrix = null;
    // Instance attribute buffers
    instanceDestRectBuffer = null;
    instanceColorBuffer = null;
    instanceTexLayerBuffer = null;
    // Instance data arrays
    instanceDestRectData;
    instanceColorData;
    instanceTexLayerData;
    texArray = null;
    texArrayWidth = 0;
    texArrayHeight = 0;
    colorMatrix = IDENTITY_MATRIX;
    constructor() {
      this.instanceDestRectData = new Float32Array(MAX_INSTANCES2 * 4);
      this.instanceColorData = new Float32Array(MAX_INSTANCES2 * 4);
      this.instanceTexLayerData = new Float32Array(MAX_INSTANCES2);
    }
    _scheduledResize;
    resizeCanvas(width, height) {
      if (width <= 0 || height <= 0)
        return;
      this._scheduledResize = { width, height };
    }
    setCanvas(canvas) {
      this.canvas = canvas;
      this.gl = canvas.getContext("webgl2", {
        alpha: true,
        premultipliedAlpha: true,
        antialias: false,
        depth: false,
        preserveDrawingBuffer: false,
        stencil: false,
        desynchronized: true,
        powerPreference: "high-performance"
      });
      if (!this.gl) {
        throw new Error("Could not get WebGL2 context");
      }
      const vertexShader = this.createShader(this.gl.VERTEX_SHADER, VERTEX_SHADER2);
      const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, FRAGMENT_SHADER2);
      if (!vertexShader || !fragmentShader) {
        throw new Error("Failed to create shaders");
      }
      this.program = this.gl.createProgram();
      this.gl.attachShader(this.program, vertexShader);
      this.gl.attachShader(this.program, fragmentShader);
      this.gl.linkProgram(this.program);
      if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
        const info = this.gl.getProgramInfoLog(this.program);
        throw new Error("Failed to link program: " + info);
      }
      this.gl.deleteShader(vertexShader);
      this.gl.deleteShader(fragmentShader);
      this.u_resolution = this.gl.getUniformLocation(this.program, "u_resolution");
      this.u_texArray = this.gl.getUniformLocation(this.program, "u_texArray");
      this.u_colorMatrix = this.gl.getUniformLocation(this.program, "u_colorMatrix");
      this.instanceDestRectBuffer = this.gl.createBuffer();
      this.instanceColorBuffer = this.gl.createBuffer();
      this.instanceTexLayerBuffer = this.gl.createBuffer();
      this.vao = this.gl.createVertexArray();
      this.gl.bindVertexArray(this.vao);
      const destRectLoc = this.gl.getAttribLocation(this.program, "a_destRect");
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceDestRectBuffer);
      this.gl.enableVertexAttribArray(destRectLoc);
      this.gl.vertexAttribPointer(destRectLoc, 4, this.gl.FLOAT, false, 0, 0);
      this.gl.vertexAttribDivisor(destRectLoc, 1);
      const colorLoc = this.gl.getAttribLocation(this.program, "a_color");
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceColorBuffer);
      this.gl.enableVertexAttribArray(colorLoc);
      this.gl.vertexAttribPointer(colorLoc, 4, this.gl.FLOAT, false, 0, 0);
      this.gl.vertexAttribDivisor(colorLoc, 1);
      const texLayerLoc = this.gl.getAttribLocation(this.program, "a_texLayer");
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceTexLayerBuffer);
      this.gl.enableVertexAttribArray(texLayerLoc);
      this.gl.vertexAttribPointer(texLayerLoc, 1, this.gl.FLOAT, false, 0, 0);
      this.gl.vertexAttribDivisor(texLayerLoc, 1);
      this.gl.enable(this.gl.BLEND);
      this.gl.blendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
      this.gl.useProgram(this.program);
      this.gl.uniform1i(this.u_texArray, 0);
      this.gl.uniformMatrix3fv(this.u_colorMatrix, false, this.colorMatrix);
      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
      this.gl.clearColor(0, 0, 0, 0);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.createTexArray(TEX_INITIAL_SIZE, TEX_INITIAL_SIZE);
    }
    createShader(type, source) {
      const shader = this.gl.createShader(type);
      this.gl.shaderSource(shader, source);
      this.gl.compileShader(shader);
      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        const info = this.gl.getShaderInfoLog(shader);
        console.log(info);
        this.gl.deleteShader(shader);
        return null;
      }
      return shader;
    }
    // Set the color matrix for color space conversion.
    // Pass null or undefined to use identity (no conversion).
    setColorMatrix(subtitleColorSpace, videoColorSpace) {
      this.colorMatrix = (subtitleColorSpace && videoColorSpace && colorMatrixConversionMap[subtitleColorSpace]?.[videoColorSpace]) ?? IDENTITY_MATRIX;
      if (this.gl && this.u_colorMatrix && this.program) {
        this.gl.useProgram(this.program);
        this.gl.uniformMatrix3fv(this.u_colorMatrix, false, this.colorMatrix);
      }
    }
    createTexArray(width, height) {
      if (this.texArray) {
        this.gl.deleteTexture(this.texArray);
      }
      this.texArray = this.gl.createTexture();
      this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texArray);
      this.gl.texImage3D(
        this.gl.TEXTURE_2D_ARRAY,
        0,
        this.gl.R8,
        width,
        height,
        TEX_ARRAY_SIZE,
        0,
        this.gl.RED,
        this.gl.UNSIGNED_BYTE,
        null
        // Firefox cries about uninitialized data, but is slower with zero initialized data...
      );
      this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
      this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
      this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
      this.texArrayWidth = width;
      this.texArrayHeight = height;
    }
    render(images, heap) {
      if (!this.gl || !this.program || !this.vao || !this.texArray)
        return;
      if (self.HEAPU8RAW.buffer !== self.WASMMEMORY.buffer || SHOULD_REFERENCE_MEMORY) {
        heap = self.HEAPU8RAW = new Uint8Array(self.WASMMEMORY.buffer);
      }
      if (this._scheduledResize) {
        const { width, height } = this._scheduledResize;
        this._scheduledResize = void 0;
        this.canvas.width = width;
        this.canvas.height = height;
        this.gl.viewport(0, 0, width, height);
        this.gl.uniform2f(this.u_resolution, width, height);
      } else {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      }
      let maxW = this.texArrayWidth;
      let maxH = this.texArrayHeight;
      const validImages = [];
      for (const img of images) {
        if (img.w <= 0 || img.h <= 0)
          continue;
        validImages.push(img);
        if (img.w > maxW)
          maxW = img.w;
        if (img.h > maxH)
          maxH = img.h;
      }
      if (validImages.length === 0)
        return;
      if (maxW > this.texArrayWidth || maxH > this.texArrayHeight) {
        this.createTexArray(maxW, maxH);
      }
      const batchSize = Math.min(TEX_ARRAY_SIZE, MAX_INSTANCES2);
      for (let batchStart = 0; batchStart < validImages.length; batchStart += batchSize) {
        const batchEnd = Math.min(batchStart + batchSize, validImages.length);
        let instanceCount = 0;
        for (let i = batchStart; i < batchEnd; i++) {
          const img = validImages[i];
          const layer = instanceCount;
          this.gl.pixelStorei(this.gl.UNPACK_ROW_LENGTH, img.stride);
          if (IS_FIREFOX) {
            const sourceView = new Uint8Array(heap.buffer, img.bitmap, img.stride * img.h);
            const bitmapData = new Uint8Array(sourceView);
            this.gl.texSubImage3D(
              this.gl.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              layer,
              // x, y, z offset
              img.w,
              img.h,
              1,
              // depth (1 layer)
              this.gl.RED,
              this.gl.UNSIGNED_BYTE,
              bitmapData
            );
          } else {
            this.gl.texSubImage3D(
              this.gl.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              layer,
              // x, y, z offset
              img.w,
              img.h,
              1,
              // depth (1 layer)
              this.gl.RED,
              this.gl.UNSIGNED_BYTE,
              heap,
              img.bitmap
            );
          }
          const idx = instanceCount * 4;
          this.instanceDestRectData[idx] = img.dst_x;
          this.instanceDestRectData[idx + 1] = img.dst_y;
          this.instanceDestRectData[idx + 2] = img.w;
          this.instanceDestRectData[idx + 3] = img.h;
          this.instanceColorData[idx] = (img.color >>> 24 & 255) / 255;
          this.instanceColorData[idx + 1] = (img.color >>> 16 & 255) / 255;
          this.instanceColorData[idx + 2] = (img.color >>> 8 & 255) / 255;
          this.instanceColorData[idx + 3] = (img.color & 255) / 255;
          this.instanceTexLayerData[instanceCount] = layer;
          instanceCount++;
        }
        this.gl.pixelStorei(this.gl.UNPACK_ROW_LENGTH, 0);
        if (instanceCount === 0)
          continue;
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceDestRectBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.instanceDestRectData.subarray(0, instanceCount * 4), this.gl.DYNAMIC_DRAW);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceColorBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.instanceColorData.subarray(0, instanceCount * 4), this.gl.DYNAMIC_DRAW);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.instanceTexLayerBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.instanceTexLayerData.subarray(0, instanceCount), this.gl.DYNAMIC_DRAW);
        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, instanceCount);
      }
    }
    destroy() {
      if (this.gl) {
        if (this.texArray) {
          this.gl.deleteTexture(this.texArray);
          this.texArray = null;
        }
        if (this.instanceDestRectBuffer) {
          this.gl.deleteBuffer(this.instanceDestRectBuffer);
          this.instanceDestRectBuffer = null;
        }
        if (this.instanceColorBuffer) {
          this.gl.deleteBuffer(this.instanceColorBuffer);
          this.instanceColorBuffer = null;
        }
        if (this.instanceTexLayerBuffer) {
          this.gl.deleteBuffer(this.instanceTexLayerBuffer);
          this.instanceTexLayerBuffer = null;
        }
        if (this.vao) {
          this.gl.deleteVertexArray(this.vao);
          this.vao = null;
        }
        if (this.program) {
          this.gl.deleteProgram(this.program);
          this.program = null;
        }
        this.gl = null;
      }
    }
  };

  // node_modules/jassub/dist/worker/worker.js
  var ASSRenderer = class {
    _offCanvas;
    _wasm;
    _subtitleColorSpace;
    _videoColorSpace;
    _malloc;
    _gpurender;
    debug = false;
    _ready;
    constructor(data, getFont) {
      this._availableFonts = Object.fromEntries(Object.entries(data.availableFonts).map(([k, v]) => [k.trim().toLowerCase(), v]));
      this.debug = data.debug;
      this.queryFonts = data.queryFonts;
      this._getFont = getFont;
      this._defaultFont = data.defaultFont.trim().toLowerCase();
      const _fetch2 = globalThis.fetch;
      globalThis.fetch = (_) => _fetch2(data.wasmUrl);
      const handleMessage = ({ data: data2 }) => {
        if (data2.name === "offscreenCanvas") {
          this._offCanvas = data2.ctrl;
          this._gpurender.setCanvas(this._offCanvas);
          removeEventListener("message", handleMessage);
        }
      };
      addEventListener("message", handleMessage);
      try {
        const testCanvas = new OffscreenCanvas(1, 1);
        if (testCanvas.getContext("webgl2")) {
          this._gpurender = new WebGL2Renderer();
        } else {
          this._gpurender = testCanvas.getContext("webgl")?.getExtension("ANGLE_instanced_arrays") ? new WebGL1Renderer() : new Canvas2DRenderer();
        }
      } catch {
        this._gpurender = new Canvas2DRenderer();
      }
      this._ready = jassub_worker_default({ __url: data.wasmUrl, __out: (log) => this._log(log) }).then(async ({ _malloc, JASSUB }) => {
        this._malloc = _malloc;
        this._wasm = new JASSUB(data.width, data.height, this._defaultFont);
        this._wasm.setThreads(THREAD_COUNT);
        this._loadInitialFonts(data.fonts);
        this._wasm.createTrackMem(data.subContent ?? await fetchtext(data.subUrl));
        this._subtitleColorSpace = LIBASS_YCBCR_MAP[this._wasm.trackColorSpace];
        if (data.libassMemoryLimit > 0 || data.libassGlyphLimit > 0) {
          this._wasm.setMemoryLimits(data.libassGlyphLimit || 0, data.libassMemoryLimit || 0);
        }
        this._checkColorSpace();
      });
    }
    ready() {
      return this._ready;
    }
    createEvent(event) {
      _applyKeys(event, this._wasm.getEvent(this._wasm.allocEvent()));
    }
    getEvents() {
      const events = [];
      for (let i = 0; i < this._wasm.getEventCount(); i++) {
        const { Start, Duration, ReadOrder, Layer, Style, MarginL, MarginR, MarginV, Name, Text, Effect } = this._wasm.getEvent(i);
        events.push({ Start, Duration, ReadOrder, Layer, Style, MarginL, MarginR, MarginV, Name, Text, Effect });
      }
      return events;
    }
    setEvent(event, index) {
      _applyKeys(event, this._wasm.getEvent(index));
    }
    removeEvent(index) {
      this._wasm.removeEvent(index);
    }
    createStyle(style) {
      const alloc = this._wasm.getStyle(this._wasm.allocStyle());
      _applyKeys(style, alloc);
      return alloc;
    }
    getStyles() {
      const styles = [];
      for (let i = 0; i < this._wasm.getStyleCount(); i++) {
        const { Name, FontName, FontSize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding, treat_fontname_as_pattern, Blur, Justify } = this._wasm.getStyle(i);
        styles.push({ Name, FontName, FontSize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding, treat_fontname_as_pattern, Blur, Justify });
      }
      return styles;
    }
    setStyle(style, index) {
      _applyKeys(style, this._wasm.getStyle(index));
    }
    removeStyle(index) {
      this._wasm.removeStyle(index);
    }
    styleOverride(style) {
      this._wasm.styleOverride(this.createStyle(style));
    }
    disableStyleOverride() {
      this._wasm.disableStyleOverride();
    }
    setTrack(content) {
      this._wasm.createTrackMem(content);
      this._subtitleColorSpace = LIBASS_YCBCR_MAP[this._wasm.trackColorSpace];
    }
    freeTrack() {
      this._wasm.removeTrack();
    }
    async setTrackByUrl(url) {
      this.setTrack(await fetchtext(url));
    }
    _checkColorSpace() {
      if (!this._subtitleColorSpace || !this._videoColorSpace)
        return;
      this._gpurender.setColorMatrix(this._subtitleColorSpace, this._videoColorSpace);
    }
    _defaultFont;
    setDefaultFont(fontName) {
      this._defaultFont = fontName.trim().toLowerCase();
      this._wasm.setDefaultFont(this._defaultFont);
    }
    async _log(log) {
      console.debug(log);
      const match = log.match(/JASSUB: fontselect:[^(]+: \(([^,]+), (\d{1,4}), \d\)/);
      if (match && !await this._findAvailableFont(match[1].trim().toLowerCase(), WEIGHT_MAP2[Math.ceil(parseInt(match[2]) / 100) - 1])) {
        await this._findAvailableFont(this._defaultFont);
      }
    }
    async addFonts(fontOrURLs) {
      if (!fontOrURLs.length)
        return;
      const strings = [];
      const uint8s = [];
      for (const fontOrURL of fontOrURLs) {
        if (typeof fontOrURL === "string") {
          strings.push(fontOrURL);
        } else {
          uint8s.push(fontOrURL);
        }
      }
      if (uint8s.length)
        this._allocFonts(uint8s);
      return await Promise.allSettled(strings.map((url) => this._asyncWrite(url)));
    }
    // we don't want to run _findAvailableFont before initial fonts are loaded
    // because it could duplicate fonts
    _loadedInitialFonts = false;
    async _loadInitialFonts(fontOrURLs) {
      await this.addFonts(fontOrURLs);
      this._loadedInitialFonts = true;
    }
    _getFont;
    _availableFonts = {};
    _checkedFonts = /* @__PURE__ */ new Set();
    async _findAvailableFont(fontName, weight) {
      if (!this._loadedInitialFonts)
        return;
      for (const _weight of WEIGHT_MAP2) {
        if (fontName.includes(_weight)) {
          fontName = fontName.replace(_weight, "").trim();
          weight ??= _weight;
          break;
        }
      }
      weight ??= "regular";
      const key = fontName + " " + weight;
      if (this._checkedFonts.has(key))
        return;
      this._checkedFonts.add(key);
      try {
        const font = this._availableFonts[key] ?? this._availableFonts[fontName] ?? await this._queryLocalFont(fontName, weight) ?? await this._queryRemoteFont([key, fontName]);
        if (font)
          return await this.addFonts([font]);
      } catch (e) {
        console.warn("Error querying font", fontName, weight, e);
      }
    }
    queryFonts;
    async _queryLocalFont(fontName, weight) {
      if (!this.queryFonts)
        return;
      return await this._getFont(fontName, weight);
    }
    async _queryRemoteFont(postscriptNames) {
      if (this.queryFonts !== "localandremote")
        return;
      const fontData = await queryRemoteFonts({ postscriptNames });
      if (!fontData.length)
        return;
      const blob = await fontData[0].blob();
      return new Uint8Array(await blob.arrayBuffer());
    }
    async _asyncWrite(font) {
      const res = await _fetch(font);
      this._allocFonts([new Uint8Array(await res.arrayBuffer())]);
    }
    _fontId = 0;
    _allocFonts(uint8s) {
      for (const uint8 of uint8s) {
        const ptr = this._malloc(uint8.byteLength);
        self.HEAPU8RAW.set(uint8, ptr);
        this._wasm.addFont("font-" + this._fontId++, ptr, uint8.byteLength);
      }
      this._wasm.reloadFonts();
    }
    _resizeCanvas(width, height, videoWidth, videoHeight) {
      this._wasm.resizeCanvas(width, height, videoWidth, videoHeight);
      this._gpurender.resizeCanvas(width, height);
    }
    async [finalizer]() {
      await this._ready;
      this._wasm.quitLibrary();
      this._gpurender.destroy();
      this._wasm = null;
      this._gpurender = null;
      this._availableFonts = {};
    }
    _draw(time, repaint = false) {
      if (!this._offCanvas || !this._gpurender)
        return;
      const result = this._wasm.rawRender(time, Number(repaint));
      if (this._wasm.changed === 0 && !repaint)
        return;
      const bitmaps = [];
      for (let image = result, i = 0; i < this._wasm.count; image = image.next, ++i) {
        bitmaps.push({
          bitmap: image.bitmap,
          color: image.color,
          dst_x: image.dst_x,
          dst_y: image.dst_y,
          h: image.h,
          stride: image.stride,
          w: image.w
        });
      }
      this._gpurender.render(bitmaps, self.HEAPU8RAW);
    }
    _setColorSpace(videoColorSpace) {
      if (videoColorSpace === "RGB")
        return;
      this._videoColorSpace = videoColorSpace;
      this._checkColorSpace();
    }
  };
  if (self.name === "jassub-worker") {
    expose2(ASSRenderer);
  }
})();
