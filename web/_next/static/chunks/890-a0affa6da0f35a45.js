"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[890],{23890:function(e,t,r){r.d(t,{Dv:function(){return useAtomValue},KO:function(){return useAtom},b9:function(){return useSetAtom},oR:function(){return useStore},zt:function(){return Provider}});var o=r(2265),n=r(77665);let a=(0,o.createContext)(void 0),useStore=e=>{let t=(0,o.useContext)(a);return(null==e?void 0:e.store)||t||(0,n.K7)()},Provider=({children:e,store:t})=>{let r=(0,o.useRef)();return t||r.current||(r.current=(0,n.MT)()),(0,o.createElement)(a.Provider,{value:t||r.current},e)},isPromiseLike=e=>"function"==typeof(null==e?void 0:e.then),l=o.use||(e=>{if("pending"===e.status)throw e;if("fulfilled"===e.status)return e.value;if("rejected"===e.status)throw e.reason;throw e.status="pending",e.then(t=>{e.status="fulfilled",e.value=t},t=>{e.status="rejected",e.reason=t}),e});function useAtomValue(e,t){let r=useStore(t),[[n,a,u],i]=(0,o.useReducer)(t=>{let o=r.get(e);return Object.is(t[0],o)&&t[1]===r&&t[2]===e?t:[o,r,e]},void 0,()=>[r.get(e),r,e]),s=n;(a!==r||u!==e)&&(i(),s=r.get(e));let m=null==t?void 0:t.delay;return(0,o.useEffect)(()=>{let t=r.sub(e,()=>{if("number"==typeof m){setTimeout(i,m);return}i()});return i(),t},[r,e,m]),(0,o.useDebugValue)(s),isPromiseLike(s)?l(s):s}function useSetAtom(e,t){let r=useStore(t),n=(0,o.useCallback)((...t)=>{if(!("write"in e))throw Error("not writable atom");return r.set(e,...t)},[r,e]);return n}function useAtom(e,t){return[useAtomValue(e,t),useSetAtom(e,t)]}},77665:function(e,t,r){let o;r.d(t,{K7:function(){return getDefaultStore},MT:function(){return createStore},cn:function(){return atom}});let n=0;function atom(e,t){let r=`atom${++n}`,o={toString:()=>r};return"function"==typeof e?o.read=e:(o.init=e,o.read=function(e){return e(this)},o.write=function(e,t,r){return t(this,"function"==typeof r?r(e(this)):r)}),t&&(o.write=t),o}let hasInitialValue=e=>"init"in e,isActuallyWritableAtom=e=>!!e.write,a=new WeakMap,registerCancelPromise=(e,t)=>{a.set(e,t),e.catch(()=>{}).finally(()=>a.delete(e))},cancelPromise=(e,t)=>{let r=a.get(e);r&&(a.delete(e),r(t))},resolvePromise=(e,t)=>{e.status="fulfilled",e.value=t},rejectPromise=(e,t)=>{e.status="rejected",e.reason=t},isPromiseLike=e=>"function"==typeof(null==e?void 0:e.then),isEqualAtomValue=(e,t)=>!!e&&"v"in e&&"v"in t&&Object.is(e.v,t.v),isEqualAtomError=(e,t)=>!!e&&"e"in e&&"e"in t&&Object.is(e.e,t.e),hasPromiseAtomValue=e=>!!e&&"v"in e&&e.v instanceof Promise,isEqualPromiseAtomValue=(e,t)=>"v"in e&&"v"in t&&e.v.orig&&e.v.orig===t.v.orig,returnAtomValue=e=>{if("e"in e)throw e.e;return e.v},createStore=()=>{let e,t;let r=new WeakMap,o=new WeakMap,n=new Map;e=new Set,t=new Set;let getAtomState=e=>r.get(e),setAtomState=(e,t)=>{Object.freeze(t);let o=r.get(e);if(r.set(e,t),n.has(e)||n.set(e,o),hasPromiseAtomValue(o)){let e="v"in t?t.v instanceof Promise?t.v:Promise.resolve(t.v):Promise.reject(t.e);o.v!==e&&cancelPromise(o.v,e)}},updateDependencies=(e,t,r)=>{let o=new Map,n=!1;r.forEach((r,a)=>{r||a!==e||(r=t),r?(o.set(a,r),t.d.get(a)!==r&&(n=!0)):console.warn("[Bug] atom state not found")}),(n||t.d.size!==o.size)&&(t.d=o)},setAtomValue=(e,t,r)=>{let o=getAtomState(e),n={d:(null==o?void 0:o.d)||new Map,v:t};if(r&&updateDependencies(e,n,r),isEqualAtomValue(o,n)&&o.d===n.d)return o;if(hasPromiseAtomValue(o)&&hasPromiseAtomValue(n)&&isEqualPromiseAtomValue(o,n)){if(o.d===n.d)return o;n.v=o.v}return setAtomState(e,n),n},setAtomValueOrPromise=(e,t,r,n)=>{if(isPromiseLike(t)){let a;let updatePromiseDependencies=()=>{let t=getAtomState(e);if(!hasPromiseAtomValue(t)||t.v!==l)return;let n=setAtomValue(e,l,r);o.has(e)&&t.d!==n.d&&mountDependencies(e,n,t.d)},l=new Promise((e,r)=>{let o=!1;t.then(t=>{o||(o=!0,resolvePromise(l,t),e(t),updatePromiseDependencies())},e=>{o||(o=!0,rejectPromise(l,e),r(e),updatePromiseDependencies())}),a=t=>{o||(o=!0,t.then(e=>resolvePromise(l,e),e=>rejectPromise(l,e)),e(t))}});return l.orig=t,l.status="pending",registerCancelPromise(l,e=>{e&&a(e),null==n||n()}),setAtomValue(e,l,r)}return setAtomValue(e,t,r)},setAtomError=(e,t,r)=>{let o=getAtomState(e),n={d:(null==o?void 0:o.d)||new Map,e:t};return(r&&updateDependencies(e,n,r),isEqualAtomError(o,n)&&o.d===n.d)?o:(setAtomState(e,n),n)},readAtomState=(e,t)=>{let r,n;let a=getAtomState(e);if(!t&&a&&(o.has(e)||Array.from(a.d).every(([t,r])=>{if(t===e)return!0;let o=readAtomState(t);return o===r||isEqualAtomValue(o,r)})))return a;let l=new Map,u=!0;try{let t=e.read(t=>{if(t===e){let e=getAtomState(t);if(e)return l.set(t,e),returnAtomValue(e);if(hasInitialValue(t))return l.set(t,void 0),t.init;throw Error("no atom init")}let r=readAtomState(t);return l.set(t,r),returnAtomValue(r)},{get signal(){return r||(r=new AbortController),r.signal},get setSelf(){return isActuallyWritableAtom(e)||console.warn("setSelf function cannot be used with read-only atom"),!n&&isActuallyWritableAtom(e)&&(n=(...t)=>{if(u&&console.warn("setSelf function cannot be called in sync"),!u)return writeAtom(e,...t)}),n}});return setAtomValueOrPromise(e,t,l,()=>null==r?void 0:r.abort())}catch(t){return setAtomError(e,t,l)}finally{u=!1}},addAtom=e=>{let t=o.get(e);return t||(t=mountAtom(e)),t},canUnmountAtom=(e,t)=>!t.l.size&&(!t.t.size||1===t.t.size&&t.t.has(e)),delAtom=e=>{let t=o.get(e);t&&canUnmountAtom(e,t)&&unmountAtom(e)},recomputeDependents=e=>{let t=new Map,r=new WeakMap,getDependents=e=>{var t;let r=new Set(null==(t=o.get(e))?void 0:t.t);return n.forEach((t,o)=>{var n;(null==(n=getAtomState(o))?void 0:n.d.has(e))&&r.add(o)}),r},loop1=e=>{getDependents(e).forEach(o=>{o!==e&&(t.set(o,(t.get(o)||new Set).add(e)),r.set(o,(r.get(o)||0)+1),loop1(o))})};loop1(e);let loop2=e=>{getDependents(e).forEach(o=>{var n;if(o!==e){let e=r.get(o);if(e&&r.set(o,--e),!e){let e=!!(null==(n=t.get(o))?void 0:n.size);if(e){let t=getAtomState(o),r=readAtomState(o,!0);e=!isEqualAtomValue(t,r)}e||t.forEach(e=>e.delete(o))}loop2(o)}})};loop2(e)},writeAtomState=(t,...r)=>{let o=!0,n=t.write(e=>returnAtomValue(readAtomState(e)),(r,...n)=>{let a;if(r===t){if(!hasInitialValue(r))throw Error("atom not writable");let e=getAtomState(r),t=setAtomValueOrPromise(r,n[0]);isEqualAtomValue(e,t)||recomputeDependents(r)}else a=writeAtomState(r,...n);if(!o){let t=flushPending();e.forEach(e=>e({type:"async-write",flushed:t}))}return a},...r);return o=!1,n},writeAtom=(t,...r)=>{let o=writeAtomState(t,...r),n=flushPending();return e.forEach(e=>e({type:"write",flushed:n})),o},mountAtom=(e,r,n)=>{var a;let l=n||[];null==(a=getAtomState(e))||a.d.forEach((t,r)=>{let n=o.get(r);n?n.t.add(e):r!==e&&mountAtom(r,e,l)}),readAtomState(e);let u={t:new Set(r&&[r]),l:new Set};if(o.set(e,u),t.add(e),isActuallyWritableAtom(e)&&e.onMount){let{onMount:t}=e;l.push(()=>{let r=t((...t)=>writeAtom(e,...t));r&&(u.u=r)})}return n||l.forEach(e=>e()),u},unmountAtom=e=>{var r;let n=null==(r=o.get(e))?void 0:r.u;n&&n(),o.delete(e),t.delete(e);let a=getAtomState(e);a?(hasPromiseAtomValue(a)&&cancelPromise(a.v),a.d.forEach((t,r)=>{if(r!==e){let t=o.get(r);t&&(t.t.delete(e),canUnmountAtom(r,t)&&unmountAtom(r))}})):console.warn("[Bug] could not find atom state to unmount",e)},mountDependencies=(e,t,r)=>{let n=new Set(t.d.keys());null==r||r.forEach((t,r)=>{if(n.has(r)){n.delete(r);return}let a=o.get(r);a&&(a.t.delete(e),canUnmountAtom(r,a)&&unmountAtom(r))}),n.forEach(t=>{let r=o.get(t);r?r.t.add(e):o.has(e)&&mountAtom(t,e)})},flushPending=()=>{let e;for(e=new Set;n.size;){let t=Array.from(n);n.clear(),t.forEach(([t,r])=>{let n=getAtomState(t);if(n){let a=o.get(t);a&&n.d!==(null==r?void 0:r.d)&&mountDependencies(t,n,null==r?void 0:r.d),a&&!(!hasPromiseAtomValue(r)&&(isEqualAtomValue(r,n)||isEqualAtomError(r,n)))&&(a.l.forEach(e=>e()),e.add(t))}else console.warn("[Bug] no atom state to flush")})}return e};return{get:e=>returnAtomValue(readAtomState(e)),set:writeAtom,sub:(t,r)=>{let o=addAtom(t),n=flushPending(),a=o.l;return a.add(r),e.forEach(e=>e({type:"sub",flushed:n})),()=>{a.delete(r),delAtom(t),e.forEach(e=>e({type:"unsub"}))}},dev_subscribe_store:(t,r)=>{if(2!==r)throw Error("The current StoreListener revision is 2.");return e.add(t),()=>{e.delete(t)}},dev_get_mounted_atoms:()=>t.values(),dev_get_atom_state:e=>r.get(e),dev_get_mounted:e=>o.get(e),dev_restore_atoms:t=>{for(let[e,r]of t)hasInitialValue(e)&&(setAtomValueOrPromise(e,r),recomputeDependents(e));let r=flushPending();e.forEach(e=>e({type:"restore",flushed:r}))}}};"number"==typeof globalThis.__NUMBER_OF_JOTAI_INSTANCES__?++globalThis.__NUMBER_OF_JOTAI_INSTANCES__:globalThis.__NUMBER_OF_JOTAI_INSTANCES__=1;let getDefaultStore=()=>(o||(1!==globalThis.__NUMBER_OF_JOTAI_INSTANCES__&&console.warn("Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"),o=createStore()),o)}}]);