# Contribution Guide

All contributions are welcome. If you're not sure about something, feel free to ask.

1. Fork it
2. Create your feature branch (`git checkout -b new-feature`)
3. Commit your changes (`git commit -am 'Added a feature'`)
4. Push to the branch (`git push origin new-feature`)
5. Create new Pull Request

# Development

![](./docs/images/charts/overview.png)
![](./docs/images/charts/autodownloader_overview.png)


As you can see from the overview, Seanime is divided into two main parts: the server and the web interface.
Once the server starts, an **App** struct is instantiated and passed to the different **route handlers** by reference.
Think of it as a big hub containing pointers to instantiated **shared services** that the handlers will pass to **localized route-level services** before calling the business logic.

For example, the **AnilistCollection** struct is fetched once and passed by reference to the **App** struct. It is then
accessible by the different route handlers. A route executing business logic might use it or other shared services.

Other services like the **Scanner** are instantiated at the route handler level since they are not used by any other service.
Though, the **Scanner** may need a pointer to a shared service like **AnilistCollection**, which is given by the **App** struct.

All services only depend on a specific set of packages instead of the whole **App** struct. It is a form of dependency injection. This makes them testable and easy to reason about.
For example, the **Scanner** doesn't depend on the **AutoDownloader** and vice versa.

## Server

```bash
go run cmd/main.go
```

### AniList GraphQL API

Anilist structs are autogenerated using gqlgenc `internal/anilist/queries/*.graphql`.

Run this when you make changes to the GraphQL schema.

```bash
go get github.com/Yamashou/gqlgenc
cd internal/anilist
go run github.com/Yamashou/gqlgenc
cd ../..
go mod tidy
```

`internal/anilist/client.go` reimplements the different queries and mutations into a `ClientWrapper` struct for packages and a `MockClientWrapper` for testing.

### Tests

**Do not** run the tests all at once. Run them **individually** if you have to.

You should:
- Create a dummy AniList account and grab the access token (from the browser).
- Edit the `test/config.toml` file with the access token and the username. Use `config.example.toml` as a template.

Tests are run using the `test_utils` package. It provides a `InitTestProvider` method that initializes the test config global variable.
This global variable contains the values from the `test/config.toml` file.

```go
func (t *testing.T) {
	test_utils.InitTestProvider(t, test_utils.Anilist())
}
```

As you can see, it also takes functions as arguments. Those functions merely skip the test if the corresponding flag is not enabled in the `test/config.toml` file.

#### Testing with AniList API

The `anilist` package exports a `MockClientWrapper` that you can use to test different packages that depend on the AniList API. (you can access it by calling `anilist.TestGetMockAnilistClientWrapper()`)

When testing a package that requires the user's **AnimeCollection**, the mock client will return a dummy collection stored in `test/daa/BoilerplateAnimeCollection.json` when 
`anilistClientWrapper.AnimeCollection` is called with a nil username.

```go
package test

import (
	"testing"
	"internal/test_utils"
	"internal/api/anilist"
)

func Test(t *testing.T) {
	test_utils.InitTestProvider(t, test_utils.Anilist())
	
	anilistClientWrapper := anilist.TestGetMockAnilistClientWrapper()
	// Called with a nil username
    // `anilistCollection` will contain the dummy collection
    anilistCollection, err := anilistClientWrapper.AnimeCollection(context.Background(), nil)
    if err != nil {
    	t.Fatal(err)
    }
}
```

Not all methods are implemented in the mock client. You can add more methods to the mock client if you need them.

When you pass a username, let's say your dummy account's, using `test_utils.ConfigData.Provider.AnilistUsername`,
the mock client will fetch it using a real request and store it in `test/testdata/AnimeCollection.json` and return it. This file will be used for subsequent calls.
(This is just to avoid making too many requests to the AniList API).

Same goes for `anilistClientWrapper.GetBaseMediaById`, `anilistClientWrapper.GetBasicMediaById` and `anilistClientWrapper.GetBasicMediaByMalId`.

#### Testing third-party apps

Some tests will directly interact with third-party apps such as Transmission and qBittorrent. You should have them installed and running on your machine.
Edit the individual test files to match your setup (e.g. port, password, files to open, etc.)

## Web

### Development

```bash
cd seanime-web
```

```bash
npm install
```

```bash
npm run dev
```

- Go to `http://127.0.0.1:43210` to see the web interface.
- Notice that the port is different from the server. It won't be an issue except for trying to authenticate with MyAnimeList.

### Build

To run a built web interface with the server like in a normal setup (i.e. accessible from `http://127.0.0.1:43211`),
you will need to run:

```bash
npm run build
```

A `out` directory will be created under the `seanime-web` folder.

You have two options:
- Change the web directory path in your Seanime `config.toml` to point to the `out` folder.
- Or, move the contents of `/seanime-web/out` to the root of the project in a folder called `web`.
